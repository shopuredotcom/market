<!DOCTYPE html>
<html lang="en">
<head>
    <!-- =====================================================
         BASIC & COMPATIBILITY
    ====================================================== -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="ShoPure - Professional E-commerce Platform with Advanced Analytics and Secure Shopping">
    <meta name="keywords" content="ecommerce, shopping, electronics, fashion, home, beauty, sports">
    <meta name="author" content="ShoPure">
    <title>ShoPureDotCom - Professional E-commerce Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">


    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Mobile Friendly -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- =====================================================
         TITLE & SEO (SAFE FOR NO DOMAIN)
    ====================================================== -->
    <title>ShoPure™ | Smart & Secure E-commerce Experience</title>

    <meta name="description" content="ShoPure™ is a modern e-commerce platform featuring electronics, fashion, home, beauty & more with a secure and premium shopping experience.">
    <meta name="keywords" content="ShoPure, ecommerce, online shopping, electronics, fashion, beauty, secure shopping">
    <meta name="author" content="ShoPure">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">

    <!-- Canonical (SAFE even without domain) -->
    <link rel="canonical" href="./">

    <!-- =====================================================
         BRANDING / FAVICON (ADD FILES LATER)
    ====================================================== -->
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

    <!-- =====================================================
         THEME / UI COLORS
    ====================================================== -->
    <meta name="theme-color" content="#000000">
    <meta name="color-scheme" content="light dark">

    <!-- =====================================================
         OPEN GRAPH (SOCIAL SHARING – SAFE OFFLINE)
    ====================================================== -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="ShoPure™ – Smart E-commerce Platform">
    <meta property="og:description" content="Discover trending products and enjoy a secure, modern shopping experience with ShoPure™.">
    <meta property="og:image" content="og-image.jpg">
    <meta property="og:url" content="./">
    <meta property="og:site_name" content="ShoPure">

    <!-- =====================================================
         TWITTER / X PREVIEW
    ====================================================== -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ShoPure™ – Modern Online Shopping">
    <meta name="twitter:description" content="Electronics, fashion, beauty & more — shop smarter with ShoPure™.">
    <meta name="twitter:image" content="og-image.jpg">

    <!-- =====================================================
         PERFORMANCE OPTIMIZATION
    ====================================================== -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">

    <!-- =====================================================
         FONTS (OPTIONAL – SAFE)
    ====================================================== -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- =====================================================
         ICON LIBRARY (LOAD ONCE – NO DUPLICATES)
    ====================================================== -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
          integrity="sha512-papNMZl+ZP6XkzU+QxJpFv6l8y5H+YpTnR5c1mX4nZzJYpJ5n0V0C5GvZl6b3Rz0X9E7pZJpZ3r1kN0zEA=="
          crossorigin="anonymous"
          referrerpolicy="no-referrer">

    <!-- =====================================================
         SECURITY (SAFE, NON-BREAKING)
    ====================================================== -->
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

    <!-- =====================================================
         PWA SUPPORT (OPTIONAL – ADD FILE LATER)
    ====================================================== -->
    <link rel="manifest" href="manifest.json">

    <!-- =====================================================
         STRUCTURED DATA (SEO – SAFE WITHOUT DOMAIN)
    ====================================================== -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "ShoPure",
      "description": "Modern and secure e-commerce platform",
      "logo": "logo.png",
      "sameAs": []
    }
    </script>

    <style>
        /* ===== CSS RESET & VARIABLES ===== */
        :root {
            --primary-color: #000000;
            --secondary-color: #111111;
            --accent-color: #333333;
            --background-color: #FFFFFF;
            --surface-color: #F5F5F7;
            --border-color: #E5E5E7;
            --text-primary: #000000;
            --text-secondary: #666666;
            --text-white: #FFFFFF;
            --error-color: #FF3B30;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --info-color: #007AFF;
            --shadow-light: 0 2px 12px rgba(0,0,0,0.08);
            --shadow-medium: 0 4px 20px rgba(0,0,0,0.12);
            --shadow-dark: 0 8px 32px rgba(0,0,0,0.2);
            --blur-bg: rgba(255, 255, 255, 0.95);
            --blur-bg-dark: rgba(0, 0, 0, 0.95);
            --radius: 10px;
            --radius-sm: 5px;
            --radius-lg: 10px;
            --transition-fast: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            --transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            --gradient-primary: linear-gradient(135deg, #000000 0%, #333333 100%);
            --gradient-secondary: linear-gradient(135deg, #FFFFFF 0%, #F5F5F7 100%);
        }

        .dark-mode {
            --primary-color: #FFFFFF;
            --secondary-color: #F5F5F7;
            --accent-color: #8E8E93;
            --background-color: #000000;
            --surface-color: #1C1C1E;
            --border-color: #777779;
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --text-white: #000000;
            --blur-bg: rgba(28, 28, 30, 0.95);
            --gradient-primary: linear-gradient(135deg, #FFFFFF 0%, #8E8E93 100%);
            --gradient-secondary: linear-gradient(135deg, #1C1C1E 0%, #2C2C2E 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            font-size: 16px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
            transition: var(--transition);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ===== TYPOGRAPHY ===== */
        h1, h2, h3, h4, h5, h6 {
            font-weight: 700;
            line-height: 1.2;
            margin-bottom: 1rem;
        }

        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.25rem; }
        h5 { font-size: 1.125rem; }
        h6 { font-size: 1rem; }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            h2 { font-size: 1.75rem; }
            h3 { font-size: 1.375rem; }
        }

        p {
            margin-bottom: 1rem;
        }

        a {
            color: inherit;
            text-decoration: none;
            transition: var(--transition-fast);
        }

        /* ===== UTILITY CLASSES ===== */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }

        .flex {
            display: flex;
        }

        .flex-center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .flex-between {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .flex-column {
            flex-direction: column;
        }

        .grid {
            display: grid;
        }

        .container {
            width: 100%;
            max-width: 1680px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .container-fluid {
            width: 100%;
            padding: 0 20px;
        }

        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }

        .mb-0 { margin-bottom: 0; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-3 { margin-bottom: 1rem; }
        .mb-4 { margin-bottom: 1.5rem; }
        .mb-5 { margin-bottom: 2rem; }
        .mb-6 { margin-bottom: 3rem; }

        .mt-0 { margin-top: 0; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-3 { margin-top: 1rem; }
        .mt-4 { margin-top: 1.5rem; }
        .mt-5 { margin-top: 2rem; }

        .p-0 { padding: 0; }
        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 1rem; }
        .p-4 { padding: 1.5rem; }
        .p-5 { padding: 2rem; }

        .gap-1 { gap: 0.25rem; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 1rem; }
        .gap-4 { gap: 1.5rem; }
        .gap-5 { gap: 2rem; }

        .rounded { border-radius: var(--radius); }
        .rounded-sm { border-radius: var(--radius-sm); }
        .rounded-lg { border-radius: var(--radius-lg); }

        .shadow-sm { box-shadow: var(--shadow-light); }
        .shadow { box-shadow: var(--shadow-medium); }
        .shadow-lg { box-shadow: var(--shadow-dark); }

        .text-primary { color: var(--primary-color); }
        .text-secondary { color: var(--text-secondary); }
        .text-success { color: var(--success-color); }
        .text-error { color: var(--error-color); }
        .text-warning { color: var(--warning-color); }
        .text-info { color: var(--info-color); }

        .bg-surface { background-color: var(--surface-color); }
        .bg-primary { background-color: var(--primary-color); }
        .bg-secondary { background-color: var(--secondary-color); }

        .glass {
            background: var(--blur-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .dark-mode .glass {
            background: var(--blur-bg-dark);
        }

        .gradient-primary {
            background: var(--gradient-primary);
        }

        .gradient-secondary {
            background: var(--gradient-secondary);
        }

        .animate-fade-in {
            animation: fadeIn 0.5s ease;
        }

        .animate-slide-up {
            animation: slideUp 0.4s ease;
        }

        .animate-slide-down {
            animation: slideDown 0.4s ease;
        }

        .animate-slide-left {
            animation: slideLeft 0.4s ease;
        }

        .animate-slide-right {
            animation: slideRight 0.4s ease;
        }

        .animate-scale {
            animation: scale 0.3s ease;
        }

        .animate-pulse {
            animation: pulse 2s infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideLeft {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideRight {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes scale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* ===== SCROLLBAR ===== */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--surface-color);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 10px;
            transition: var(--transition);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* ===== LOADER ===== */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .loader-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid var(--surface-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ===== HEADER ===== */
        .header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--blur-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .header.scrolled {
            box-shadow: var(--shadow-light);
        }

        .header-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
            height: 70px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
            font-weight: 900;
            font-size: 1.5rem;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: var(--gradient-primary);
            color: var(--text-white);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 900;
        }

        .dark-mode .logo-icon {
            color: var(--background-color);
        }

        .logo-text {
            display: none;
        }

        .search-container {
            flex: 1;
            max-width: 600px;
            margin: 0 2rem;
            position: relative;
        }

        .search-wrapper {
            display: flex;
            height: 44px;
            border-radius: var(--radius);
            overflow: hidden;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            transition: var(--transition);
        }

        .search-wrapper:focus-within {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.1);
        }

        .dark-mode .search-wrapper:focus-within {
            box-shadow: 0 0 0 3px rgba(255,255,255,0.1);
        }

        .category-select {
            width: 100px;
            background: var(--background-color);
            border: none;
            color: var(--text-primary);
            font-size: 0.875rem;
            padding: 0 1rem;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'%3E%3C/path%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 16px;
        }

        .category-select:focus {
            outline: none;
        }

        .search-input {
            flex: 1;
            border: none;
            padding: 0 1rem;
            font-size: 0.9375rem;
            background: transparent;
            color: var(--text-primary);
            min-width: 0;
        }

        .search-input:focus {
            outline: none;
        }

        .search-btn {
            width: 50px;
            background: var(--primary-color);
            color: var(--text-white);
            border: none;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .search-btn:hover {
            background: var(--secondary-color);
        }

        .dark-mode .search-btn {
            background: var(--text-primary);
            color: var(--background-color);
        }

        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: var(--blur-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 var(--radius) var(--radius);
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 1001;
            box-shadow: var(--shadow-medium);
        }

        .search-suggestions.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .suggestion-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .suggestion-item:hover {
            background: var(--surface-color);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            margin-right: 0.75rem;
        }

        .suggestion-info {
            flex: 1;
            min-width: 0;
        }

        .suggestion-name {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-price {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .dark-mode .suggestion-price {
            color: var(--text-primary);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-action {
            position: relative;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1.25rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
        }

        .header-action:hover {
            background: var(--surface-color);
            transform: translateY(-2px);
        }

        .action-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--error-color);
            color: var(--text-white);
            font-size: 0.6875rem;
            font-weight: 700;
            min-width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            border: 2px solid var(--background-color);
        }

        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
        }

        .menu-toggle:hover {
            background: var(--surface-color);
        }

        /* ===== MOBILE MENU ===== */
        .mobile-menu {
            position: fixed;
            top: 0;
            right: -100%;
            width: 320px;
            height: 100vh;
            background: var(--blur-bg);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            z-index: 2000;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-dark);
            overflow: hidden;
        }

        .mobile-menu.active {
            right: 0;
        }

        .mobile-menu-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .mobile-menu-close {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
        }

        .mobile-menu-close:hover {
            background: var(--surface-color);
        }

        .mobile-menu-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .mobile-menu-content::-webkit-scrollbar {
            width: 4px;
        }

        .mobile-menu-section {
            margin-bottom: 2rem;
        }

        .mobile-menu-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mobile-menu-items {
            list-style: none;
        }

        .mobile-menu-item {
            margin-bottom: 0.5rem;
        }

        .mobile-menu-link {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            text-decoration: none;
            border-radius: var(--radius-sm);
            transition: var(--transition-fast);
        }

        .mobile-menu-link:hover {
            background: var(--surface-color);
            transform: translateX(4px);
        }

        .mobile-menu-link i {
            width: 20px;
            text-align: center;
            font-size: 1.125rem;
        }

        /* ===== MAIN CONTENT ===== */
        .main-content {
            min-height: calc(100vh - 200px);
            padding: 2rem 0;
        }

        .page {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .page.active {
            display: block;
            opacity: 1;
            animation: fadeIn 0.5s ease;
        }

        /* ===== HOME PAGE ===== */
        .slider-container {
            position: relative;
            width: 100%;
            height: 500px;
            border-radius: var(--radius-lg);
            overflow: hidden;
            margin-bottom: 3rem;
            box-shadow: var(--shadow-dark);
        }

        .slider {
            display: flex;
            height: 100%;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .slide {
            min-width: 100%;
            height: 100%;
            position: relative;
            cursor: pointer;
        }

        .slide-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 10s ease;
        }

        .slide:hover .slide-image {
            transform: scale(1.05);
        }

        .slide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.5) 50%, transparent 100%);
        }

        .dark-mode .slide-overlay {
            background: linear-gradient(to right, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.5) 50%, transparent 100%);
        }

        .slide-content {
            position: absolute;
            top: 50%;
            left: 5%;
            transform: translateY(-50%);
            max-width: 500px;
            color: var(--text-white);
            z-index: 2;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }

        .dark-mode .slide-content {
            color: var(--text-primary);
            text-shadow: 0 2px 4px rgba(255,255,255,0.2);
        }

        .slide-title {
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 1rem;
            line-height: 1.1;
        }

        .slide-description {
            font-size: 1.25rem;
            margin-bottom: 2rem;
            opacity: 0.95;
        }

        .slide-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            background: var(--text-white);
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 600;
            border-radius: var(--radius);
            transition: var(--transition);
            border: 2px solid transparent;
        }

        .slide-btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-dark);
            border-color: var(--text-white);
            background: transparent;
            color: var(--text-white);
        }

        .dark-mode .slide-btn {
            background: var(--text-primary);
            color: var(--background-color);
        }

        .dark-mode .slide-btn:hover {
            background: transparent;
            color: var(--text-primary);
            border-color: var(--text-primary);
        }

        .slider-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 3;
        }

        .slider-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255,255,255,0.5);
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
        }

        .slider-dot.active {
            background: var(--text-white);
            transform: scale(1.3);
            border-color: var(--text-white);
        }

        .dark-mode .slider-dot {
            background: rgba(0,0,0,0.5);
        }

        .dark-mode .slider-dot.active {
            background: var(--text-primary);
            border-color: var(--text-primary);
        }

        .slider-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: var(--blur-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            transition: var(--transition);
            z-index: 3;
            opacity: 0;
        }

        .slider-container:hover .slider-nav {
            opacity: 1;
        }

        .slider-nav.prev {
            left: 2rem;
        }

        .slider-nav.next {
            right: 2rem;
        }

        .slider-nav:hover {
            background: var(--primary-color);
            color: var(--text-white);
            border-color: var(--primary-color);
        }

        .section {
            margin-bottom: 4rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--primary-color);
        }

        .dark-mode .section-header {
            border-bottom-color: var(--text-primary);
        }

        .section-title {
            font-size: 1.75rem;
            font-weight: 800;
            position: relative;
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: -1rem;
            left: 0;
            width: 50px;
            height: 3px;
            background: var(--primary-color);
        }

        .dark-mode .section-title::after {
            background: var(--text-primary);
        }

        .view-all {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9375rem;
            font-weight: 600;
            transition: var(--transition);
        }

        .view-all:hover {
            color: var(--text-primary);
            transform: translateX(4px);
        }

        /* ===== CATEGORY GRID ===== */
        .categories-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .category-card {
            position: relative;
            height: 200px;
            border-radius: var(--radius);
            overflow: hidden;
            cursor: pointer;
        }

        .category-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s ease;
        }

        .category-card:hover .category-image {
            transform: scale(1.1);
        }

        .category-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.3) 50%, transparent 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 1.5rem;
            color: var(--text-white);
        }

        .category-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .category-count {
            font-size: 0.875rem;
            opacity: 0.9;
        }

        /* ===== PRODUCT GRID ===== */
        .products-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .product-card {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            overflow: hidden;
            transition: var(--transition);
            position: relative;
            animation: fadeIn 0.5s ease;
        }

        .product-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-dark);
            border-color: var(--primary-color);
        }

        .product-image-container {
            position: relative;
            width: 100%;
            height: 200px;
            overflow: hidden;
            background: var(--background-color);
        }

        .product-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 1rem;
            transition: transform 0.5s ease;
        }

        .product-card:hover .product-image {
            transform: scale(1.05);
        }

        .product-badges {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 2;
        }

        .product-badge {
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-new {
            background: var(--success-color);
            color: var(--text-white);
        }

        .badge-sale {
            background: var(--error-color);
            color: var(--text-white);
        }

        .badge-hot {
            background: var(--warning-color);
            color: var(--text-white);
        }

        .product-actions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: var(--transition);
        }

        .product-card:hover .product-actions {
            opacity: 1;
        }

        .product-action-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--blur-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: var(--transition);
        }

        .product-action-btn:hover {
            background: var(--primary-color);
            color: var(--text-white);
            border-color: var(--primary-color);
            transform: scale(1.1);
        }

        .product-action-btn.active {
            background: var(--error-color);
            color: var(--text-white);
            border-color: var(--error-color);
        }

        .product-info {
            padding: 1.25rem;
        }

        .product-category {
            display: inline-block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
        }

        .product-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
            height: 40px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            transition: var(--transition-fast);
        }

        .product-card:hover .product-title {
            color: var(--primary-color);
        }

        .product-price {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .current-price {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .dark-mode .current-price {
            color: var(--text-primary);
        }

        .original-price {
            font-size: 0.9375rem;
            color: var(--text-secondary);
            text-decoration: line-through;
        }

        .discount {
            background: var(--error-color);
            color: var(--text-white);
            padding: 0.125rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 700;
        }

        .product-rating {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .rating-stars {
            display: flex;
            gap: 0.125rem;
        }

        .rating-star {
            color: var(--warning-color);
            font-size: 0.875rem;
        }

        .rating-count {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .product-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .product-stock {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .stock-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-color);
        }

        .stock-dot.low {
            background: var(--warning-color);
        }

        .stock-dot.out {
            background: var(--error-color);
        }

        /* ===== STORE PAGE ===== */
        .store-header {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem;
            padding: 2rem;
            background: var(--surface-color);
            border-radius: var(--radius);
        }

        .store-title {
            font-size: 2rem;
            font-weight: 800;
        }

        .store-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .store-select {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
            min-width: 200px;
            cursor: pointer;
            transition: var(--transition);
        }

        .store-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.1);
        }

        .dark-mode .store-select:focus {
            box-shadow: 0 0 0 3px rgba(255,255,255,0.1);
        }

        /* ===== PRODUCT DETAILS PAGE ===== */
        .product-details-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        @media (min-width: 1024px) {
            .product-details-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 3rem;
                align-items: start;
            }
        }

        /* Add related products section styling */
        .related-products-section {
            grid-column: 1 / -1;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
            width: 100%;
            clear: both;
        }

        /* Update related products grid */
        .related-products-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .related-products-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .related-products-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        /* Make product cards more square */
        .related-products-section .product-image-container {
            height: 180px;
        }

        @media (min-width: 768px) {
            .related-products-section .product-image-container {
                height: 200px;
            }
        }

        @media (min-width: 1024px) {
            .related-products-section .product-image-container {
                height: 220px;
            }
        }

        .product-gallery {
            display: flex;
            flex-direction: column;
            margin-bottom: 2rem;
        }

        .main-image-container {
            width: 100%;
            height: 400px;
            background: var(--surface-color);
            border-radius: var(--radius);
            overflow: hidden;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: zoom-in;
            position: relative;
        }

        .main-product-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-height: 400px;
            transition: transform 0.3s ease;
        }

        .thumbnail-container {
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            padding: 0.5rem 0;
            scrollbar-width: thin;
        }
        .main-image-container {
            flex: 1;
            background: var(--surface-color);
            border-radius: var(--radius);
            overflow: hidden;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: zoom-in;
            position: relative;
        }

        .main-product-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-height: 500px;
            transition: transform 0.3s ease;
        }

        .zoom-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: var(--transition);
            color: var(--text-white);
        }

        .main-image-container:hover .zoom-overlay {
            opacity: 1;
        }

        .thumbnail-container {
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            padding: 0.5rem 0;
            scrollbar-width: thin;
        }

        .thumbnail {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 2px solid transparent;
            transition: var(--transition);
            flex-shrink: 0;
        }

        .thumbnail.active {
            border-color: var(--primary-color);
        }

        .dark-mode .thumbnail.active {
            border-color: var(--text-primary);
        }

        .product-info-details {
            padding: 0 1rem;
        }

        .product-category-detail {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .product-title-large {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 1rem;
            line-height: 1.2;
        }

        .product-rating-large {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .product-price-large {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .current-price-large {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--primary-color);
        }

        .original-price-large {
            font-size: 1.75rem;
            color: var(--text-secondary);
            text-decoration: line-through;
        }

        .discount-large {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--error-color);
        }

        .product-actions-large {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .action-btn-large {
            flex: 1;
            min-width: 160px;
            padding: 1rem 2rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
        }

        .buy-now-btn {
            background: var(--gradient-primary);
            color: var(--text-white);
        }

        .buy-now-btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-dark);
        }

        .add-cart-btn {
            background: var(--surface-color);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .add-cart-btn:hover {
            background: var(--border-color);
            transform: translateY(-3px);
        }

        .wishlist-btn-large {
            min-width: 60px;
            background: var(--surface-color);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .wishlist-btn-large:hover {
            transform: translateY(-3px);
        }

        .wishlist-btn-large.active {
            background: var(--error-color);
            color: var(--text-white);
            border-color: var(--error-color);
        }

        .product-description {
            margin-bottom: 2rem;
        }

        .description-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .description-content {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .specs-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .spec-item {
            padding: 1rem;
            background: var(--surface-color);
            border-radius: var(--radius-sm);
            transition: var(--transition);
        }

        .spec-item:hover {
            transform: translateY(-2px);
        }

        .spec-key {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .spec-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* ===== REVIEWS SECTION ===== */
        .reviews-section {
            margin-top: 4rem;
        }

        .reviews-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .review-form {
            background: var(--surface-color);
            padding: 2rem;
            border-radius: var(--radius);
            margin-bottom: 2rem;
        }

        .review-form-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
        }

        .rating-input {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .rating-star-input {
            font-size: 2rem;
            color: var(--border-color);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .rating-star-input.active {
            color: var(--warning-color);
        }

        .review-images-input {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            padding: 0.5rem 0;
        }

        .review-image-preview {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            border: 2px solid var(--border-color);
        }

        .reviews-list {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .review-card {
            background: var(--surface-color);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }

        .review-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .review-user {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .review-user-img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .review-user-info h4 {
            margin-bottom: 0.25rem;
            font-size: 1rem;
        }

        .review-date {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .review-rating {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .review-content {
            color: var(--text-primary);
            line-height: 1.7;
            margin-bottom: 1rem;
        }

        .review-images {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .review-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: var(--transition);
        }

        .review-image:hover {
            transform: scale(1.1);
        }

        /* ===== MODALS ===== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            padding: 1rem;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--background-color);
            border-radius: var(--radius-lg);
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-dark);
            position: relative;
            animation: modalSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--background-color);
            z-index: 1;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 800;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--surface-color);
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-footer {
            padding: 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* ===== ADMIN PANEL ===== */
        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: var(--surface-color);
            border-radius: var(--radius);
        }

        .admin-title {
            font-size: 2rem;
            font-weight: 800;
        }

        .admin-search {
            width: 300px;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
        }

        .admin-search:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .admin-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .admin-stat-card {
            background: var(--surface-color);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .admin-stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-medium);
        }

        .admin-stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .admin-stat-title {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .admin-stat-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius);
            background: var(--primary-color);
            color: var(--text-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .dark-mode .admin-stat-icon {
            background: var(--text-primary);
            color: var(--background-color);
        }

        .admin-stat-value {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .dark-mode .admin-stat-value {
            color: var(--text-primary);
        }

        .admin-stat-change {
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .admin-stat-change.positive {
            color: var(--success-color);
        }

        .admin-stat-change.negative {
            color: var(--error-color);
        }

        .admin-charts {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .admin-chart-container {
            background: var(--surface-color);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }

        .admin-chart-title {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .admin-chart {
            height: 300px;
            position: relative;
        }

        .admin-table-container {
            background: var(--surface-color);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }

        .admin-table-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
        }

        .admin-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        .admin-table th {
            text-align: left;
            padding: 1rem;
            border-bottom: 2px solid var(--border-color);
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            background: var(--surface-color);
            position: sticky;
            top: 0;
        }

        .admin-table td {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
        }

        .admin-table tr:hover {
            background: var(--background-color);
        }

        .admin-table tr:last-child td {
            border-bottom: none;
        }

        .admin-badge {
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-success {
            background: rgba(52, 199, 89, 0.1);
            color: var(--success-color);
        }

        .badge-warning {
            background: rgba(255, 149, 0, 0.048);
            color: var(--warning-color);
        }

        .badge-error {
            background: rgba(255, 59, 48, 0.1);
            color: var(--error-color);
        }

        .badge-info {
            background: rgba(0, 122, 255, 0.1);
            color: var(--info-color);
        }

        .admin-actions {
            display: flex;
            gap: 0.5rem;
        }

        .admin-action-btn {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            background: var(--background-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .admin-action-btn:hover {
            background: var(--primary-color);
            color: var(--text-white);
            border-color: var(--primary-color);
        }

        .admin-action-btn.delete:hover {
            background: var(--error-color);
            border-color: var(--error-color);
        }

        /* ===== ADMIN PRODUCT MODAL ===== */
        .admin-form-group {
            margin-bottom: 1.5rem;
        }

        .admin-form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .admin-form-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
            transition: var(--transition);
        }

        .admin-form-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.1);
        }

        .dark-mode .admin-form-input:focus {
            box-shadow: 0 0 0 3px rgba(255,255,255,0.1);
        }

        .admin-form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        .admin-form-select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'%3E%3C/path%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 16px;
        }

        .admin-form-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .admin-form-images {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .admin-form-image {
            position: relative;
            width: 100%;
            height: 100px;
            border-radius: var(--radius-sm);
            overflow: hidden;
            border: 2px solid var(--border-color);
        }

        .admin-form-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .admin-form-image-remove {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--error-color);
            color: var(--text-white);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .admin-form-file {
            width: 100%;
            padding: 0.75rem;
            border: 2px dashed var(--border-color);
            border-radius: var(--radius);
            background: var(--surface-color);
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .admin-form-file:hover {
            border-color: var(--primary-color);
            background: var(--background-color);
        }

        /* ===== CHAT MODAL ===== */
        .chat-modal {
            max-width: 400px;
        }

        .chat-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--gradient-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-white);
            font-weight: 600;
        }

        .chat-info h3 {
            margin-bottom: 0.25rem;
            font-size: 1rem;
        }

        .chat-status {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-color);
        }

        .chat-body {
            height: 400px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: var(--radius-lg);
            position: relative;
            animation: slideUp 0.3s ease;
        }

        .message-incoming {
            background: var(--surface-color);
            align-self: flex-start;
            border-bottom-left-radius: var(--radius-sm);
        }

        .message-outgoing {
            background: var(--primary-color);
            color: var(--text-white);
            align-self: flex-end;
            border-bottom-right-radius: var(--radius-sm);
        }

        .dark-mode .message-outgoing {
            background: var(--text-primary);
            color: var(--background-color);
        }

        .message-content {
            margin-bottom: 0.25rem;
        }

        .message-time {
            font-size: 0.6875rem;
            opacity: 0.7;
            text-align: right;
        }

        .chat-input-container {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
            resize: none;
            min-height: 44px;
            max-height: 120px;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .chat-send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--primary-color);
            color: var(--text-white);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            transition: var(--transition);
        }

        .chat-send-btn:hover {
            background: var(--secondary-color);
            transform: scale(1.1);
        }

        .dark-mode .chat-send-btn {
            background: var(--text-primary);
            color: var(--background-color);
        }

        /* ===== FOOTER ===== */
        .footer {
            background: var(--surface-color);
            padding: 4rem 0 2rem;
            margin-top: 4rem;
            border-top: 1px solid var(--border-color);
        }

        .footer-content {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3rem;
            margin-bottom: 3rem;
        }

        .footer-section {
            animation: fadeIn 0.5s ease;
        }

        .footer-section h3 {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            position: relative;
            display: inline-block;
        }

        .footer-section h3::after {
            content: '';
            position: absolute;
            bottom: -0.5rem;
            left: 0;
            width: 40px;
            height: 2px;
            background: var(--primary-color);
        }

        .dark-mode .footer-section h3::after {
            background: var(--text-primary);
        }

        .footer-links {
            list-style: none;
        }

        .footer-links li {
            margin-bottom: 0.75rem;
        }

        .footer-links a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9375rem;
            transition: var(--transition-fast);
            display: inline-block;
        }

        .footer-links a:hover {
            color: var(--text-primary);
            transform: translateX(4px);
        }

        .footer-apps {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .app-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            color: var(--text-primary);
            text-decoration: none;
            transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .app-link:hover {
            background: var(--primary-color);
            color: var(--text-white);
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .footer-social {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .social-link {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--background-color);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid var(--border-color);
        }

        .social-link:hover {
            background: var(--primary-color);
            color: var(--text-white);
            border-color: var(--primary-color);
            transform: translateY(-3px);
        }

        .footer-bottom {
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .footer-payment {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .payment-method {
            width: 48px;
            height: 32px;
            border-radius: var(--radius-sm);
            background: var(--background-color);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            color: var(--text-primary);
        }

        .copyright {
            text-align: center;
        }

        /* ===== FLOATING BUTTONS ===== */
        .floating-buttons {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 1000;
        }

        .floating-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--gradient-primary);
            color: var(--text-white);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: var(--shadow-dark);
            transition: var(--transition);
            position: relative;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .floating-btn:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .dark-mode .floating-btn {
            color: var(--background-color);
        }

        .floating-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--error-color);
            color: var(--text-white);
            font-size: 0.75rem;
            font-weight: 700;
            min-width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            border: 2px solid var(--background-color);
            animation: pulse 2s infinite;
        }

        /* ===== TOAST NOTIFICATIONS ===== */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 4000;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 400px;
        }

        .toast {
            padding: 1rem 1.25rem;
            background: var(--blur-bg);
            backdrop-filter: blur(20px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-dark);
            animation: slideLeft 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            border-left: 4px solid var(--primary-color);
            border: 1px solid var(--border-color);
        }

        .toast.success {
            border-left-color: var(--success-color);
        }

        .toast.error {
            border-left-color: var(--error-color);
        }

        .toast.warning {
            border-left-color: var(--warning-color);
        }

        .toast.info {
            border-left-color: var(--info-color);
        }

        .toast-icon {
            font-size: 1.25rem;
        }

        .toast.success .toast-icon {
            color: var(--success-color);
        }

        .toast.error .toast-icon {
            color: var(--error-color);
        }

        .toast.warning .toast-icon {
            color: var(--warning-color);
        }

        .toast.info .toast-icon {
            color: var(--info-color);
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-size: 0.9375rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .toast-message {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.125rem;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .toast-close:hover {
            background: var(--surface-color);
            color: var(--text-primary);
        }

        /* ===== LOADING SKELETONS ===== */
        .skeleton {
            background: linear-gradient(90deg, var(--surface-color) 25%, var(--border-color) 50%, var(--surface-color) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: var(--radius);
        }
        /* ===== CART & WISHLIST ITEMS ===== */
        .cart-item {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .cart-item:hover {
            background: var(--surface-color);
        }

        .cart-item-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            flex-shrink: 0;
        }

        .cart-item-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .cart-item-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .cart-item-price {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .dark-mode .cart-item-price {
            color: var(--text-primary);
        }

        .cart-item-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .quantity-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 0.25rem;
        }

        .quantity-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--surface-color);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: var(--transition);
        }

        .quantity-btn:hover {
            background: var(--primary-color);
            color: var(--text-white);
        }

        .quantity-value {
            min-width: 30px;
            text-align: center;
            font-weight: 600;
        }

        .remove-item-btn {
            background: none;
            border: none;
            color: var(--error-color);
            cursor: pointer;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: var(--transition);
        }

        .remove-item-btn:hover {
            color: var(--error-color);
            text-decoration: underline;
        }

        .cart-summary {
            padding: 1.5rem;
            background: var(--surface-color);
            border-radius: var(--radius);
            margin-top: 1.5rem;
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9375rem;
        }

        .summary-row:last-child {
            border-bottom: none;
        }

        .summary-total {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .dark-mode .summary-total {
            color: var(--text-primary);
        }

        .checkout-btn {
            width: 100%;
            padding: 1rem;
            background: var(--gradient-primary);
            color: var(--text-white);
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 1rem;
            transition: var(--transition);
        }

        .checkout-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        /* ===== FORM STYLES ===== */
        .profile-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .profile-tab {
            padding: 0.75rem 1.5rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.9375rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: var(--radius) var(--radius) 0 0;
            transition: var(--transition);
            position: relative;
        }

        .profile-tab.active {
            color: var(--primary-color);
            background: var(--surface-color);
        }

        .profile-tab.active::after {
            content: '';
            position: absolute;
            bottom: -0.5rem;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--primary-color);
        }

        .dark-mode .profile-tab.active::after {
            background: var(--text-primary);
        }

        .profile-content {
            display: none;
        }

        .profile-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .form-btn {
            flex: 1;
            padding: 1rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: var(--text-white);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .btn-secondary {
            background: var(--surface-color);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--border-color);
            transform: translateY(-2px);
        }

        .profile-info {
            text-align: center;
        }

        .profile-image-container {
            margin-bottom: 1.5rem;
        }

        .profile-image {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid var(--primary-color);
            margin-bottom: 1rem;
        }

        .dark-mode .profile-image {
            border-color: var(--text-primary);
        }

        .profile-name {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .profile-email,
        .profile-phone,
        .profile-address {
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .profile-stats {
            display: flex;
            justify-content: space-around;
            margin: 2rem 0;
            padding: 1.5rem;
            background: var(--surface-color);
            border-radius: var(--radius);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.25rem;
        }

        .dark-mode .stat-value {
            color: var(--text-primary);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* ===== PAYMENT METHODS ===== */
        .newPaymentMethod {
        width: 100%;
        padding: 10px 12px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #fff;
        color: #333;
        outline: none;
        cursor: pointer;
    }

    /* Focus effect */
    .newPaymentMethod:focus {
        border-color: #4CAF50;
        box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    /* Disabled option look (optional) */
    .newPaymentMethod option {
        color: #333;
    }

        .payment-methods {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .payment-method {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
        }

        .payment-method:hover {
            border-color: var(--primary-color);
            background: var(--surface-color);
        }

        .payment-method.active {
            border-color: var(--primary-color);
            background: var(--surface-color);
        }

        .dark-mode .payment-method.active {
            border-color: var(--text-primary);
        }

        .payment-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-sm);
            background: var(--primary-color);
            color: var(--text-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            flex-shrink: 0;
            margin: 5px;
        }

        .dark-mode .payment-icon {
            background: var(--text-primary);
            color: var(--background-color);
        }

        .payment-info {
            flex: 1;
        }

        .payment-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .payment-desc {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* ===== CONTACT OPTIONS ===== */
        .contact-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .contact-option {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            text-decoration: none;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .contact-option:hover {
            border-color: var(--primary-color);
            background: var(--surface-color);
            transform: translateY(-2px);
        }

        .contact-icon {
            width: 50px;
            height: 50px;
            border-radius: var(--radius);
            background: var(--primary-color);
            color: var(--text-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .dark-mode .contact-icon {
            background: var(--text-primary);
            color: var(--background-color);
        }

        .contact-details {
            flex: 1;
        }

        .contact-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .contact-info {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* ===== LOADING STATES ===== */
        .loading {
            opacity: 0.7;
            pointer-events: none;
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        /* ===== REVIEW FORM MODAL ===== */
        .review-form-modal .modal {
            max-width: 600px;
        }

        .review-form-content {
            padding: 1.5rem;
        }

        .review-rating-input {
            margin-bottom: 1.5rem;
        }

        .rating-stars-input {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .rating-star-input {
            font-size: 2rem;
            color: var(--border-color);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .rating-star-input.active {
            color: var(--warning-color);
        }

        .rating-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .rating-value {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--warning-color);
        }

        .review-title-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
            margin-bottom: 1rem;
        }

        .review-title-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .review-text-input {
            width: 100%;
            min-height: 150px;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 0.9375rem;
            resize: vertical;
            margin-bottom: 1rem;
        }

        .review-text-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .review-images-upload {
            margin-bottom: 1.5rem;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: var(--primary-color);
            background: var(--surface-color);
        }

        .upload-area i {
            font-size: 2.5rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .upload-area p {
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .upload-area span {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .uploaded-images-preview {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .uploaded-image {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .uploaded-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .remove-image-btn {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--error-color);
            color: var(--text-white);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .image-input {
            display: none;
        }

        .form-actions-review {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        /* Add these styles to your existing CSS */

        #zoomedImage {
            transition: transform 0.3s ease;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            cursor: zoom-in;
        }

        #zoomedImage.zoomed {
            transform: scale(2);
            cursor: zoom-out;
        }

        /* Improve modal for zoom */
        #zoomModal .modal {
            max-width: 90vw;
            max-height: 90vh;
            background: transparent;
            box-shadow: none;
        }

        #zoomModal .modal-header {
            background: var(--blur-bg);
            backdrop-filter: blur(20px);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1;
            border-bottom: 1px solid var(--border-color);
        }

        #zoomModal .modal-body {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            background: transparent;
        }
        .translate-btn {
            display: inline-block;
            margin-top: 15px;
            padding: 8px 16px;
            border-radius: 6px;
            background: #2563eb;
            color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }

        .translate-btn:hover {
            background: #1e40af;
        }
        /* Touch-friendly zoom controls for mobile */
        @media (max-width: 768px) {
            #zoomedImage {
                touch-action: manipulation;
            }
            
            #zoomModal .modal {
                max-width: 95vw;
                max-height: 95vh;
            }
        }

        /* ===== REVIEW DISPLAY ===== */
        .review-helpful {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .review-helpful button {
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            color: var(--text-secondary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: var(--transition);
        }

        .review-helpful button:hover {
            background: var(--border-color);
        }

        /* ===== RELATED PRODUCTS ===== */
        .related-products-section {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .related-products-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
        }

        .related-products-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .related-products-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .related-products-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        /* ===== REVIEW SORTING ===== */
        .reviews-sorting {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .sort-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            color: var(--text-primary);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 0.875rem;
            transition: var(--transition);
        }

        .sort-btn.active {
            background: var(--primary-color);
            color: var(--text-white);
            border-color: var(--primary-color);
        }

        .sort-btn:hover:not(.active) {
            background: var(--border-color);
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-text {
            height: 1rem;
            margin-bottom: 0.5rem;
            border-radius: var(--radius-sm);
        }

        .skeleton-text:last-child {
            margin-bottom: 0;
            width: 80%;
        }

        .skeleton-image {
            width: 100%;
            height: 200px;
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }
        /* ===== SUGGESTIONS MODAL ===== */
        #suggestionsModal .modal {
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #suggestionsModal .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        #suggestionsProducts {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            max-height: none;
        }

        #suggestionsProducts .product-card {
            height: auto;
            min-height: 250px;
            display: flex;
            flex-direction: column;
        }

        #suggestionsProducts .product-image-container {
            height: 140px;
            flex-shrink: 0;
        }

        #suggestionsProducts .product-image {
            padding: 0.5rem;
            object-fit: contain;
        }

        #suggestionsProducts .product-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
        }

        #suggestionsProducts .product-title {
            font-size: 0.875rem;
            height: 36px;
            margin-bottom: 0.5rem;
            -webkit-line-clamp: 2;
        }

        #suggestionsProducts .product-price {
            margin-bottom: 0.5rem;
        }

        #suggestionsProducts .current-price {
            font-size: 1rem;
        }

        #suggestionsProducts .product-rating {
            margin-bottom: 0.5rem;
        }

        #suggestionsProducts .rating-stars {
            font-size: 0.75rem;
        }

        #suggestionsProducts .rating-count {
            font-size: 0.75rem;
        }

        #suggestionsProducts .product-actions {
            opacity: 1;
            position: static;
            transform: none;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: auto;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
            background: transparent;
        }

        #suggestionsProducts .product-action-btn {
            width: 32px;
            height: 32px;
            font-size: 0.875rem;
        }

        #suggestionsProducts .product-badges {
            top: 0.5rem;
            left: 0.5rem;
        }

        #suggestionsProducts .product-badge {
            padding: 0.125rem 0.375rem;
            font-size: 0.625rem;
        }
        /* Shorter profile modal buttons */
        #profileModal .form-actions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        #profileModal .form-actions .form-btn {
            width: 100%;
            max-width: 200px; /* Reduced from full width */
            margin: 0 auto; /* Center the buttons */
            padding: 0.65rem 1rem; /* Smaller padding */
            font-size: 0.9rem; /* Smaller font */
            min-height: 44px; /* Standard touch target */
        }

        #profileModal #editProfileBtn,
        #profileModal #adminAccessBtn {
            max-width: 180px; /* Even shorter for specific buttons */
        }


        .message-box {
            max-width: 600px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 20px;
            background: #ffffff;
            font-family: Arial, sans-serif;
        }

        .message-content {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }

        .message-content.active {
            display: block;
        }

        .message-content h3 {
            margin-bottom: 12px;
            color: #111827;
        }

        .message-content p {
            margin: 8px 0;
            line-height: 1.6;
            color: #374151;
        }

        .message-content hr {
            margin: 16px 0;
            border: none;
            border-top: 1px dashed #d1d5db;
        }

        .message-content .thanks {
            margin-top: 12px;
            font-weight: 500;
        }

        .message-content button {
            margin-top: 15px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #2563eb;
            color: #ffffff;
            cursor: pointer;
            font-size: 14px;
        }

        .message-content button:hover {
            background: #1e40af;
        }

/* ===== ENHANCED CHAT MODAL STYLES ===== */
.chat-input-wrapper {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: var(--radius);
}

.chat-input {
    flex: 1;
    border: none;
    background: transparent;
    color: var(--text-primary);
    font-size: 0.9375rem;
    padding: 0.25rem 0.5rem;
    min-height: 36px;
    max-height: 100px;
    resize: none;
}

.chat-input:focus {
    outline: none;
}

.chat-input-actions {
    display: flex;
    gap: 0.25rem;
    border-left: 1px solid var(--border-color);
    padding-left: 0.5rem;
}

.chat-emoji-btn,
.chat-attach-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.125rem;
    transition: var(--transition-fast);
}

.chat-emoji-btn:hover,
.chat-attach-btn:hover {
    background: var(--surface-color);
    color: var(--text-primary);
}

/* Chat typing indicator */
.typing-indicator {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.5rem 1rem;
    background: var(--surface-color);
    border-radius: var(--radius-lg);
    width: fit-content;
    margin: 0.5rem 0;
}

.typing-dots {
    display: flex;
    gap: 0.25rem;
}

.typing-dots span {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-secondary);
    animation: typing 1.4s infinite both;
}

.typing-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dots span:nth-child(3) {
    animation-delay: 0.4s;
}
/* ===== ENHANCED CHAT STYLES ===== */
.chat-message .message-footer {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 0.25rem;
    font-size: 0.75rem;
}

.message-incoming .message-footer {
    justify-content: flex-start;
}

.message-status {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.75rem;
}

.message-status.sent {
    color: var(--text-secondary);
}

.message-status.delivered {
    color: var(--info-color);
}

.message-status.read {
    color: var(--success-color);
}

.chat-timestamp {
    text-align: center;
    margin: 1rem 0;
    position: relative;
}

.chat-timestamp span {
    background: var(--surface-color);
    padding: 0.25rem 0.75rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.typing-indicator {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.5rem 1rem;
    background: var(--surface-color);
    border-radius: var(--radius-lg);
    width: fit-content;
    margin: 0.5rem 0;
}

.typing-dots {
    display: flex;
    gap: 0.25rem;
}

.typing-dots span {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-secondary);
    animation: typing 1.4s infinite both;
}

.typing-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typing {
    0%, 80%, 100% {
        opacity: 0.3;
        transform: translateY(0);
    }
    40% {
        opacity: 1;
        transform: translateY(-4px);
    }
}




@keyframes typing {
    0%, 80%, 100% {
        opacity: 0.3;
        transform: translateY(0);
    }
    40% {
        opacity: 1;
        transform: translateY(-4px);
    }
}

/* Chat message status */
.message-status {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.message-status.sent {
    color: var(--success-color);
}

.message-status.delivered {
    color: var(--info-color);
}

.message-status.read {
    color: var(--primary-color);
}

/* Chat timestamp */
.chat-timestamp {
    text-align: center;
    margin: 1rem 0;
    position: relative;
}

.chat-timestamp span {
    background: var(--surface-color);
    padding: 0.25rem 0.75rem;
    border-radius: var(--radius);
    font-size: 0.75rem;
    color: var(--text-secondary);
}

/* Chat quick replies */
.chat-quick-replies {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin: 0.5rem 0;
}

.quick-reply-btn {
    padding: 0.5rem 0.75rem;
    background: var(--surface-color);
    border: 1px solid var(--border-color);
    border-radius: var(--radius);
    color: var(--text-primary);
    font-size: 0.875rem;
    cursor: pointer;
    transition: var(--transition-fast);
}

.quick-reply-btn:hover {
    background: var(--primary-color);
    color: var(--text-white);
    border-color: var(--primary-color);
}



.payment-instructions-table {
    margin: 1.5rem 0;
    padding: 1.25rem;
    background: var(--surface-color);
    border-radius: var(--radius);
    border: 1px solid var(--border-color);
}

.payment-table-container {
    overflow-x: auto;
    margin: 0.75rem 0;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-color);
}

.payment-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 500px;
}

.payment-table th {
    padding: 0.75rem 1rem;
    background: var(--background-color);
    text-align: left;
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-primary);
    border-bottom: 2px solid var(--border-color);
}

.payment-table td {
    padding: 0.75rem 1rem;
    font-size: 0.9rem;
    border-bottom: 1px solid var(--border-color);
    vertical-align: middle;
}

.payment-table tr:last-child td {
    border-bottom: none;
}

.payment-table tr:hover {
    background: rgba(0, 0, 0, 0.02);
}

.dark-mode .payment-table tr:hover {
    background: rgba(255, 255, 255, 0.03);
}

.payment-table td:first-child {
    font-weight: 500;
    color: var(--text-primary);
    display: flex;
    align-items: center;
}

.payment-table td:nth-child(2) {
    font-family: monospace;
    letter-spacing: 0.5px;
    color: var(--primary-color);
}

.dark-mode .payment-table td:nth-child(2) {
    color: var(--text-primary);
}

.payment-table td:nth-child(3) {
    font-weight: 600;
    color: var(--success-color);
    text-align: right;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .payment-table {
        min-width: 450px;
    }
    
    .payment-table th,
    .payment-table td {
        padding: 0.6rem 0.75rem;
        font-size: 0.85rem;
    }
    
    .payment-instructions-table {
        padding: 1rem;
    }
}

@media (max-width: 480px) {
    .payment-table {
        min-width: 400px;
    }
    
    .payment-table th,
    .payment-table td {
        padding: 0.5rem;
        font-size: 0.8rem;
    }
}
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }


        /* For mobile, make buttons slightly wider */
        @media (max-width: 768px) {
            #profileModal .form-actions .form-btn {
                max-width: 90%;
                padding: 0.75rem 1.25rem;
            }
        }

        /* Ensure buttons look good in dark mode */
        .dark-mode #profileModal .form-btn {
            border: 1px solid var(--border-color);
        }

        /* Specific styling for admin button */
        #profileModal #adminAccessBtn {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            border: none;
        }

        .dark-mode #profileModal #adminAccessBtn {
            background: linear-gradient(135deg, #8a2be2 0%, #4169e1 100%);
        }
        /* Responsive adjustments for suggestions modal */
        @media (max-width: 768px) {
            #suggestionsModal .modal {
                max-width: 95vw;
                max-height: 80vh;
                margin: 1rem;
            }
            
            #suggestionsProducts {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 0.75rem;
            }
            
            #suggestionsProducts .product-image-container {
                height: 120px;
            }
        }

        @media (max-width: 480px) {
            #suggestionsProducts {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
                gap: 0.5rem;
            }
            
            #suggestionsProducts .product-image-container {
                height: 100px;
            }
            
            #suggestionsProducts .product-title {
                font-size: 0.8125rem;
                height: 32px;
            }
            
            #suggestionsProducts .product-info {
                padding: 0.5rem;
            }
        }
        /* ===== RESPONSIVE DESIGN ===== */
        @media (min-width: 640px) {
            .logo-text {
                display: block;
            }

            .categories-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .products-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 1.5rem;
            }

            .product-image-container {
                height: 240px;
            }

            .footer-content {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 768px) {
            .header-actions {
                gap: 1.5rem;
            }

            .search-container {
                margin: 0 3rem;
            }

            .slider-container {
                height: 500px;
            }

            .slide-content {
                left: 5%;
                max-width: 500px;
            }

            .slide-title {
                font-size: 3.5rem;
            }

            .slide-description {
                font-size: 1.5rem;
            }

            .categories-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .products-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .admin-stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .footer-content {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .product-details-container {
                grid-template-columns: 1fr 1fr;
            }

            .products-grid {
                grid-template-columns: repeat(5, 1fr);
            }

            .slider-container {
                height: 600px;
            }

            .slide-content {
                left: 10%;
            }

            .slide-title {
                font-size: 4rem;
            }

            .admin-charts {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1280px) {
            .container {
                padding: 0 40px;
            }

            .products-grid {
                grid-template-columns: repeat(6, 1fr);
            }

            .slider-container {
                height: 700px;
            }
        }

        @media (max-width: 767px) {
            .header-actions .header-action:not(.menu-toggle) {
                display: none;
            }

            .menu-toggle {
                display: flex;
            }

            .search-container {
                margin: 0 1rem;
            }

            .category-select {
                width: 80px;
                min-width: 80px;
                padding: 0 0.75rem;
                font-size: 0.8125rem;
            }

            .product-details-container {
                grid-template-columns: 1fr;
            }

            .product-gallery {
                position: static;
                height: auto;
            }

            .main-image-container {
                height: 400px;
            }

            .action-btn-large {
                min-width: 100%;
            }

            .slider-container {
                height: 300px;
            }

            .slide-content {
                left: 1.5rem;
                max-width: 300px;
            }

            .slide-title {
                font-size: 1.75rem;
            }

            .slide-description {
                font-size: 1rem;
            }

            .slide-btn {
                padding: 0.75rem 1.5rem;
                font-size: 0.9375rem;
            }

            .slider-nav {
                display: none;
            }

            .admin-stats-grid {
                grid-template-columns: 1fr;
            }

            .admin-charts {
                grid-template-columns: 1fr;
            }

            .modal {
                max-height: 80vh;
            }

            .floating-buttons {
                bottom: 1.5rem;
                right: 1.5rem;
            }

            .floating-btn {
                width: 50px;
                height: 50px;
                font-size: 1.25rem;
            }
        }

        @media (max-width: 480px) {
            .header-container {
                padding: 0.75rem 0;
                height: 60px;
            }

            .logo-icon {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            .categories-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }

            .category-card {
                height: 150px;
            }

            .category-title {
                font-size: 1.25rem;
            }

            .products-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }

            .product-image-container {
                height: 180px;
            }

            .product-info {
                padding: 1rem;
            }

            .product-title {
                font-size: 0.9375rem;
                height: 36px;
            }

            .current-price {
                font-size: 1.125rem;
            }

            .original-price {
                font-size: 0.875rem;
            }

            .slider-container {
                height: 250px;
            }

            .slide-content {
                left: 1rem;
                max-width: 250px;
            }

            .slide-title {
                font-size: 1.5rem;
            }

            .slide-description {
                font-size: 0.875rem;
            }

            .slide-btn {
                padding: 0.625rem 1.25rem;
                font-size: 0.875rem;
            }

            .main-image-container {
                height: 350px;
            }

            .product-title-large {
                font-size: 2rem;
            }

            .current-price-large {
                font-size: 2rem;
            }

            .original-price-large {
                font-size: 1.5rem;
            }

            .footer-content {
                grid-template-columns: 1fr;
                gap: 2rem;
            }

            .floating-buttons {
                bottom: 1rem;
                right: 1rem;
            }

            .floating-btn {
                width: 48px;
                height: 48px;
                font-size: 1.125rem;
            }
        }

        /* ===== TOUCH OPTIMIZATIONS ===== */
        @media (hover: none) {
            .product-actions {
                opacity: 1;
                background: var(--blur-bg);
                backdrop-filter: blur(10px);
                padding: 0.5rem;
                border-radius: var(--radius);
            }

            .product-card:hover {
                transform: none;
            }

            .action-btn-large:hover,
            .floating-btn:hover,
            .search-btn:hover,
            .header-action:hover,
            .mobile-menu-link:hover,
            .contact-option:hover,
            .payment-method:hover {
                transform: none;
            }
        }

        /* ===== PRINT STYLES ===== */
        @media print {
            .header,
            .footer,
            .floating-buttons,
            .mobile-menu {
                display: none !important;
            }

            body {
                background: white;
                color: black;
            }

            .container {
                max-width: 100%;
                padding: 0;
            }
        }
    
        /* ===== MOBILE/ANDROID UI FIXES ===== */
        /* Keep images filling their containers (no padding gaps) */
        .product-image {
            object-fit: cover !important;
            padding: 0 !important;
        }
        .main-product-image {
            object-fit: cover !important;
            max-height: none !important;
        }

        /* Remove "Trending" badge in product cards (keep other badges like sale) */
        .badge-hot, .product-badge.badge-hot {
            display: none !important;
        }

        /* Mobile: product action buttons stay hidden until card tapped */
        .product-card.active-actions .product-actions {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Mobile bottom nav like Daraz */
        .mobile-bottom-nav {
            display: none;
        }

        @media (max-width: 768px) {
            /* Make room for bottom nav */
            body { padding-bottom: 64px; }

            /* Remove hamburger/menu on Android; use bottom nav instead */
            #menuToggle { display: none !important; }
            #mobileMenu { display: none !important; }

            /* Avoid duplicate top-right icons on mobile (bottom nav handles these) */
            .header-actions { display: none !important; }

            /* Bottom nav visible on mobile only */
            .mobile-bottom-nav {
                display: flex;
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                height: 60px;
                padding: 0.25rem 0.5rem;
                background: var(--surface-color);
                border-top: 1px solid var(--border-color);
                z-index: 1500;
                justify-content: space-around;
                align-items: center;
            }
            .mobile-nav-btn {
                position: relative;
                width: 48px;
                height: 48px;
                border: none;
                background: transparent;
                color: var(--text-primary);
                border-radius: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: var(--transition-fast);
            }
            .mobile-nav-btn:active {
                transform: scale(0.96);
                background: var(--background-color);
            }
            .mobile-nav-btn .badge {
                position: absolute;
                top: 4px;
                right: 6px;
                background: var(--danger-color);
                color: #fff;
                min-width: 18px;
                height: 18px;
                padding: 0 6px;
                border-radius: 999px;
                font-size: 0.7rem;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Product action buttons: move to bottom of image and keep hidden until activated */
            .product-actions {
                top: auto !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0.5rem !important;
                transform: none !important;
                justify-content: center;
                opacity: 0;
                pointer-events: none;
            }
            .product-image-container {
                height: 180px; /* slightly taller to show image clearly */
                background: var(--surface-color);
            }

            /* Smaller category select; don't show selected text on mobile */
            .category-select {
                width: 44px !important;
                padding: 0 !important;
                text-indent: -9999px;
                background-position: center !important;
                background-size: 18px !important;
            }

            /* Make search button/icon shorter */
            .search-btn { width: 40px !important; }
            .search-btn i { font-size: 0.95rem; }

            /* Profile modal buttons smaller on mobile */
            #profileModal .form-actions .form-btn {
                padding: 0.55rem 0.75rem !important;
                font-size: 0.9rem !important;
            }
        }

        /* Disable "always visible" product actions on touch devices */
        @media (hover: none) {
            .product-actions {
                opacity: 0;
            }
            .product-card:hover .product-actions {
                opacity: 0;
            }
        }

        /* Zoom modal: allow pinch zoom without overflowing */
        #zoomModal .modal-body {
            overflow: hidden;
        }

    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-overlay" id="loader">
        <div class="loader"></div>
    </div>

    <!-- Header -->
    <header class="header" id="header">
        <div class="container">
            <div class="header-container">
                <a href="#" class="logo" id="homeLogo">
                    <div class="logo-icon">SP</div>
                    <span class="logo-text">ShoPure</span>
                </a>
                
                <div class="search-container">
                    <div class="search-wrapper">
                        <input type="text" class="search-input" id="searchInput" placeholder="Search products...">
                        <button class="search-btn" id="searchBtn">
                            <i class="fas fa-search"></i>
                        </button>
                    </div>
                    <div class="search-suggestions" id="searchSuggestions">
                        <!-- Suggestions will be loaded dynamically -->
                    </div>
                </div>
                
                <div class="header-actions">
                    <button class="header-action" id="themeToggle" title="Toggle Theme">
                        <i class="fas fa-moon"></i>
                    </button>
                    <button class="header-action" id="suggestionsBtn" title="Product Suggestions">
                        <i class="fas fa-lightbulb"></i>
                    </button>
                    <button class="header-action" id="profileBtn" title="Profile">
                        <i class="fas fa-user"></i>
                    </button>
                    <button class="header-action" id="wishlistBtn" title="Wishlist">
                        <i class="fas fa-heart"></i>
                        <span class="action-badge" id="wishlistBadge">0</span>
                    </button>
                    <button class="header-action" id="cartBtn" title="Cart">
                        <i class="fas fa-shopping-cart"></i>
                        <span class="action-badge" id="cartBadge">0</span>
                    </button>
                    <button class="menu-toggle" id="menuToggle">
                        <i class="fas fa-bars"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
            <div class="logo">
                <div class="logo-icon">SP</div>
                <span class="logo-text">ShoPure</span>
            </div>
            <button class="mobile-menu-close" id="mobileMenuClose">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-menu-section">
                <h3 class="mobile-menu-title">Navigation</h3>
                <ul class="mobile-menu-items">
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-page="home">
                            <i class="fas fa-home"></i>
                            <span>Home</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-page="store">
                            <i class="fas fa-store"></i>
                            <span>Store</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileProfileBtn">
                            <i class="fas fa-user"></i>
                            <span>Profile</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileWishlistBtn">
                            <i class="fas fa-heart"></i>
                            <span>Wishlist</span>
                            <span class="action-badge" id="mobileWishlistBadge">0</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileCartBtn">
                            <i class="fas fa-shopping-cart"></i>
                            <span>Cart</span>
                            <span class="action-badge" id="mobileCartBadge">0</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileSuggestionsBtn">
                            <i class="fas fa-lightbulb"></i>
                            <span>Suggestions</span>
                        </a>
                    </li>
                </ul>
            </div>
            
            <div class="mobile-menu-section">
                <h3 class="mobile-menu-title">Categories</h3>
                <ul class="mobile-menu-items">
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-category="electronics">
                            <i class="fas fa-laptop"></i>
                            <span>Electronics</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-category="fashion">
                            <i class="fas fa-tshirt"></i>
                            <span>Fashion</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-category="home">
                            <i class="fas fa-home"></i>
                            <span>Home</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-category="beauty">
                            <i class="fas fa-spa"></i>
                            <span>Beauty</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-category="sports">
                            <i class="fas fa-dumbbell"></i>
                            <span>Sports</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" data-category="books">
                            <i class="fas fa-book"></i>
                            <span>Books</span>
                        </a>
                    </li>
                </ul>
            </div>
            
            <div class="mobile-menu-section">
                <h3 class="mobile-menu-title">Support</h3>
                <ul class="mobile-menu-items">
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileContactBtn">
                            <i class="fas fa-headset"></i>
                            <span>Contact Us</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileOrdersBtn">
                            <i class="fas fa-box"></i>
                            <span>My Orders</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileReturnsBtn">
                            <i class="fas fa-exchange-alt"></i>
                            <span>Returns</span>
                        </a>
                    </li>
                    <li class="mobile-menu-item">
                        <a href="#" class="mobile-menu-link" id="mobileLiveChatBtn">
                            <i class="fas fa-comments"></i>
                            <span>Live Chat</span>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content container">
        <!-- Home Page -->
        <div class="page active" id="homePage">
            <!-- Slider -->
            <div class="slider-container">
                <div class="slider" id="slider">
                    <!-- Slides will be loaded dynamically -->
                </div>
                <div class="slider-nav prev" id="sliderPrev">
                    <i class="fas fa-chevron-left"></i>
                </div>
                <div class="slider-nav next" id="sliderNext">
                    <i class="fas fa-chevron-right"></i>
                </div>
                <div class="slider-controls" id="sliderControls">
                    <!-- Slider dots will be loaded dynamically -->
                </div>
            </div>

            <!-- Categories -->
            <div class="section">
                <div class="section-header">
                    <h2 class="section-title">Shop by Category</h2>
                </div>
                <div class="categories-grid" id="categoriesGrid">
                    <!-- Categories will be loaded dynamically -->
                </div>
            </div>

            <!-- Trending Products -->
            <div class="section">
                <div class="section-header">
                    <h2 class="section-title">Trending Products</h2>
                    <a href="#" class="view-all" id="viewTrending">
                        View All
                        <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
                <div class="products-grid" id="trendingProducts">
                    <!-- Products will be loaded dynamically -->
                </div>
            </div>

            <!-- Discounted Products -->
            <div class="section">
                <div class="section-header">
                    <h2 class="section-title">Discounted Products</h2>
                    <a href="#" class="view-all" id="viewDiscounted">
                        View All
                        <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
                <div class="products-grid" id="discountedProducts">
                    <!-- Products will be loaded dynamically -->
                </div>
            </div>

            <!-- Top Rated Products -->
            <div class="section">
                <div class="section-header">
                    <h2 class="section-title">Top Rated</h2>
                    <a href="#" class="view-all" id="viewTopRated">
                        View All
                        <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
                <div class="products-grid" id="topRatedProducts">
                    <!-- Products will be loaded dynamically -->
                </div>
            </div>

            <!-- Most Sold Products -->
            <div class="section">
                <div class="section-header">
                    <h2 class="section-title">Most Sold</h2>
                    <a href="#" class="view-all" id="viewMostSold">
                        View All
                        <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
                <div class="products-grid" id="mostSoldProducts">
                    <!-- Products will be loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- Store Page -->
        <div class="page" id="storePage">
            <div class="store-header">
                <h1 class="store-title">All Products</h1>
                <div class="store-controls">
                    <select class="store-select" id="sortSelect">
                        <option value="default">Sort by: Default</option>
                        <option value="price-low">Price: Low to High</option>
                        <option value="price-high">Price: High to Low</option>
                        <option value="rating">Highest Rated</option>
                        <option value="popular">Most Popular</option>
                        <option value="newest">Newest First</option>
                        <option value="discount">Best Discount</option>
                    </select>
                    <select class="store-select" id="filterSelect">
                        <option value="all">All Categories</option>
                        <option value="electronics">Electronics</option>
                        <option value="fashion">Fashion</option>
                        <option value="home">Home & Kitchen</option>
                        <option value="beauty">Beauty</option>
                        <option value="sports">Sports</option>
                        <option value="books">Books</option>
                        <option value="toys">Toys</option>
                    </select>
                    <select class="store-select" id="priceSelect">
                        <option value="all">All Prices</option>
                        <option value="0-50">Under <b><strong>৳</strong></b>50</option>
                        <option value="50-100"><b><strong>৳</strong></b>50 - <b><strong>৳</strong></b>100</option>
                        <option value="100-200"><b><strong>৳</strong></b>100 - <b><strong>৳</strong></b>200</option>
                        <option value="200-500"><b><strong>৳</strong></b>200 - <b><strong>৳</strong></b>500</option>
                        <option value="500+">Above <b><strong>৳</strong></b>500</option>
                    </select>
                </div>
            </div>
            <div class="products-grid" id="storeProducts">
                <!-- Store products will be loaded dynamically -->
            </div>
            <div class="text-center mt-5" id="storePagination">
                <!-- Pagination will be loaded dynamically -->
            </div>
        </div>

        <!-- Product Details Page -->
        <div class="page" id="productPage">
            <div class="product-details-container" id="productDetailsContainer">
                <!-- Product details will be loaded dynamically -->
            </div>
        </div>

        <!-- Admin Panel -->
        <div class="page" id="adminPage">
            <div class="admin-header">
                <h1 class="admin-title">Admin Dashboard</h1>
                <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                    <input type="text" class="admin-search" id="adminSearch" placeholder="Search products, users...">
                    <button class="action-btn-large" id="clearSearchBtn" style="display: none;">
                        <i class="fas fa-times"></i>Clear
                    </button>
                    <button class="action-btn-large" id="addProductBtn">
                        <i class="fas fa-plus"></i> Add Product
                    </button>
                </div>
            </div>
            
            <!-- Statistics -->
            <div class="admin-stats-grid">
                <div class="admin-stat-card">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Total Users</div>
                        <div class="admin-stat-icon">
                            <i class="fas fa-users"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminTotalUsers">0</div>
                    <div class="admin-stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span id="adminUsersChange">0%</span> from last month
                    </div>
                </div>
                
                <div class="admin-stat-card">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Total Products</div>
                        <div class="admin-stat-icon">
                            <i class="fas fa-box"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminTotalProducts">0</div>
                    <div class="admin-stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span id="adminProductsChange">0%</span> from last month
                    </div>
                </div>
                
                <div class="admin-stat-card">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Total Orders</div>
                        <div class="admin-stat-icon">
                            <i class="fas fa-shopping-cart"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminTotalOrders">0</div>
                    <div class="admin-stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span id="adminOrdersChange">0%</span> from last month
                    </div>
                </div>
                
                <div class="admin-stat-card">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Total Revenue</div>
                        <div class="admin-stat-icon">
                            <i class="fas fa-dollar-sign"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminTotalRevenue"><b><strong>৳</strong></b>0</div>
                    <div class="admin-stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span id="adminRevenueChange">0%</span> from last month
                    </div>
                </div>
                
                <div class="admin-stat-card">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Avg. Order Value</div>
                        <div class="admin-stat-icon">
                            <i class="fas fa-chart-line"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminAvgOrder"><b><strong>৳</strong></b>0</div>
                    <div class="admin-stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span id="adminAvgOrderChange">0%</span> from last month
                    </div>
                </div>
                
                <div class="admin-stat-card">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Conversion Rate</div>
                        <div class="admin-stat-icon">
                            <i class="fas fa-percentage"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminConversion">0%</div>
                    <div class="admin-stat-change negative">
                        <i class="fas fa-arrow-down"></i>
                        <span id="adminConversionChange">0%</span> from last month
                    </div>
                </div>
                <div class="admin-stat-card order-validation">
                    <div class="admin-stat-header">
                        <div class="admin-stat-title">Pending Orders</div>
                        <div class="admin-stat-icon">
                            <i class="fa-solid fa-box-open"></i>
                        </div>
                    </div>
                    <div class="admin-stat-value" id="adminConversion">0</div>
                    <div class="admin-stat-change">
                        <i class="fa-solid fa-arrow-up-right-dots"></i>
                        <span id="adminConversionChange">0</span> total orders.
                    </div>
                </div>
            </div>
            
            <!-- Charts -->
            <div class="admin-charts">
                <div class="admin-chart-container">
                    <h3 class="admin-chart-title">Sales Overview</h3>
                    <div class="admin-chart" id="salesChart">
                        <!-- Chart will be rendered here -->
                    </div>
                </div>
                
                <div class="admin-chart-container">
                    <h3 class="admin-chart-title">Product Categories</h3>
                    <div class="admin-chart" id="categoriesChart">
                        <!-- Chart will be rendered here -->
                    </div>
                </div>
                
                <div class="admin-chart-container">
                    <h3 class="admin-chart-title">User Activity</h3>
                    <div class="admin-chart" id="activityChart">
                        <!-- Chart will be rendered here -->
                    </div>
                </div>
            </div>
            
            <!-- Product Analytics Table -->
            <div class="admin-table-container">
                <h3 class="admin-table-title">Product Analytics</h3>
                <div class="table-responsive">
                    <table class="admin-table" id="productAnalyticsTable">
                        <thead>
                            <tr>
                                <th>Product</th>
                                <th>Views</th>
                                <th>Clicks</th>
                                <th>Wishlist</th>
                                <th>Cart Adds</th>
                                <th>Purchases</th>
                                <th>Avg. View Time</th>
                                <th>Conversion Rate</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="productAnalyticsBody">
                            <!-- Analytics data will be loaded dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- User Analytics Table -->
            <div class="admin-table-container">
                <h3 class="admin-table-title">User Analytics</h3>
                <div class="table-responsive">
                    <table class="admin-table" id="userAnalyticsTable">
                        <thead>
                            <tr>
                                <th>User</th>
                                <th>Total Orders</th>
                                <th>Total Spent</th>
                                <th>Avg. Order Value</th>
                                <th>Last Activity</th>
                                <th>Session Time</th>
                                <th>Products Viewed</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="userAnalyticsBody">
                            <!-- User analytics data will be loaded dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Recent Activities -->
            <div class="admin-table-container">
                <h3 class="admin-table-title">Recent Activities</h3>
                <div class="table-responsive">
                    <table class="admin-table" id="recentActivitiesTable">
                        <thead>
                            <tr>
                                <th>User</th>
                                <th>Activity</th>
                                <th>Product</th>
                                <th>Time</th>
                                <th>Duration</th>
                                <th>IP Address</th>
                                <th>Device</th>
                            </tr>
                        </thead>
                        <tbody id="recentActivitiesBody">
                            <!-- Activities will be loaded dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Get to Know Us</h3>
                    <ul class="footer-links">
                        <li><a href="#">About ShoPure</a></li>
                        <li><a href="#">Careers</a></li>
                        <li><a href="#">Press Releases</a></li>
                        <li><a href="#">ShoPure Science</a></li>
                        <li><a href="#">Investor Relations</a></li>
                        <li><a href="#">ShoPure Devices</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Make Money with Us</h3>
                    <ul class="footer-links">
                        <li><a href="#">Sell on ShoPure</a></li>
                        <li><a href="#">Become an Affiliate</a></li>
                        <li><a href="#">Advertise Your Products</a></li>
                        <li><a href="#">Fulfillment by ShoPure</a></li>
                        <li><a href="#">ShoPure Business</a></li>
                        <li><a href="#">Associates Program</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Payment Methods</h3>
                    <ul class="footer-links">
                        <li><a href="#">Credit Cards</a></li>
                        <li><a href="#">Debit Cards</a></li>
                        <li><a href="#">bKash</a></li>
                        <li><a href="#">Nagad</i></a></li>
                        <li><a href="#">Rocket</a></li>
                        <li><a href="#">Upay</a></li>
                    </ul>
                    <div class="footer-payment">
                        <div class="payment-method">
                            <i class="fa-solid fa-credit-card"></i>
                        </div>
                        <div class="payment-method">
                            <i class="fab fa-cc-mastercard"></i>
                        </div>
                        <div class="payment-method">
                            <i class="fab fa-cc-amex"></i>
                        </div>
                        <div class="payment-method">
                            <i class="fas fa-mobile-alt"></i>
                        </div>
                    </div>
                </div>
                
                <div class="footer-section">
                    <h3>Let Us Help You</h3>
                    <ul class="footer-links">
                        <li><a href="#" id="footerContactBtn">Contact Us</a></li>
                        <li><a href="#" id="footerOrdersBtn">Your Orders</a></li>
                        <li><a href="#">Returns & Replacements</a></li>
                        <li><a href="#">Shipping Rates & Policies</a></li>
                        <li><a href="#">Help Center</a></li>
                        <li><a href="#">COVID-19 Response</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Download Our App</h3>
                    <div class="footer-apps">
                        <a href="#" class="app-link">
                            <i class="fab fa-apple"></i>
                            <div>
                                <span style="font-size: 0.75rem;">Download on the</span>
                                <div style="font-weight: 600;">App Store</div>
                            </div>
                        </a>
                        <a href="#" class="app-link">
                            <i class="fab fa-google-play"></i>
                            <div>
                                <span style="font-size: 0.75rem;">Get it on</span>
                                <div style="font-weight: 600;">Google Play</div>
                            </div>
                        </a>
                    </div>
                    
                    <h3 class="mt-4">Follow Us</h3>
                    <div class="footer-social">
                        <a href="https://www.facebook.com/share/1BVKsgiFfn/" class="social-link">
                            <i class="fab fa-facebook-f"></i>
                        </a>
                        <a href="https://www.facebook.com/share/1BVKsgiFfn/" class="social-link">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="https://www.facebook.com/share/1BVKsgiFfn/" class="social-link">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="https://www.facebook.com/share/1BVKsgiFfn/" class="social-link">
                            <i class="fab fa-youtube"></i>
                        </a>
                        <a href="https://www.facebook.com/share/1BVKsgiFfn/" class="social-link">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="mailto:shopuredotcom@gmail.com" class="social-link">
                            <i class="fa-regular fa-envelope"></i>
                        </a>
                        <a href="https://wa.me/8801712345678?text=Hey%20ShoPure%2C%20I%20need%20a%20help%21"
                            class="social-link"
                            target="_blank">
                            <i class="fab fa-whatsapp"></i>
                        </a>

                    </div>
                </div>
            </div>
            
            <div class="footer-bottom">
                <div class="footer-payment">
                    <div class="payment-method">
                        <i class="fab fa-cc-visa"></i>
                    </div>
                    <div class="payment-method">
                        <i class="fab fa-cc-mastercard"></i>
                    </div>
                    <div class="payment-method">
                        <i class="fab fa-cc-amex"></i>
                    </div>
                    <div class="payment-method">
                        <i class="fab fa-cc-paypal"></i>
                    </div>
                    <div class="payment-method">
                        <i class="fab fa-cc-discover"></i>
                    </div>
                    <div class="payment-method">
                        <i class="fas fa-university"></i>
                    </div>
                </div>
                
                <div class="copyright">
                    <p>&copy; 2026 ShopureDotcom. All rights reserved.</p>
                    <p class="mt-2">
                        <a href="#" style="color: var(--text-secondary); margin: 0 10px;">Privacy Policy</a> |
                        <a href="#" style="color: var(--text-secondary); margin: 0 10px;">Terms of Use</a> |
                        <a href="#" style="color: var(--text-secondary); margin: 0 10px;">Cookie Policy</a> |
                        <a href="#" style="color: var(--text-secondary); margin: 0 10px;">Interest-Based Ads</a> |
                        <a href="#" style="color: var(--text-secondary); margin: 0 10px;">Your Ads Privacy Choices</a> |
                        <a href="https://didarul15-rob.github.io/didarul/" target="_blank" rel="noopener noreferrer"
                        style="color: var(--text-secondary); margin: 0 10px;">Developer Portfolio</a> |
                        <a href="https://didarul15-rob.github.io/didarul/" target="_blank" rel="noopener noreferrer"
                        style="color: var(--text-secondary); margin: 0 10px;">CEO</a>

                    </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Toast Notifications -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Floating Buttons -->
    
    <!-- Mobile Bottom Navigation (Android-like) -->
    <nav class="mobile-bottom-nav" id="mobileBottomNav" aria-label="Mobile Navigation">
        <button class="mobile-nav-btn" id="mobileThemeToggle" title="Toggle Theme">
            <i class="fas fa-moon"></i>
        </button>
        <button class="mobile-nav-btn" id="mobileNavSuggestionsBtn" title="Product Suggestions">
            <i class="fas fa-lightbulb"></i>
        </button>
        <button class="mobile-nav-btn" id="mobileNavProfileBtn" title="Profile">
            <i class="fas fa-user"></i>
        </button>
        <button class="mobile-nav-btn" id="mobileNavWishlistBtn" title="Wishlist">
            <i class="fas fa-heart"></i>
            <span class="badge" id="mobileBottomWishlistBadge">0</span>
        </button>
        <button class="mobile-nav-btn" id="mobileNavCartBtn" title="Cart">
            <i class="fas fa-shopping-cart"></i>
            <span class="badge" id="mobileBottomCartBadge">0</span>
        </button>
    </nav>

<!-- Floating Buttons -->
<div class="floating-buttons">
    <!-- Uncomment this if you want the contact button -->
    <button class="floating-btn" id="floatingContactBtn" title="Contact Us">
        <i class="fas fa-headset"></i>
    </button>
    
    <button class="floating-btn" id="floatingChatBtn" title="Live Chat">
        <i class="fas fa-comment-dots"></i>
    </button>
    
    <!-- This button might already exist or not -->
    <button class="floating-btn" id="floatingBackBtn" title="Back to Top">
        <i class="fas fa-arrow-up"></i>
    </button>
</div>

    <!-- All Modals -->
    <!-- Profile Modal -->
    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="profileModalTitle">Profile</h2>
                <button class="modal-close" id="closeProfileModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="profile-tabs" id="profileTabs">
                    <button class="profile-tab active" data-tab="login">Login</button>
                    <button class="profile-tab" data-tab="register">Register</button>
                    <button class="profile-tab" data-tab="profile" style="display: none;">Profile</button>
                </div>
                
                <div class="profile-content active" id="loginTab">
                    <form class="profile-form" id="loginForm">
                        <div class="admin-form-group">
                            <label class="admin-form-label">Email</label>
                            <input type="email" class="admin-form-input" id="loginEmail" placeholder="Enter your email" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Password</label>
                            <input type="password" class="admin-form-input" id="loginPassword" placeholder="Enter your password" required>
                        </div>
                        <div class="form-actions">
                            <button type="submit" class="form-btn btn-primary">Login</button>
                            <button type="button" class="form-btn btn-secondary" id="loginCancelBtn">Cancel</button>
                        </div>
                    </form>
                </div>
                
                <div class="profile-content" id="registerTab">
                    <form class="profile-form" id="registerForm">
                        <div class="admin-form-group">
                            <label class="admin-form-label">Full Name</label>
                            <input type="text" class="admin-form-input" id="registerName" placeholder="Enter your full name" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Email</label>
                            <input type="email" class="admin-form-input" id="registerEmail" placeholder="Enter your email" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Password</label>
                            <input type="password" class="admin-form-input" id="registerPassword" placeholder="Create a password" minlength="8" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Confirm Password</label>
                            <input type="password" class="admin-form-input" id="registerConfirmPassword" placeholder="Confirm your password" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Phone Number</label>
                            <input type="tel" class="admin-form-input" id="registerPhone" placeholder="Enter your phone number">
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Address</label>
                            <textarea class="admin-form-input admin-form-textarea" id="registerAddress" placeholder="Enter your address"></textarea>
                        </div>
                        <div class="form-actions">
                            <button type="submit" class="form-btn btn-primary">Create Account</button>
                            <button type="button" class="form-btn btn-secondary" id="registerCancelBtn">Cancel</button>
                        </div>
                    </form>
                </div>
                
                <div class="profile-content" id="profileTab">
                    <div class="profile-info">
                        <div class="profile-image-container">
                            <img src="https://images.unsplash.com/photo-1535713875002-d1d0cf377fde?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60" 
                                 alt="Profile" class="profile-image" id="profileImage">
                        </div>
                        <h3 class="profile-name" id="profileUserName">Didarul Abedin</h3>
                        <p class="profile-email" id="profileUserEmail">didarulabedin@shopure.com</p>
                        <p class="profile-phone" id="profileUserPhone">+8801897204672</p>
                        <p class="profile-address" id="profileUserAddress">Jatrabari, Dhaka</p>
                        
                        <div class="profile-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="profileOrders">0</div>
                                <div class="stat-label">Orders</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="profileSpent"><b><strong>৳</strong></b>0</div>
                                <div class="stat-label">Spent</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="profileWishlist">0</div>
                                <div class="stat-label">Wishlist</div>
                            </div>
                        </div>
                        
                        <div class="form-actions">
                            <button class="form-btn btn-primary" id="editProfileBtn">
                                <i class="fas fa-edit"></i> Edit Profile
                            </button>
                            <button class="form-btn btn-secondary" id="logoutBtn">Logout</button>
                            <button class="form-btn btn-secondary" id="closeProfileBtn">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Cart Modal -->
    <div class="modal-overlay" id="cartModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Your Cart</h2>
                <button class="modal-close" id="closeCartModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="cart-items" id="cartItemsContainer">
                    <!-- Cart items will be loaded dynamically -->
                </div>
                <div class="cart-summary">
                    <div class="summary-row">
                        <span>Subtotal:</span>
                        <span id="cartSubtotal"><b><strong>৳</strong></b>0.00</span>
                    </div>
                    <div class="summary-row">
                        <span>Shipping:</span>
                        <span id="cartShipping"><b><strong>৳</strong></b>5.99</span>
                    </div>
                    <div class="summary-row">
                        <span>Tax:</span>
                        <span id="cartTax"><b><strong>৳</strong></b>0.00</span>
                    </div>
                    <div class="summary-row summary-total">
                        <span>Total:</span>
                        <span id="cartTotal"><b><strong>৳</strong></b>5.99</span>
                    </div>
                    <button class="checkout-btn" id="checkoutBtn">Proceed to Checkout</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Order Modal -->
    <div class="modal-overlay" id="orderModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Complete Your Order</h2>
                <button class="modal-close" id="closeOrderModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="orderForm">
                    <div class="admin-form-group">
                        <label class="admin-form-label">Full Name</label>
                        <input type="text" class="admin-form-input" id="orderName" required>
                    </div>
                    <div class="admin-form-group">
                        <label class="admin-form-label">Phone Number</label>
                        <input type="tel" class="admin-form-input" id="orderPhone" required>
                    </div>
                    <div class="admin-form-group">
                        <label class="admin-form-label">Email</label>
                        <input type="email" class="admin-form-input" id="orderEmail" required>
                    </div>
                    <div class="admin-form-group">
                        <label class="admin-form-label">Shipping Address</label>
                        <textarea class="admin-form-input admin-form-textarea" id="orderAddress" rows="3" required></textarea>
                    </div>
                    <div class="admin-form-group">
                        <label class="admin-form-label">City</label>
                        <input type="text" class="admin-form-input" id="orderCity" required>
                    </div>
                    <div class="admin-form-group">
                        <label class="admin-form-label">Postal Code</label>
                        <input type="text" class="admin-form-input" id="orderPostalCode" required>
                    </div>
                    
                    <div class="mb-4">
                        <h3 class="section-title mb-3">Payment Method</h3>
                        <div class="message-box">

                            <div class="message-content bangla-message active">
                                <h3>অনুগ্রহ করে বার্তাটি মনোযোগসহকারে পড়ুন</h3>

                                <p>বর্তমানে আমাদের কাছে শুধুমাত্র <strong>Cash on Delivery (COD)</strong> সুবিধাটি চালু রয়েছে।</p>
                                <p>তবে আপনার অর্ডারটি কনফার্ম করার জন্য অনুগ্রহ করে <strong>ডেলিভারি চার্জটি অগ্রিম পরিশোধ</strong> করতে হবে।</p>

                                <hr>

                                <p>আপনার লোকেশন অনুযায়ী ডেলিভারি চার্জের বিস্তারিত তথ্য নিচের চার্টে দেওয়া আছে।</p>
                                <p>এছাড়াও, পেমেন্ট করার জন্য যেসব অপশনগুলো বর্তমানে অ্যাভেইলেবল রয়েছে, সেগুলোর তথ্যও নিচে উল্লেখ করা হলো।</p>

                                <p class="thanks">আপনার সহযোগিতার জন্য আন্তরিকভাবে ধন্যবাদ। 😊</p>

                                <span class="translate-btn" onclick="showEnglish()">English</span>
                            </div>

                            <div class="message-content english-message">
                                <h3>Please read the message carefully</h3>

                                <p>Currently, only <strong>Cash on Delivery (COD)</strong> is available.</p>
                                <p>However, to confirm your order, kindly <strong>pay the delivery charge in advance</strong>.</p>

                                <hr>

                                <p>The delivery charge details based on your location are provided in the chart below.</p>
                                <p>The available payment options for paying the delivery charge are also mentioned below.</p>

                                <p class="thanks">Thank you very much for your cooperation. 😊</p>

                                <span class="translate-btn" onclick="showBangla()">বাংলা</span>
                            </div>

                        </div>
                    </div>


                    <div class="admin-form-group" id="paymentDetails">
                        <div class="paymentMethod">
                            <select name="newPaymentMethod" class="newPaymentMethod newPaymentMethod" required>
                                <option value="">Select Payment</option>
                                <option value="bkash">bKash</option>
                                <option value="nagad">Nagad</option>
                                <option value="card">Card</option>
                                <option value="rocket">Rocket</option>
                                <option value="upay">Upay</option>
                            </select>
                        </div>
                        <div class="payment-instructions-table">
                            <h4 style="margin-bottom: 12px; color: var(--text-primary);">Payment Details</h4>
                            <div class="payment-table-container">
                                <table class="payment-table">
                                    <thead>
                                        <tr>
                                            <th>Payment Method</th>
                                            <th>Account Number</th>
                                            <th>Minimum</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>
                                                <i class="fas fa-mobile-alt" style="color: #E2136E; margin-right: 8px;"></i>
                                                bKash
                                            </td>
                                            <td>01897204672</td>
                                            <td><b><strong>৳</strong></b>60</td>                                        
                                        </tr>
                                        <tr>
                                            <td>
                                                <i class="fas fa-wallet" style="color: #F8A61F; margin-right: 8px;"></i>
                                                Nagad
                                            </td>
                                            <td>01897204672</td>
                                            <td><b><strong>৳</strong></b>60</td>                                        
                                        </tr>
                                        <tr>
                                            <td>
                                                <i class="fas fa-rocket" style="color: #5D2D91; margin-right: 8px;"></i>
                                                Rocket
                                            </td>
                                            <td>01897204672</td>
                                            <td><b><strong>৳</strong></b>60</td>                                        
                                        </tr>
                                        <tr>
                                            <td>
                                                <i class="fas fa-qrcode" style="color: #00AEEF; margin-right: 8px;"></i>
                                                Upay
                                            </td>
                                            <td>01897204672</td>
                                            <td><b><strong>৳</strong></b>60</td>                                        
                                        </tr>
                                        <tr>
                                            <td>
                                                <i class="fab fa-cc-visa" style="color: #1A1F71; margin-right: 8px;"></i>
                                                Visa Card
                                            </td>
                                            <td>DBBL 4840610005406279</td>
                                            <td><b><strong>৳</strong></b>60</td>                                        
                                        </tr>
                                        <tr>
                                            <td>
                                                <i class="fas fa-university" style="color: #b30606; margin-right: 8px;"></i>
                                                Bank
                                            </td>
                                            <td>DBBL 148105 - 0484857</td>
                                            <td><b><strong>৳</strong></b>60</td>                                        
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            <p style="margin-top: 12px; font-size: 0.85rem; color: var(--text-secondary); line-height: 1.4;">
                                <i class="fas fa-info-circle" style="color: var(--info-color); margin-right: 4px;"></i>
                                <strong>Important:</strong> Send only to the numbers above. Send at least <b><strong>৳</strong></b>60 as delivery charge. 
                                Include the last 3 digits of your payment number in the form below.
                            </p>
                        </div>
                        <label class="admin-form-label">Transaction ID</label>
                        <input type="text" class="admin-form-input" id="transactionId" placeholder="Enter transaction ID">
                        <label class="admin-form-label mt-3">Payment Amount</label>
                        <input type="number" class="admin-form-input" id="paymentAmount" placeholder="Enter payment amount">
                        <label class="admin-form-label mt-3">last 3 digits of your payment number.</label>
                        <input type="number" class="admin-form-input" id="lastThreeDigits" placeholder="Enter 3 digits">
                    </div>
                    
                    <div class="cart-summary">
                        <div class="summary-row">
                            <span>Subtotal:</span>
                            <span id="orderSubtotal"><b><strong>৳</strong></b>0.00</span>
                        </div>
                        <div class="summary-row">
                            <span>Shipping:</span>
                            <span id="orderShipping"><b><strong>৳</strong></b>5.99</span>
                        </div>
                        <div class="summary-row">
                            <span>Tax:</span>
                            <span id="orderTax"><b><strong>৳</strong></b>0.00</span>
                        </div>
                        <div class="summary-row summary-total">
                            <span>Total:</span>
                            <span id="orderTotal"><b><strong>৳</strong></b>5.99</span>
                        </div>
                    </div>
                    
                    <div class="form-actions">
                        <button type="submit" class="form-btn btn-primary" disabled style="opacity: 0.6; cursor: not-allowed;">Place Order</button>
                        <button type="button" class="form-btn btn-secondary" id="cancelOrderBtn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Contact Modal -->
    <div class="modal-overlay" id="contactModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Contact Us</h2>
                <button class="modal-close" id="closeContactModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="contact-options">
                    <a href="https://wa.me/8801897204672" target="_blank" class="contact-option">
                        <div class="contact-icon">
                            <i class="fab fa-whatsapp"></i>
                        </div>
                        <div class="contact-details">
                            <div class="contact-title">WhatsApp</div>
                            <div class="contact-info">+880 1897 204672</div>
                        </div>
                    </a>
                    <a href="https://m.me/shopuredotcom" target="_blank" class="contact-option">
                        <div class="contact-icon">
                            <i class="fab fa-facebook-messenger"></i>
                        </div>
                        <div class="contact-details">
                            <div class="contact-title">Messenger</div>
                            <div class="contact-info">@shopuredotcom</div>
                        </div>
                    </a>
                    <a href="mailto:shopuredotcom@gmail.com" class="contact-option">
                        <div class="contact-icon">
                            <i class="fas fa-envelope"></i>
                        </div>
                        <div class="contact-details">
                            <div class="contact-title">Email</div>
                            <div class="contact-info">shopuredotcom@gmail.com</div>
                        </div>
                    </a>
                    <div class="contact-option" id="liveChatBtn">
                        <div class="contact-icon">
                            <i class="fas fa-comments"></i>
                        </div>
                        <div class="contact-details">
                            <div class="contact-title">Live Chat</div>
                            <div class="contact-info">Chat with our support team</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chat Modal -->
    <div class="modal-overlay" id="chatModal">
        <div class="modal chat-modal">
            <div class="chat-header">
                <div class="chat-avatar">
                    <i class="fas fa-headset"></i>
                </div>
                <div class="chat-info">
                    <h3>Support Team</h3>
                    <div class="chat-status">
                        <span class="status-dot"></span>
                        <span>Online</span>
                    </div>
                </div>
                <button class="modal-close" id="closeChatModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="chat-body">
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message message-incoming">
                        <div class="message-content">Welcome to ShoPure Live Chat! How can we help you today?</div>
                        <div class="message-time">Just now</div>
                    </div>
                </div>
                <div class="chat-input-container">
                    <div class="chat-input-wrapper">
                        <input type="text" class="chat-input" id="chatInput" placeholder="Type your message...">
                        <div class="chat-input-actions">
                            <button class="chat-emoji-btn" id="emojiBtn" title="Emoji">
                                <i class="far fa-smile"></i>
                            </button>
                            <button class="chat-attach-btn" id="attachBtn" title="Attach file">
                                <i class="fas fa-paperclip"></i>
                            </button>
                        </div>
                    </div>
                    <button class="chat-send-btn" id="sendChatBtn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Wishlist Modal -->
    <div class="modal-overlay" id="wishlistModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Your Wishlist</h2>
                <button class="modal-close" id="closeWishlistModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="cart-items" id="wishlistItemsContainer">
                    <!-- Wishlist items will be loaded dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Suggestions Modal -->
    <div class="modal-overlay" id="suggestionsModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Personalized Suggestions</h2>
                <button class="modal-close" id="closeSuggestionsModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="products-grid" id="suggestionsProducts">
                    <!-- Suggested products will be loaded dynamically -->
                </div>
            </div>
        </div>
    </div>
    <!-- Admin Product Modal -->
    <div class="modal-overlay" id="adminProductModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="adminProductModalTitle">Add New Product</h2>
                <button class="modal-close" id="closeAdminProductModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="adminProductForm">
                    <div class="admin-form-group">
                        <label class="admin-form-label">Product Name</label>
                        <input type="text" class="admin-form-input" id="adminProductName" required>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Category</label>
                        <select class="admin-form-select" id="adminProductCategory" required>
                            <option value="">Select Category</option>
                            <option value="electronics">Electronics</option>
                            <option value="fashion">Fashion</option>
                            <option value="home">Home & Kitchen</option>
                            <option value="beauty">Beauty</option>
                            <option value="sports">Sports</option>
                            <option value="books">Books</option>
                            <option value="toys">Toys</option>
                        </select>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Description</label>
                        <textarea class="admin-form-input admin-form-textarea" id="adminProductDescription" required></textarea>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Price (<b><strong>৳</strong></b>)</label>
                        <input type="number" class="admin-form-input" id="adminProductPrice" step="0.01" required>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Original Price (<b><strong>৳</strong></b>)</label>
                        <input type="number" class="admin-form-input" id="adminProductOriginalPrice" step="0.01">
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Stock Quantity</label>
                        <input type="number" class="admin-form-input" id="adminProductStock" required>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Product Images</label>
                        <div class="admin-form-images" id="adminProductImages">
                            <!-- Image previews will be added here -->
                        </div>
                        <input type="file" class="admin-form-file" id="adminProductImageUpload" accept="image/*" multiple>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Specifications (JSON)</label>
                        <textarea class="admin-form-input admin-form-textarea" id="adminProductSpecs" placeholder='{"Brand": "Example", "Model": "X100", "Color": "Black"}'></textarea>
                    </div>
                    
                    <div class="admin-form-group">
                        <label class="admin-form-label">Tags (comma separated)</label>
                        <input type="text" class="admin-form-input" id="adminProductTags" placeholder="tag1, tag2, tag3">
                    </div>
                    
                    <div class="form-actions">
                        <button type="submit" class="form-btn btn-primary" id="adminProductSubmit">Save Product</button>
                        <button type="button" class="form-btn btn-secondary" id="adminProductCancel">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Zoom Modal -->
    <div class="modal-overlay" id="zoomModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Product Image</h2>
                <button class="modal-close" id="closeZoomModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <img src="" alt="Zoomed Product Image" id="zoomedImage" style="width: 100%; height: auto; border-radius: var(--radius);">
            </div>
        </div>
    </div>

    <!-- Image Gallery Modal -->
    <div class="modal-overlay" id="galleryModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Product Gallery</h2>
                <button class="modal-close" id="closeGalleryModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="thumbnail-container" id="galleryThumbnails">
                    <!-- Gallery thumbnails will be loaded dynamically -->
                </div>
                <div class="main-image-container" style="height: 400px; margin-top: 1rem;">
                    <img src="" alt="Gallery Image" id="galleryMainImage" style="width: 100%; height: 100%; object-fit: contain;">
                </div>
            </div>
        </div>
    </div>
<!-- Review Form Modal -->
<div class="modal-overlay" id="reviewModal">
    <div class="modal review-form-modal">
        <div class="modal-header">
            <h2 class="modal-title">Write a Review</h2>
            <button class="modal-close" id="closeReviewModal">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="modal-body review-form-content">
            <form id="reviewForm">
                <div class="review-rating-input">
                    <label class="rating-label">Your Rating</label>
                    <div class="rating-stars-input" id="ratingStars">
                        <i class="fas fa-star rating-star-input" data-value="1"></i>
                        <i class="fas fa-star rating-star-input" data-value="2"></i>
                        <i class="fas fa-star rating-star-input" data-value="3"></i>
                        <i class="fas fa-star rating-star-input" data-value="4"></i>
                        <i class="fas fa-star rating-star-input" data-value="5"></i>
                    </div>
                    <div class="rating-value" id="ratingValue">0.0</div>
                </div>
                
                <input type="hidden" id="reviewProductId">
                
                <div class="admin-form-group">
                    <label class="admin-form-label">Review Title</label>
                    <input type="text" class="review-title-input" id="reviewTitle" 
                           placeholder="Summarize your experience" required>
                </div>
                
                <div class="admin-form-group">
                    <label class="admin-form-label">Your Review</label>
                    <textarea class="review-text-input" id="reviewText" 
                              placeholder="Share details of your experience with this product" required></textarea>
                </div>
                
                <div class="review-images-upload">
                    <label class="admin-form-label">Add Photos (Optional)</label>
                    <div class="upload-area" id="uploadArea">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>Drag & drop images or click to upload</p>
                        <span>Up to 5 images, 5MB each</span>
                    </div>
                    <input type="file" class="image-input" id="reviewImages" 
                           accept="image/*" multiple style="display: none;">
                    <div class="uploaded-images-preview" id="uploadedImagesPreview"></div>
                </div>
                
                <div class="form-actions-review">
                    <button type="submit" class="form-btn btn-primary" id="submitReviewBtn">
                        <i class="fas fa-paper-plane"></i> Submit Review
                    </button>
                    <button type="button" class="form-btn btn-secondary" id="cancelReviewBtn">
                        Cancel
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>
    <!-- JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@latest"></script>
    <script>
        // ===== GLOBAL VARIABLES =====
        const APP_NAME = 'ShoPure';
        const APP_VERSION = '1.0.0';
        const ADMIN_PASSWORD = 'admin@shopure2023!';
        const SECRET_KEY = 'shopure-secret-key-2023';
        
        let currentUser = null;
        let currentPage = 'home';
        let users = [];
        let cart = [];
        let wishlist = [];
        let orders = [];
        let interactions = [];
        let activities = [];
        let slides = [];
        let categories = [];
        let reviews = [];
        let suggestions = [];
        let products = [];
        
        let currentSlide = 0;
        let slideInterval;
        let productViewTimers = {};
        let userActivityTimers = {};
        let screenTimeInterval;
        let nanoTimeTracker = {};

        let searchPlaceholders = [
            "Search smartphones and gadgets...",
            "Looking for fashion trends?",
            "Find home appliances...",
            "Discover beauty products...",
            "Search sports equipment...",
            "Looking for books?",
            "Find toys and games..."
        ];
        let currentPlaceholderIndex = 0;
        let placeholderInterval;

        // ===== RELATED PRODUCTS FUNCTIONS =====
        function getRelatedProducts(productId) {
            try {
                const product = products.find(p => p.id == productId);
                if (!product) return [];
                
                // Cache for performance
                const cacheKey = `related_${productId}`;
                if (window.relatedProductsCache && window.relatedProductsCache[cacheKey]) {
                    return [...window.relatedProductsCache[cacheKey]];
                }
                
                // Initialize cache if not exists
                if (!window.relatedProductsCache) {
                    window.relatedProductsCache = {};
                }
                
                const MAX_RELATED = 8;
                const relatedProducts = new Map(); // Use Map to avoid duplicates
                
                // Algorithm 1: Multi-dimensional scoring system
                const scoredProducts = scoreAllProducts(product);
                
                // Algorithm 2: Category-based with advanced filtering
                const categoryProducts = getCategoryProducts(product, scoredProducts);
                
                // Algorithm 3: Semantic similarity analysis
                const semanticProducts = getSemanticRelated(product, scoredProducts);
                
                // Algorithm 4: Behavioral/trending products
                const trendingProducts = getTrendingProducts(product, scoredProducts);
                
                // Combine all algorithms with priority
                combineAlgorithms(
                    relatedProducts,
                    categoryProducts,    // Highest priority
                    semanticProducts,    // Second priority
                    trendingProducts     // Third priority
                );
                
                // Convert Map to array and sort by final score
                let finalRelated = Array.from(relatedProducts.values())
                    .sort((a, b) => {
                        // Sort by total score (descending)
                        if (b.finalScore !== a.finalScore) {
                            return b.finalScore - a.finalScore;
                        }
                        
                        // Secondary: Name alphabetical
                        const nameA = a.name.toLowerCase();
                        const nameB = b.name.toLowerCase();
                        if (nameA !== nameB) {
                            return nameA.localeCompare(nameB);
                        }
                        
                        // Tertiary: Price proximity
                        const priceDiffA = Math.abs(product.price - a.price);
                        const priceDiffB = Math.abs(product.price - b.price);
                        return priceDiffA - priceDiffB;
                    })
                    .slice(0, MAX_RELATED);
                
                // If we still don't have enough products, add random high-scoring ones
                if (finalRelated.length < MAX_RELATED) {
                    const remainingNeeded = MAX_RELATED - finalRelated.length;
                    const takenIds = new Set(finalRelated.map(p => p.id));
                    const additional = scoredProducts
                        .filter(p => !takenIds.has(p.id) && p.id !== productId)
                        .sort((a, b) => b.totalScore - a.totalScore)
                        .slice(0, remainingNeeded)
                        .map(p => ({
                            ...p,
                            finalScore: p.totalScore
                        }));
                    
                    finalRelated = [...finalRelated, ...additional];
                }
                
                // Ensure we have exactly MAX_RELATED products
                finalRelated = finalRelated.slice(0, MAX_RELATED);
                
                // Remove scoring metadata before returning
                const cleanRelated = finalRelated.map(p => {
                    const { totalScore, finalScore, ...cleanProduct } = p;
                    return cleanProduct;
                });
                
                // Cache the result
                window.relatedProductsCache[cacheKey] = cleanRelated;
                
                return cleanRelated;
                
            } catch (error) {
                console.error('Error in getRelatedProducts:', error);
                return getFallbackRelatedProducts(productId);
            }
        }

        // ===== HELPER FUNCTIONS =====

        function scoreAllProducts(mainProduct) {
            return products
                .filter(p => p.id !== mainProduct.id)
                .map(otherProduct => {
                    let totalScore = 0;
                    const weights = {
                        category: 40,
                        price: 25,
                        tags: 20,
                        name: 15,
                        description: 10,
                        rating: 10,
                        trending: 8,
                        stock: 5,
                        brand: 15
                    };
                    
                    // 1. Category scoring
                    if (otherProduct.category === mainProduct.category) {
                        totalScore += weights.category;
                    } else if (getCategoryGroup(mainProduct.category) === getCategoryGroup(otherProduct.category)) {
                        totalScore += weights.category * 0.5; // Partial score for related categories
                    }
                    
                    // 2. Price proximity scoring
                    const priceDiff = Math.abs(mainProduct.price - otherProduct.price);
                    const priceSimilarity = 1 - Math.min(priceDiff / (mainProduct.price || 1), 1);
                    totalScore += priceSimilarity * weights.price;
                    
                    // 3. Tag overlap scoring
                    if (mainProduct.tags && otherProduct.tags) {
                        const mainTags = new Set(mainProduct.tags.map(t => t.toLowerCase()));
                        const otherTags = new Set(otherProduct.tags.map(t => t.toLowerCase()));
                        let commonTags = 0;
                        
                        for (const tag of mainTags) {
                            if (otherTags.has(tag)) commonTags++;
                        }
                        
                        const tagScore = (commonTags / Math.max(mainTags.size, 1)) * weights.tags;
                        totalScore += tagScore;
                    }
                    
                    // 4. Name similarity scoring
                    const nameSimilarity = calculateNameSimilarity(mainProduct.name, otherProduct.name);
                    totalScore += nameSimilarity * weights.name;
                    
                    // 5. Description keyword scoring
                    const descSimilarity = calculateDescriptionSimilarity(
                        mainProduct.description || '',
                        otherProduct.description || ''
                    );
                    totalScore += descSimilarity * weights.description;
                    
                    // 6. Rating similarity scoring
                    const ratingDiff = Math.abs((mainProduct.rating || 0) - (otherProduct.rating || 0));
                    const ratingSimilarity = Math.max(0, 1 - ratingDiff / 5);
                    totalScore += ratingSimilarity * weights.rating;
                    
                    // 7. Trending/featured bonus
                    if (otherProduct.trending) totalScore += weights.trending;
                    if (otherProduct.topRated) totalScore += weights.trending * 0.8;
                    if (otherProduct.mostSold) totalScore += weights.trending * 0.6;
                    
                    // 8. Stock bonus
                    if (otherProduct.stock > 10) totalScore += weights.stock;
                    if (otherProduct.stock > 50) totalScore += weights.stock * 0.5;
                    
                    // 9. Brand matching
                    const mainBrand = mainProduct.specifications?.Brand || '';
                    const otherBrand = otherProduct.specifications?.Brand || '';
                    if (mainBrand && otherBrand && mainBrand.toLowerCase() === otherBrand.toLowerCase()) {
                        totalScore += weights.brand;
                    }
                    
                    return {
                        ...otherProduct,
                        totalScore: Math.round(totalScore * 100) / 100
                    };
                });
        }

        function getCategoryProducts(mainProduct, scoredProducts) {
            const sameCategory = scoredProducts
                .filter(p => p.category === mainProduct.category)
                .sort((a, b) => b.totalScore - a.totalScore);
            
            if (sameCategory.length <= 5) {
                return sameCategory;
            }
            
            // If more than 5 same-category products, use multiple strategies
            const strategies = [
                // Strategy A: Top by overall score
                sameCategory.slice(0, 2),
                
                // Strategy B: Top by name alphabetical
                [...sameCategory]
                    .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()))
                    .slice(0, 2),
                
                // Strategy C: Top by tag overlap (if available)
                mainProduct.tags && mainProduct.tags.length > 0 
                    ? [...sameCategory]
                        .sort((a, b) => {
                            const aTags = new Set((a.tags || []).map(t => t.toLowerCase()));
                            const bTags = new Set((b.tags || []).map(t => t.toLowerCase()));
                            const mainTags = new Set(mainProduct.tags.map(t => t.toLowerCase()));
                            
                            const aOverlap = [...aTags].filter(t => mainTags.has(t)).length;
                            const bOverlap = [...bTags].filter(t => mainTags.has(t)).length;
                            return bOverlap - aOverlap;
                        })
                        .slice(0, 2)
                    : [],
                
                // Strategy D: Closest price
                [...sameCategory]
                    .sort((a, b) => {
                        const aDiff = Math.abs(mainProduct.price - a.price);
                        const bDiff = Math.abs(mainProduct.price - b.price);
                        return aDiff - bDiff;
                    })
                    .slice(0, 2)
            ];
            
            // Combine strategies and remove duplicates
            const combined = new Map();
            strategies.forEach(strategy => {
                strategy.forEach(product => {
                    if (!combined.has(product.id)) {
                        combined.set(product.id, {
                            ...product,
                            finalScore: product.totalScore + (combined.size * 0.1) // Slight bonus for strategy diversity
                        });
                    }
                });
            });
            
            return Array.from(combined.values());
        }

        function getSemanticRelated(mainProduct, scoredProducts) {
            const semanticProducts = [];
            
            // Focus on products with high description similarity
            const byDescription = [...scoredProducts]
                .sort((a, b) => {
                    const aSim = calculateDescriptionSimilarity(mainProduct.description || '', a.description || '');
                    const bSim = calculateDescriptionSimilarity(mainProduct.description || '', b.description || '');
                    return bSim - aSim;
                })
                .slice(0, 4);
            
            semanticProducts.push(...byDescription);
            
            // Add products with similar specifications
            if (mainProduct.specifications) {
                const specKeys = Object.keys(mainProduct.specifications);
                if (specKeys.length > 0) {
                    const bySpecs = scoredProducts
                        .filter(p => p.specifications)
                        .map(p => {
                            let matchCount = 0;
                            specKeys.forEach(key => {
                                if (p.specifications[key] && 
                                    p.specifications[key].toString().toLowerCase() === 
                                    mainProduct.specifications[key].toString().toLowerCase()) {
                                    matchCount++;
                                }
                            });
                            return { product: p, matchCount };
                        })
                        .filter(item => item.matchCount > 0)
                        .sort((a, b) => b.matchCount - a.matchCount)
                        .slice(0, 2)
                        .map(item => item.product);
                    
                    semanticProducts.push(...bySpecs);
                }
            }
            
            return semanticProducts;
        }

        function getTrendingProducts(mainProduct, scoredProducts) {
            return scoredProducts
                .filter(p => p.trending || p.mostSold || p.topRated)
                .sort((a, b) => {
                    let aBonus = 0;
                    let bBonus = 0;
                    
                    if (a.trending) aBonus += 3;
                    if (a.mostSold) aBonus += 2;
                    if (a.topRated) aBonus += 1;
                    
                    if (b.trending) bBonus += 3;
                    if (b.mostSold) bBonus += 2;
                    if (b.topRated) bBonus += 1;
                    
                    return bBonus - aBonus;
                })
                .slice(0, 3);
        }

        function combineAlgorithms(targetMap, ...algorithmResults) {
            algorithmResults.forEach((results, algorithmIndex) => {
                results.forEach((product, resultIndex) => {
                    if (!targetMap.has(product.id)) {
                        // Calculate final score with algorithm priority weighting
                        const priorityWeight = 1 - (algorithmIndex * 0.1); // First algorithm gets 1.0, second 0.9, etc.
                        const positionWeight = 1 - (resultIndex * 0.05); // Higher position in results gets more weight
                        
                        const finalScore = (product.totalScore || 0) * priorityWeight * positionWeight;
                        
                        targetMap.set(product.id, {
                            ...product,
                            finalScore: Math.round(finalScore * 100) / 100
                        });
                    }
                });
            });
        }

        // ===== UTILITY FUNCTIONS =====

        function getCategoryGroup(category) {
            const groups = {
                electronics: ['electronics', 'computers', 'phones', 'tablets'],
                fashion: ['fashion', 'clothing', 'shoes', 'accessories'],
                home: ['home', 'kitchen', 'furniture', 'appliances'],
                beauty: ['beauty', 'health', 'wellness', 'personalcare'],
                sports: ['sports', 'fitness', 'outdoors', 'recreation']
            };
            
            for (const [group, categories] of Object.entries(groups)) {
                if (categories.includes(category)) {
                    return group;
                }
            }
            return category;
        }

        function calculateNameSimilarity(name1, name2) {
            const cleanName1 = name1.toLowerCase().replace(/[^a-z0-9\s]/g, '');
            const cleanName2 = name2.toLowerCase().replace(/[^a-z0-9\s]/g, '');
            
            // Simple word overlap
            const words1 = new Set(cleanName1.split(/\s+/).filter(w => w.length > 2));
            const words2 = new Set(cleanName2.split(/\s+/).filter(w => w.length > 2));
            
            let common = 0;
            for (const word of words1) {
                if (words2.has(word)) common++;
            }
            
            const union = new Set([...words1, ...words2]).size;
            
            return union > 0 ? common / union : 0;
        }

        function calculateDescriptionSimilarity(desc1, desc2) {
            if (!desc1 || !desc2 || desc1.length < 20 || desc2.length < 20) {
                return 0;
            }
            
            // Extract keywords (words longer than 3 characters)
            const getKeywords = (text) => {
                return text.toLowerCase()
                    .split(/\W+/)
                    .filter(word => word.length > 3)
                    .slice(0, 15); // Limit to 15 keywords for performance
            };
            
            const keywords1 = new Set(getKeywords(desc1));
            const keywords2 = new Set(getKeywords(desc2));
            
            let common = 0;
            for (const word of keywords1) {
                if (keywords2.has(word)) common++;
            }
            
            const union = new Set([...keywords1, ...keywords2]).size;
            
            return union > 0 ? common / union : 0;
        }

        function getFallbackRelatedProducts(productId) {
            const product = products.find(p => p.id == productId);
            if (!product) return [];
            
            // Simple fallback: same category + trending
            let related = products.filter(p => 
                p.id != productId && 
                p.category === product.category
            );
            
            if (related.length < 8) {
                const trending = products.filter(p => 
                    p.id != productId && 
                    p.trending &&
                    !related.some(r => r.id == p.id)
                );
                related = [...related, ...trending];
            }
            
            // Add random if still not enough
            if (related.length < 8) {
                const allOther = products.filter(p => 
                    p.id != productId && 
                    !related.some(r => r.id == p.id)
                );
                const random = allOther
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 8 - related.length);
                related = [...related, ...random];
            }
            
            return related.slice(0, 8);
        }

        function calculateAverageRating(productId) {
            const productReviews = reviews.filter(r => r.productId == productId);
            if (productReviews.length === 0) return 0;
            
            const totalRating = productReviews.reduce((sum, review) => sum + review.rating, 0);
            return totalRating / productReviews.length;
        }

        function getProductById(productId) {
            return products.find(p => p.id == productId);
        }

        function getProductsByCategory(category, excludeId = null) {
            let filtered = products.filter(p => p.category === category);
            if (excludeId) {
                filtered = filtered.filter(p => p.id != excludeId);
            }
            return filtered;
        }
        // ===== TOAST NOTIFICATIONS =====
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) return;
            
            const toastId = 'toast-' + Date.now();
            const toast = document.createElement('div');
            toast.id = toastId;
            toast.className = `toast ${type}`;
            
            // Set icon based on type
            let icon = 'info-circle';
            switch(type) {
                case 'success': icon = 'check-circle'; break;
                case 'error': icon = 'exclamation-circle'; break;
                case 'warning': icon = 'exclamation-triangle'; break;
                case 'info': icon = 'info-circle'; break;
            }
            
            toast.innerHTML = `
                <div class="toast-icon">
                    <i class="fas fa-${icon}"></i>
                </div>
                <div class="toast-content">
                    <div class="toast-title">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.closest('.toast').remove()">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            toastContainer.appendChild(toast);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                const toastElement = document.getElementById(toastId);
                if (toastElement) {
                    toastElement.style.animation = 'slideRight 0.6s ease';
                    setTimeout(() => toastElement.remove(), 300);
                }
            }, 6000);
        }

        // ===== REVIEW MODAL FUNCTIONS =====
        function setupReviewModal() {
            //console.log('Setting up review modal...');
            
            // Create review modal if it doesn't exist
            if (!document.getElementById('reviewModal')) {
                const reviewModalHTML = `
                    <div class="modal-overlay" id="reviewModal">
                        <div class="modal review-form-modal">
                            <div class="modal-header">
                                <h2 class="modal-title">Write a Review</h2>
                                <button class="modal-close" id="closeReviewModal">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div class="modal-body review-form-content">
                                <form id="reviewForm">
                                    <div class="review-rating-input">
                                        <label class="rating-label">Your Rating</label>
                                        <div class="rating-stars-input" id="ratingStars">
                                            <i class="fas fa-star rating-star-input" data-value="1"></i>
                                            <i class="fas fa-star rating-star-input" data-value="2"></i>
                                            <i class="fas fa-star rating-star-input" data-value="3"></i>
                                            <i class="fas fa-star rating-star-input" data-value="4"></i>
                                            <i class="fas fa-star rating-star-input" data-value="5"></i>
                                        </div>
                                        <div class="rating-value" id="ratingValue">0.0</div>
                                    </div>
                                    
                                    <input type="hidden" id="reviewProductId">
                                    
                                    <div class="admin-form-group">
                                        <label class="admin-form-label">Review Title</label>
                                        <input type="text" class="review-title-input" id="reviewTitle" 
                                            placeholder="Summarize your experience" required>
                                    </div>
                                    
                                    <div class="admin-form-group">
                                        <label class="admin-form-label">Your Review</label>
                                        <textarea class="review-text-input" id="reviewText" 
                                                placeholder="Share details of your experience with this product" required></textarea>
                                    </div>
                                    
                                    <div class="review-images-upload">
                                        <label class="admin-form-label">Add Photos (Optional)</label>
                                        <div class="upload-area" id="uploadArea">
                                            <i class="fas fa-cloud-upload-alt"></i>
                                            <p>Drag & drop images or click to upload</p>
                                            <span>Up to 5 images, 5MB each</span>
                                        </div>
                                        <input type="file" class="image-input" id="reviewImages" 
                                            accept="image/*" multiple style="display: none;">
                                        <div class="uploaded-images-preview" id="uploadedImagesPreview"></div>
                                    </div>
                                    
                                    <div class="form-actions-review">
                                        <button type="submit" class="form-btn btn-primary" id="submitReviewBtn">
                                            <i class="fas fa-paper-plane"></i> Submit Review
                                        </button>
                                        <button type="button" class="form-btn btn-secondary" id="cancelReviewBtn">
                                            Cancel
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', reviewModalHTML);
                
                // Setup review modal event listeners
                setupReviewModalEvents();
            }
        }
        // ===== REVIEW FUNCTIONS =====
        function loadReviews(productId, sortBy = 'newest') {
            let productReviews = reviews.filter(r => r.productId === productId);
            
            // Sort reviews
            switch(sortBy) {
                case 'newest':
                    productReviews.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    break;
                case 'highest':
                    productReviews.sort((a, b) => b.rating - a.rating);
                    break;
                case 'lowest':
                    productReviews.sort((a, b) => a.rating - b.rating);
                    break;
                case 'helpful':
                    productReviews.sort((a, b) => (b.helpful - b.notHelpful) - (a.helpful - a.notHelpful));
                    break;
            }
            
            return productReviews;
        }
        function setupReviewModalEvents() {
            // Rating stars interaction
            const ratingStars = document.querySelectorAll('.rating-star-input');
            const ratingValue = document.getElementById('ratingValue');
            
            ratingStars.forEach(star => {
                star.addEventListener('click', () => {
                    const value = parseInt(star.dataset.value);
                    
                    // Update stars
                    ratingStars.forEach((s, index) => {
                        if (index < value) {
                            s.classList.add('active');
                        } else {
                            s.classList.remove('active');
                        }
                    });
                    
                    // Update value display
                    ratingValue.textContent = value.toFixed(1);
                });
                
                star.addEventListener('mouseenter', () => {
                    const value = parseInt(star.dataset.value);
                    ratingStars.forEach((s, index) => {
                        if (index < value) {
                            s.classList.add('hover');
                        }
                    });
                });
                
                star.addEventListener('mouseleave', () => {
                    ratingStars.forEach(s => s.classList.remove('hover'));
                });
            });
            // ===== PRODUCT RATING FUNCTIONS =====
            function calculateAverageRating(productId) {
                const productReviews = reviews.filter(r => r.productId == productId);
                if (productReviews.length === 0) return 0;
                
                const totalRating = productReviews.reduce((sum, review) => sum + review.rating, 0);
                return totalRating / productReviews.length;
            }

            // ===== PRODUCT UTILITY FUNCTIONS =====
            function getProductById(productId) {
                return products.find(p => p.id == productId);
            }

            function getProductsByCategory(category, excludeId = null) {
                let filtered = products.filter(p => p.category === category);
                if (excludeId) {
                    filtered = filtered.filter(p => p.id != excludeId);
                }
                return filtered;
            }
            // Upload area click
            const uploadArea = document.getElementById('uploadArea');
            const reviewImagesInput = document.getElementById('reviewImages');
            
            if (uploadArea && reviewImagesInput) {
                uploadArea.addEventListener('click', () => {
                    reviewImagesInput.click();
                });
                
                reviewImagesInput.addEventListener('change', handleReviewImageUpload);
            }
            
            // Close modal
            const closeBtn = document.getElementById('closeReviewModal');
            const cancelBtn = document.getElementById('cancelReviewBtn');
            
            if (closeBtn) {
                closeBtn.addEventListener('click', () => hideModal('reviewModal'));
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => hideModal('reviewModal'));
            }
            
            // Form submission
            const reviewForm = document.getElementById('reviewForm');
            if (reviewForm) {
                reviewForm.addEventListener('submit', handleReviewSubmit);
            }
        }

        // ===== UTILITY FUNCTIONS =====
        function formatDate(date) {
            const d = new Date(date);
            const now = new Date();
            const diffTime = Math.abs(now - d);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return 'Today';
            } else if (diffDays === 1) {
                return 'Yesterday';
            } else if (diffDays < 7) {
                return `${diffDays} days ago`;
            } else if (diffDays < 30) {
                return `${Math.floor(diffDays / 7)} weeks ago`;
            } else {
                return d.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    year: d.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
                });
            }
        }

        // ===== SEARCH FUNCTIONS =====
        function handleSearchInput() {
            const searchInput = document.getElementById('searchInput');
            const suggestions = document.getElementById('searchSuggestions');
            
            if (!searchInput || !suggestions) return;
            
            const query = searchInput.value.trim();
            
            if (query.length < 2) {
                suggestions.classList.remove('active');
                return;
            }
            
            // Filter products based on search query
            const searchResults = searchProducts(query);
            
            if (searchResults.length > 0) {
                showSearchSuggestions(searchResults);
            } else {
                suggestions.classList.remove('active');
            }
        }

        function searchProducts(query) {
            const searchTerm = query.toLowerCase();
            
            return products.filter(product => {
                // Search in name, category, description, and tags
                return (
                    product.name.toLowerCase().includes(searchTerm) ||
                    product.category.toLowerCase().includes(searchTerm) ||
                    product.description.toLowerCase().includes(searchTerm) ||
                    (product.tags && product.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
                );
            }).slice(0, 10); // Limit to 10 results
        }
        
        //send search data to google sheet
        function sendSearchData(searchDetails){

            const searchData = {
                id: currentUser.id,
                name: currentUser.name,
                email: currentUser.email,
                phone: currentUser.phone,
                query: searchDetails.query,
                results: JSON.stringify(searchDetails.results)
            };
            const data = new URLSearchParams(searchData);

            fetch("https://script.google.com/macros/s/AKfycbwjVIY-vonkhELprvpGszqvpa-Id-SBxkbkgxBh2UAAqkPaT6shJzM918kikBDxD1K-aA/exec", {
                method: "POST",
                mode: "no-cors",
                body: data
        });
        };

        function showSearchSuggestions(results) {
            const suggestions = document.getElementById('searchSuggestions');
            if (!suggestions) return;
            
            let html = '';
            
            results.forEach(product => {
                const discount = product.originalPrice ? 
                    Math.round(((product.originalPrice - product.price) / product.originalPrice) * 100) : 0;
                
                html += `
                    <div class="suggestion-item" data-product-id="${product.id}">
                        <img src="${product.images[0]}" alt="${product.name}" class="suggestion-img">
                        <div class="suggestion-info">
                            <div class="suggestion-name">${product.name}</div>
                            <div class="suggestion-price">
                                <b><strong>৳</strong></b>${product.price.toFixed(2)}
                                ${product.originalPrice ? 
                                    `<span style="text-decoration: line-through; color: var(--text-secondary); margin-left: 5px; font-size: 0.8em;">
                                        <b><strong>৳</strong></b>${product.originalPrice.toFixed(2)}
                                    </span>` : ''
                                }
                                ${discount > 0 ? 
                                    `<span style="color: var(--error-color); margin-left: 5px; font-size: 0.8em;">
                                        -${discount}%
                                    </span>` : ''
                                }
                            </div>
                        </div>
                    </div>
                `;
            });
            
            // Add a view all results option
            if (results.length >= 10) {
                html += `
                    <div class="suggestion-item" id="viewAllResults">
                        <div class="suggestion-info" style="text-align: center;">
                            <div class="suggestion-name" style="color: var(--primary-color);">
                                View all results for "${document.getElementById('searchInput').value}"
                            </div>
                        </div>
                    </div>
                `;
            }
            
            suggestions.innerHTML = html;
            suggestions.classList.add('active');
            
            // Add click events to suggestions
            setupSearchSuggestionEvents();
        }

        function setupSearchSuggestionEvents() {
            const suggestionItems = document.querySelectorAll('.suggestion-item');
            const suggestions = document.getElementById('searchSuggestions');
            
            suggestionItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    const productId = item.dataset.productId;
                    
                    if (item.id === 'viewAllResults') {
                        // Handle view all results
                        handleSearch();
                    } else if (productId) {
                        // View specific product
                        viewProduct(productId);
                        suggestions.classList.remove('active');
                        document.getElementById('searchInput').value = '';
                    }
                });
            });
        }

        function handleSearch() {
            const searchInput = document.getElementById('searchInput');
            const query = searchInput.value.trim();

            if (query.length < 2) {
                showToast('Please enter at least 2 characters to search', 'warning');
                return;
            }
            
            // Navigate to store page with search results
            navigateTo('store');
            
            // Filter products
            const filteredProducts = searchProducts(query);
            
            // Render search results
            renderSearchResults(filteredProducts, query);
            
            // Clear search input
            searchInput.value = '';
            document.getElementById('searchSuggestions').classList.remove('active');
            
            // Track search activity
            trackActivity('search', null, query);
        }

        function renderSearchResults(results, query) {
            sendSearchData({query: query, results: results});
            const storeProductsContainer = document.getElementById('storeProducts');
            const storeHeader = document.querySelector('.store-header h1');
            
            if (!storeProductsContainer || !storeHeader) return;
            
            // Update header
            storeHeader.textContent = `Search Results for "${query}"`;
            
            if (results.length === 0) {
                storeProductsContainer.innerHTML = `
                    <div class="text-center" style="grid-column: 1/-1; padding: 3rem; color: var(--text-secondary)">
                        <i class="fas fa-search" style="font-size: 4rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3 style="margin-bottom: 0.5rem;">No products found</h3>
                        <p>No results found for "${query}". Try different keywords.</p>
                        <button class="action-btn-large mt-3" onclick="navigateTo('home')">
                            <i class="fas fa-home"></i> Back to Home
                        </button>
                    </div>
                `;
            } else {
                renderProducts(results, 'storeProducts');
            }
        }

        // ===== MOBILE MENU FUNCTIONS =====
        function showMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            if (mobileMenu) {
                mobileMenu.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function hideMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            if (mobileMenu) {
                mobileMenu.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        // ===== STORE FILTER FUNCTIONS =====
        function handleSortChange() {
            loadStorePage();
        }

        function handleFilterChange() {
            loadStorePage();
        }

        function filterProductsByCategory(category) {
            const filterSelect = document.getElementById('filterSelect');
            if (filterSelect) {
                filterSelect.value = category;
                loadStorePage();
            }
        }
        // ===== MODAL FUNCTIONS =====
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        function handleReviewImageUpload(e) {
            const files = e.target.files;
            const previewContainer = document.getElementById('uploadedImagesPreview');
            
            if (!previewContainer) return;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    const imageElement = document.createElement('div');
                    imageElement.className = 'uploaded-image';
                    imageElement.innerHTML = `
                        <img src="${event.target.result}" alt="Review image">
                        <button type="button" class="remove-image-btn" onclick="this.parentElement.remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    previewContainer.appendChild(imageElement);
                };
                
                reader.readAsDataURL(file);
            }
        }

        function handleReviewSubmit(e) {
            e.preventDefault();
            
            const productId = document.getElementById('reviewProductId').value;
            const rating = parseFloat(document.getElementById('ratingValue').textContent);
            const title = document.getElementById('reviewTitle').value.trim();
            const text = document.getElementById('reviewText').value.trim();
            
            if (!currentUser) {
                showToast('Please login to submit a review', 'error');
                return;
            }
            
            if (rating === 0) {
                showToast('Please select a rating', 'error');
                return;
            }
            
            if (!title || !text) {
                showToast('Please fill in title and review text', 'error');
                return;
            }
            
            // Get uploaded images
            const uploadedImages = Array.from(document.querySelectorAll('#uploadedImagesPreview img')).map(img => img.src);
            
            // Create review
            const review = {
                id: Date.now(),
                productId: parseInt(productId),
                userId: currentUser.id,
                rating: rating,
                title: title,
                comment: text,
                images: uploadedImages,
                helpful: 0,
                notHelpful: 0,
                createdAt: new Date().toISOString()
            };
            sendReviewData(review);
            // Add to reviews
            reviews.push(review);
            
            // Update product rating
            const product = products.find(p => p.id === parseInt(productId));
            if (product) {
                const productReviews = reviews.filter(r => r.productId === parseInt(productId));
                const averageRating = productReviews.reduce((sum, r) => sum + r.rating, 0) / productReviews.length;
                product.rating = averageRating;
                product.ratingCount = productReviews.length;
            }
            
            saveToLocalStorage();
            hideModal('reviewModal');
            showToast('Review submitted successfully!', 'success');
            
            // Reload product page if it's currently open
            if (currentPage === 'product') {
                loadProductPage(productId);
            }
        }

        //send review data to google sheet
        function sendReviewData(review){

            const data = new URLSearchParams(review);
            fetch("https://script.google.com/macros/s/AKfycbyOPNjpa-OOZmoQ3mDQ3GaKo5X-z4FXoV68S3LAY5xIXtLAlhjLk9GzxvDqKbv5kmVu/exec", {
                method: "POST",
                mode: "no-cors",
                body: data
        });
        };


        function showReviewModal(productId) {
            if (!currentUser) {
                showToast('Please login to write a review', 'error');
                showProfileModal();
                return;
            }
            
            // Reset form
            document.getElementById('reviewProductId').value = productId;
            document.getElementById('reviewTitle').value = '';
            document.getElementById('reviewText').value = '';
            document.getElementById('uploadedImagesPreview').innerHTML = '';
            
            // Reset stars
            const ratingStars = document.querySelectorAll('.rating-star-input');
            const ratingValue = document.getElementById('ratingValue');
            ratingStars.forEach(star => star.classList.remove('active'));
            ratingValue.textContent = '0.0';
            
            showModal('reviewModal');
        }

        // Make functions available globally
        window.showReviewModal = showReviewModal;
        // ===== SECURITY FUNCTIONS =====
        function hashPassword(password) {
            // Simple hash function for demonstration (use bcrypt in production)
            let hash = 0;
            for (let i = 0; i < password.length; i++) {
                const char = password.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        function encryptData(data) {
            // Simple encryption for demonstration (use proper encryption in production)
            return btoa(JSON.stringify(data));
        }

        function decryptData(encryptedData) {
            try {
                return JSON.parse(atob(encryptedData));
            } catch {
                return null;
            }
        }

        function generateToken(userId) {
            const timestamp = Date.now();
            const random = Math.random().toString(36).substr(2);
            return hashPassword(`${userId}${timestamp}${random}${SECRET_KEY}`);
        }

        function validateToken(token, userId) {
            // Token validation logic
            return true;
        }

        // ===== INITIALIZATION =====
        // ===== LOADER CONTROL =====
        document.addEventListener('DOMContentLoaded', () => {
            // Show loader initially
            showLoader();
            
            // Initialize app
            initializeApp();
            
            // Setup event listeners
            setupEventListeners();
            
            // Load initial data
            loadInitialData();
            
            // Hide loader after everything is loaded
            setTimeout(hideLoader, 1500);
        });

        function initializeApp() {
            //console.log('Initializing app...');
            
            // Load saved data
            loadFromLocalStorage();
            
            // Load category interactions
            const savedCategoryInteractions = localStorage.getItem('shopure_category_interactions_v3');
            if (savedCategoryInteractions) {
                window.categoryInteractions = JSON.parse(savedCategoryInteractions);
            }
            
            // Initialize UI
            initializeUI();
            
            // Start background processes
            startBackgroundProcesses();
            
            // Setup Intersection Observer
            setupIntersectionObserver();
            
            // Load initial content
            loadHomePage();
            
            //console.log('App initialized');
        }

                // ===== STORE PAGE =====
        function loadStorePage() {
            //console.log('Loading store page...');
            
            const sortSelect = document.getElementById('sortSelect');
            const filterSelect = document.getElementById('filterSelect');
            const priceSelect = document.getElementById('priceSelect');
            
            if (!sortSelect || !filterSelect || !priceSelect) return;
            
            // Get filter values
            const sortBy = sortSelect.value;
            const category = filterSelect.value;
            const priceRange = priceSelect.value;
            
            // Filter products
            let filteredProducts = [...products];
            
            // Filter by category
            if (category !== 'all') {
                filteredProducts = filteredProducts.filter(p => p.category === category);
            }
            
            // Filter by price range
            if (priceRange !== 'all') {
                const [min, max] = priceRange === '500+' ? [500, Infinity] : priceRange.split('-').map(Number);
                filteredProducts = filteredProducts.filter(p => {
                    return priceRange === '500+' ? p.price >= 500 : p.price >= min && p.price <= max;
                });
            }
            
            // Sort products
            switch(sortBy) {
                case 'price-low':
                    filteredProducts.sort((a, b) => a.price - b.price);
                    break;
                case 'price-high':
                    filteredProducts.sort((a, b) => b.price - a.price);
                    break;
                case 'rating':
                    filteredProducts.sort((a, b) => b.rating - a.rating);
                    break;
                case 'popular':
                    // Sort by combination of rating and sales
                    filteredProducts.sort((a, b) => {
                        const aScore = a.rating * 100 + (a.metadata?.purchases || 0);
                        const bScore = b.rating * 100 + (b.metadata?.purchases || 0);
                        return bScore - aScore;
                    });
                    break;
                case 'newest':
                    filteredProducts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    break;
                case 'discount':
                    filteredProducts.sort((a, b) => {
                        const aDiscount = a.originalPrice ? ((a.originalPrice - a.price) / a.originalPrice) * 100 : 0;
                        const bDiscount = b.originalPrice ? ((b.originalPrice - b.price) / b.originalPrice) * 100 : 0;
                        return bDiscount - aDiscount;
                    });
                    break;
            }
            
            // Render products
            renderProducts(filteredProducts, 'storeProducts');
            
            // Update pagination
            updatePagination(filteredProducts.length);
            
            //console.log('Store page loaded');
        }

        function updatePagination(totalProducts) {
            const paginationContainer = document.getElementById('storePagination');
            if (!paginationContainer) return;
            
            const productsPerPage = 24;
            const totalPages = Math.ceil(totalProducts / productsPerPage);
            
            if (totalPages <= 1) {
                paginationContainer.innerHTML = '';
                return;
            }
            
            let html = `
                <div class="flex-center" style="gap: 0.5rem;">
                    <button class="action-btn-large" style="padding: 0.5rem 1rem;" id="prevPage">
                        <i class="fas fa-chevron-left"></i>
                    </button>
            `;
            
            // Show page numbers
            for (let i = 1; i <= Math.min(totalPages, 5); i++) {
                html += `
                    <button class="action-btn-large ${i === 1 ? 'active' : ''}" style="padding: 0.5rem 1rem;" data-page="${i}">
                        ${i}
                    </button>
                `;
            }
            
            if (totalPages > 5) {
                html += `<span style="padding: 0.5rem;">...</span>`;
            }
            
            html += `
                    <button class="action-btn-large" style="padding: 0.5rem 1rem;" id="nextPage">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            `;
            
            paginationContainer.innerHTML = html;
            
            // Add pagination event listeners
            setupPaginationEvents();
        }

        function setupPaginationEvents() {
            // Page number buttons
            document.querySelectorAll('[data-page]').forEach(button => {
                button.addEventListener('click', () => {
                    const page = parseInt(button.dataset.page);
                    goToPage(page);
                });
            });
            
            // Previous page
            document.getElementById('prevPage')?.addEventListener('click', () => {
                const currentPage = document.querySelector('[data-page].active');
                if (currentPage) {
                    const page = parseInt(currentPage.dataset.page);
                    if (page > 1) goToPage(page - 1);
                }
            });
            
            // Next page
            document.getElementById('nextPage')?.addEventListener('click', () => {
                const currentPage = document.querySelector('[data-page].active');
                if (currentPage) {
                    const page = parseInt(currentPage.dataset.page);
                    const totalPages = document.querySelectorAll('[data-page]').length;
                    if (page < totalPages) goToPage(page + 1);
                }
            });
        }

        function goToPage(page) {
            // Update active page button
            document.querySelectorAll('[data-page]').forEach(button => {
                button.classList.toggle('active', parseInt(button.dataset.page) === page);
            });
            
            // Calculate which products to show
            const productsPerPage = 24;
            const startIndex = (page - 1) * productsPerPage;
            const endIndex = startIndex + productsPerPage;
            
            // Get current filtered products
            const sortSelect = document.getElementById('sortSelect');
            const filterSelect = document.getElementById('filterSelect');
            const priceSelect = document.getElementById('priceSelect');
            
            if (!sortSelect || !filterSelect || !priceSelect) return;
            
            // Apply filters and sort (same logic as loadStorePage)
            let filteredProducts = [...products];
            
            const category = filterSelect.value;
            if (category !== 'all') {
                filteredProducts = filteredProducts.filter(p => p.category === category);
            }
            
            const priceRange = priceSelect.value;
            if (priceRange !== 'all') {
                const [min, max] = priceRange === '500+' ? [500, Infinity] : priceRange.split('-').map(Number);
                filteredProducts = filteredProducts.filter(p => {
                    return priceRange === '500+' ? p.price >= 500 : p.price >= min && p.price <= max;
                });
            }
            
            const sortBy = sortSelect.value;
            switch(sortBy) {
                case 'price-low':
                    filteredProducts.sort((a, b) => a.price - b.price);
                    break;
                case 'price-high':
                    filteredProducts.sort((a, b) => b.price - a.price);
                    break;
                case 'rating':
                    filteredProducts.sort((a, b) => b.rating - a.rating);
                    break;
                case 'popular':
                    filteredProducts.sort((a, b) => {
                        const aScore = a.rating * 100 + (a.metadata?.purchases || 0);
                        const bScore = b.rating * 100 + (b.metadata?.purchases || 0);
                        return bScore - aScore;
                    });
                    break;
                case 'newest':
                    filteredProducts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    break;
                case 'discount':
                    filteredProducts.sort((a, b) => {
                        const aDiscount = a.originalPrice ? ((a.originalPrice - a.price) / a.originalPrice) * 100 : 0;
                        const bDiscount = b.originalPrice ? ((b.originalPrice - b.price) / b.originalPrice) * 100 : 0;
                        return bDiscount - aDiscount;
                    });
                    break;
            }
            
            // Get products for current page
            const pageProducts = filteredProducts.slice(startIndex, endIndex);
            
            // Render products
            renderProducts(pageProducts, 'storeProducts');
            
            // Scroll to top of products
            const storeProducts = document.getElementById('storeProducts');
            if (storeProducts) {
                storeProducts.scrollIntoView({ behavior: 'smooth' });
            }
        }


        // ===== SCROLL FUNCTIONS =====
        function handleScroll() {
            // Header scroll effect (already implemented in initializeUI)
            
            // Show/hide back to top button
            const backBtn = document.getElementById('floatingBackBtn');
            if (backBtn) {
                if (window.scrollY > 500) {
                    backBtn.style.display = 'flex';
                } else {
                    backBtn.style.display = 'none';
                }
            }
        }

        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function updateBackButton() {
            const backBtn = document.getElementById('floatingBackBtn');
            if (backBtn) {
                if (currentPage !== 'home') {
                    backBtn.style.display = 'flex';
                    backBtn.innerHTML = '<i class="fas fa-arrow-left"></i>';
                    backBtn.title = 'Back to Home';
                    backBtn.onclick = () => navigateTo('home');
                } else {
                    backBtn.innerHTML = '<i class="fas fa-arrow-up"></i>';
                    backBtn.title = 'Back to Top';
                    backBtn.onclick = scrollToTop;
                }
            }
        }
        function loadInitialData() {
            //console.log('Loading initial data...');
            
            // If no data exists, load default data
            if (products.length === 0) {
                //console.log('No data found, loading default data...');
                loadDefaultData();
            }
            
            // Initialize UI components
            loadSlideData().then(data => {
                slides = data;
                initSlider(slides);
            });
            updateCartCount();
            updateWishlistCount();
            
            //console.log('Data loaded');
        }

        // ===== LOADER CONTROL =====
        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                //console.log('Hiding loader...');
                loader.classList.add('hidden');
                // Remove from DOM after animation
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 500);
            }
        }

        function showLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.display = 'flex';
                loader.classList.remove('hidden');
            }
        }

        function loadFromLocalStorage() {
            try {
                // Load users
                const savedUsers = localStorage.getItem('shopure_users_v3');
                if (savedUsers) users = JSON.parse(savedUsers);
                
                // Load current user
                const savedUser = localStorage.getItem('shopure_current_user_v3');
                if (savedUser) currentUser = JSON.parse(savedUser);
                
                // Load cart
                const savedCart = localStorage.getItem('shopure_cart_v3');
                if (savedCart) cart = JSON.parse(savedCart);
                
                // Load wishlist
                const savedWishlist = localStorage.getItem('shopure_wishlist_v3');
                if (savedWishlist) wishlist = JSON.parse(savedWishlist);
                
                // Load orders
                const savedOrders = localStorage.getItem('shopure_orders_v3');
                if (savedOrders) orders = JSON.parse(savedOrders);
                
                // Load interactions
                const savedInteractions = localStorage.getItem('shopure_interactions_v3');
                if (savedInteractions) interactions = JSON.parse(savedInteractions);
                
                // Load activities
                const savedActivities = localStorage.getItem('shopure_activities_v3');
                if (savedActivities) activities = JSON.parse(savedActivities);
                
                // Load reviews
                const savedReviews = localStorage.getItem('shopure_reviews_v3');
                if (savedReviews) reviews = JSON.parse(savedReviews);
                
                // Load default data if empty
                if (products.length === 0 || users.length === 0) {
                    loadDefaultData();
                }
            } catch (error) {
                console.error('Error loading data:', error);
                loadDefaultData();
            }
        }

        function loadDefaultData() {
            // Default admin user
            users = [
                {
                    id: 1,
                    name: "Admin User",
                    email: "admin@shopure.com",
                    password: hashPassword("admin123"),
                    phone: "+8801897204672",
                    address: "123 Admin Street, Dhaka, Bangladesh",
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    isAdmin: true,
                    orders: [],
                    lastLogin: null,
                    totalSpent: 0,
                    totalOrders: 0,
                    preferences: {
                        categories: ["electronics", "fashion"],
                        priceRange: { min: 0, max: 1000 },
                        likedProducts: [],
                        viewedProducts: []
                    },
                    activityStats: {
                        totalSessions: 0,
                        totalTimeSpent: 0,
                        avgSessionTime: 0,
                        lastActivity: null
                    }
                }
            ];

            
            // In loadDefaultData() function, add this admin user:
            users.push({
                id: 99, // Use a high ID to avoid conflicts
                name: "Admin",
                email: "admin@shopure.com",
                password: hashPassword("admin@shopure2023!"), // Hash the password
                phone: "+8801897204672",
                address: "Admin Headquarters",
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                isAdmin: true,
                orders: [],
                lastLogin: null,
                totalSpent: 0,
                totalOrders: 0,
                preferences: {
                    categories: ["electronics", "fashion"],
                    priceRange: { min: 0, max: 1000 },
                    likedProducts: [],
                    viewedProducts: []
                },
                activityStats: {
                    totalSessions: 0,
                    totalTimeSpent: 0,
                    avgSessionTime: 0,
                    lastActivity: null
                }
            });
           
            saveToLocalStorage();
        }

        function saveToLocalStorage() {
            try {
                localStorage.setItem('shopure_users_v3', JSON.stringify(users));
                localStorage.setItem('shopure_products_v3', JSON.stringify(products));
                localStorage.setItem('shopure_cart_v3', JSON.stringify(cart));
                localStorage.setItem('shopure_wishlist_v3', JSON.stringify(wishlist));
                localStorage.setItem('shopure_orders_v3', JSON.stringify(orders));
                localStorage.setItem('shopure_interactions_v3', JSON.stringify(interactions));
                localStorage.setItem('shopure_activities_v3', JSON.stringify(activities));
                localStorage.setItem('shopure_reviews_v3', JSON.stringify(reviews));
                localStorage.setItem('shopure_categories_v3', JSON.stringify(categories));
                if (currentUser) {
                    localStorage.setItem('shopure_current_user_v3', JSON.stringify(currentUser));
                }
                localStorage.setItem('shopure_last_save_v3', new Date().toISOString());
            } catch (error) {
                console.error('Error saving data:', error);
                showToast('Error saving data', 'error');
            }
        }

        function initializeUI() {
            // Set theme
            if (localStorage.getItem('shopure_theme') === 'dark') {
                document.body.classList.add('dark-mode');
                document.getElementById('themeToggle').innerHTML = '<i class="fas fa-sun"></i>';
                const _mtt = document.getElementById('mobileThemeToggle');
                if (_mtt) _mtt.innerHTML = '<i class="fas fa-sun"></i>';
            }
            // Ensure mobile theme icon matches initial theme
            const _mttDefault = document.getElementById('mobileThemeToggle');
            if (_mttDefault && !document.body.classList.contains('dark-mode')) {
                _mttDefault.innerHTML = '<i class="fas fa-moon"></i>';
            }
            
            // Initialize search placeholder
            initSearchPlaceholder();
            
            // Load home page
            loadHomePage();
            
            // Update counters
            updateCartCount();
            updateWishlistCount();
            
            // Initialize slider
            loadSlideData().then(data => {
                slides = data;
                initSlider(slides);
            });
            // Initialize review modal
            setupReviewModal();
            
            // Setup header scroll effect
            window.addEventListener('scroll', () => {
                const header = document.getElementById('header');
                if (window.scrollY > 50) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }
            });
        }

        
        // Toggle theme (light/dark) - shared by header & mobile bottom nav
        function toggleTheme() {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('shopure_theme', isDark ? 'dark' : 'light');

            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';

            const mobileThemeToggle = document.getElementById('mobileThemeToggle');
            if (mobileThemeToggle) mobileThemeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        }

        function initSearchPlaceholder() {
            const searchInput = document.getElementById('searchInput');
            searchInput.placeholder = searchPlaceholders[0];
            
            placeholderInterval = setInterval(() => {
                currentPlaceholderIndex = (currentPlaceholderIndex + 1) % searchPlaceholders.length;
                searchInput.placeholder = searchPlaceholders[currentPlaceholderIndex];
            }, 4000);
        }

        function setupIntersectionObserver() {
            //console.log('Setting up Intersection Observer...');
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const productId = entry.target.dataset.productId;
                        if (productId && !nanoTimeTracker[productId]) {
                            nanoTimeTracker[productId] = {
                                startTime: performance.now(),
                                userId: currentUser?.id || 'guest'
                            };
                            trackInteraction(productId, 'view');
                            trackActivity('product_view_start', productId);
                            
                            // Update user's viewed products
                            if (currentUser) {
                                updateUserPreferencesInRealTime('product_view', productId);
                            }
                        }
                    } else {
                        const productId = entry.target.dataset.productId;
                        if (productId && nanoTimeTracker[productId]) {
                            const viewData = nanoTimeTracker[productId];
                            const viewTime = performance.now() - viewData.startTime;
                            
                            // Track interaction with time
                            trackInteraction(productId, 'viewTime', Math.round(viewTime));
                            trackActivity('product_view_end', productId, Math.round(viewTime));
                            
                            // Update user viewing stats
                            if (viewData.userId && viewData.userId !== 'guest') {
                                updateUserViewTime(viewData.userId, productId, Math.round(viewTime));
                            }
                            
                            delete nanoTimeTracker[productId];
                        }
                    }
                });
            }, { 
                threshold: 0.5,
                rootMargin: '0px 0px 0px 0px'
            });
            
            // Observe all product cards
            setTimeout(() => {
                const productCards = document.querySelectorAll('.product-card');
                //console.log(`Found ${productCards.length} product cards to observe`);
                
                productCards.forEach(card => {
                    if (card.dataset.productId) {
                        observer.observe(card);
                    }
                });
            }, 500);
        }

        // New function to update user view time
        function updateUserViewTime(userId, productId, viewTime) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            // Initialize viewing stats if not exists
            if (!user.viewingStats) {
                user.viewingStats = {};
            }
            
            if (!user.viewingStats[productId]) {
                user.viewingStats[productId] = {
                    totalTime: 0,
                    sessions: 0,
                    lastViewed: null
                };
            }
            
            // Update stats
            user.viewingStats[productId].totalTime += viewTime;
            user.viewingStats[productId].sessions += 1;
            user.viewingStats[productId].lastViewed = new Date().toISOString();
            
            // Update category view time
            const product = products.find(p => p.id === productId);
            if (product) {
                if (!user.categoryViewTime) {
                    user.categoryViewTime = {};
                }
                user.categoryViewTime[product.category] = 
                    (user.categoryViewTime[product.category] || 0) + viewTime;
            }
            
            user.updatedAt = new Date().toISOString();
            saveToLocalStorage();
        }
        function initSlider(slides) {
            const slider = document.getElementById('slider');
            const sliderControls = document.getElementById('sliderControls');
            
            slider.innerHTML = '';
            sliderControls.innerHTML = '';
            
            slides.forEach((slide, index) => {
                // Create slide
                const slideElement = document.createElement('div');
                slideElement.className = 'slide';
                slideElement.dataset.productId = slide.productId;
                slideElement.innerHTML = `
                    <img src="${slide.image}" alt="${slide.title}" class="slide-image">
                    <div class="slide-overlay"></div>
                    <div class="slide-content">
                        <h2 class="slide-title">${slide.title}</h2>
                        <p class="slide-description">${slide.description}</p>
                        <a href="#" class="slide-btn" data-product-id="${slide.productId}">
                            ${slide.btnText}
                            <i class="fas fa-arrow-right"></i>
                        </a>
                    </div>
                `;
                slider.appendChild(slideElement);
                
                // Add click event to slide
                slideElement.addEventListener('click', () => {
                    viewProduct(slide.productId);
                    activityData = {
                    productId: slide.productId || "",
                    productName: " " || "",
                    activity: "clicked slide-btn" + slide.productId
                }
                sendActivityData(activityData);
                });
                
                // Add click event to button
                slideElement.querySelector('.slide-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    viewProduct(slide.productId);
                    activityData = {
                    productId: slide.productId || "",
                    productName: " " || "",
                    activity: "clicked slide-btn" + slide.productId
                }
                sendActivityData(activityData);
                });
                
                // Create dot
                const dot = document.createElement('div');
                dot.className = `slider-dot ${index === 0 ? 'active' : ''}`;
                dot.addEventListener('click', () => goToSlide(index));
                sliderControls.appendChild(dot);
            });
            
            // Setup navigation
            document.getElementById('sliderPrev').addEventListener('click', () => {
                currentSlide = (currentSlide - 1 + slides.length) % slides.length;
                goToSlide(currentSlide);
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "clicked sliderPrev" + currentSlide
                }
                sendActivityData(activityData);

            });
            
            document.getElementById('sliderNext').addEventListener('click', () => {
                currentSlide = (currentSlide + 1) % slides.length;
                goToSlide(currentSlide);
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "clicked sliderNext" + currentSlide
                }
                sendActivityData(activityData);
            });
            
            // Start auto-slide
            startAutoSlide();
        }

        function startAutoSlide() {
            clearInterval(slideInterval);
            slideInterval = setInterval(() => {
                currentSlide = (currentSlide + 1) % slides.length;
                goToSlide(currentSlide);
            }, 6000);
        }

        function goToSlide(index) {
            currentSlide = index;
            const slider = document.getElementById('slider');
            slider.style.transform = `translateX(-${currentSlide * 100}%)`;
            
            // Update dots
            const dots = document.querySelectorAll('.slider-dot');
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === currentSlide);
            });
            
            // Restart interval
            startAutoSlide();
        }

        function startBackgroundProcesses() {
            // Start screen time tracking
            screenTimeInterval = setInterval(() => {
                Object.keys(nanoTimeTracker).forEach(productId => {
                    const viewTime = performance.now() - nanoTimeTracker[productId];
                    if (viewTime > 1000) { // Update every second
                        trackInteraction(productId, 'viewTime', 1000);
                        nanoTimeTracker[productId] = performance.now();
                    }
                });
            }, 1000);
            
            // Auto-save data every 30 seconds
            setInterval(saveToLocalStorage, 30000);
            
            // Update user activity timer
            setInterval(() => {
                if (currentUser && userActivityTimers[currentUser.id]) {
                    const sessionTime = Date.now() - userActivityTimers[currentUser.id];
                    if (sessionTime > 60000) { // Update every minute
                        updateUserActivity(sessionTime);
                        userActivityTimers[currentUser.id] = Date.now();
                    }
                }
            }, 60000);
        }

        function updateUserActivity(duration) {
            if (!currentUser) return;
            
            const user = users.find(u => u.id === currentUser.id);
            if (user) {
                user.activityStats.totalSessions = (user.activityStats.totalSessions || 0) + 1;
                user.activityStats.totalTimeSpent = (user.activityStats.totalTimeSpent || 0) + duration;
                user.activityStats.avgSessionTime = user.activityStats.totalTimeSpent / user.activityStats.totalSessions;
                user.activityStats.lastActivity = new Date().toISOString();
                user.updatedAt = new Date().toISOString();
            }
        }

        // ===== EVENT LISTENERS SETUP =====
        function setupEventListeners() {
            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Navigation
            document.getElementById('homeLogo').addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo('home');
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "homeLogo clicked"
                }
                sendActivityData(activityData);
            });
            
            // Search
            document.getElementById('searchInput').addEventListener('input', handleSearchInput);
            document.getElementById('searchBtn').addEventListener('click', handleSearch);
            const searchValue = document.getElementById('searchInput').value;
            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSearch();
                    activityData = {
                    productId: "unknown" || "",
                    productName: "unknown" || "",
                    activity: "searched for " + searchValue
                }
                sendActivityData(activityData);
                };
            });
            
            // Close search suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-container')) {
                    document.getElementById('searchSuggestions').classList.remove('active');
                }
            });
            
            // Modals
            document.getElementById('profileBtn').addEventListener('click', showProfileModal);
            document.getElementById('cartBtn').addEventListener('click', showCartModal);
            document.getElementById('wishlistBtn').addEventListener('click', showWishlistModal);
            document.getElementById('suggestionsBtn').addEventListener('click', showSuggestionsModal);

            // Bottom nav (mobile)
            const mobileThemeToggle = document.getElementById('mobileThemeToggle');
            if (mobileThemeToggle) mobileThemeToggle.addEventListener('click', toggleTheme);
            const mobileSuggestionsBtn = document.getElementById('mobileNavSuggestionsBtn');
            if (mobileSuggestionsBtn) mobileSuggestionsBtn.addEventListener('click', showSuggestionsModal);
            const mobileProfileBtn = document.getElementById('mobileNavProfileBtn');
            if (mobileProfileBtn) mobileProfileBtn.addEventListener('click', showProfileModal);
            const mobileWishlistBtn = document.getElementById('mobileNavWishlistBtn');
            if (mobileWishlistBtn) mobileWishlistBtn.addEventListener('click', showWishlistModal);
            const mobileCartBtn = document.getElementById('mobileNavCartBtn');
            if (mobileCartBtn) mobileCartBtn.addEventListener('click', showCartModal);

            // Hide product card actions when tapping outside (mobile)
            document.addEventListener('click', (e) => {
                if (window.matchMedia('(max-width: 768px)').matches) {
                    if (!e.target.closest('.product-card')) {
                        document.querySelectorAll('.product-card.active-actions').forEach(card => card.classList.remove('active-actions'));
                    }
                }
            });

            const _fsb = document.getElementById('floatingSuggestionsBtn');
            if (_fsb) _fsb.addEventListener('click', showSuggestionsModal);
            // Review modal setup
            setupReviewModal();

            // Review sorting
            document.addEventListener('click', function(e) {
                if (e.target.closest('.sort-btn')) {
                    const sortBtn = e.target.closest('.sort-btn');
                    const sortBy = sortBtn.getAttribute('data-sort');
                    
                    // Update active button
                    document.querySelectorAll('.sort-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    sortBtn.classList.add('active');
                    
                    // Reload reviews with new sorting
                    if (currentPage === 'product') {
                        const productId = document.getElementById('reviewProductId')?.value || 
                                        document.querySelector('.product-title-large')?.dataset.productId;
                        if (productId) {
                            loadProductPage(productId);
                        }
                    }
                }
            });
            // At the very end of setupEventListeners(), add:
            //console.log('Event listeners setup complete');
            //console.log('Products count:', products.length);
            //console.log('Users count:', users.length);
            // In setupEventListeners() function, add these:
            document.getElementById('addProductBtn').addEventListener('click', showAddProductModal);
            document.getElementById('adminProductForm').addEventListener('submit', handleAdminProductSubmit);
            document.getElementById('adminProductImageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('adminSearch').addEventListener('input', handleAdminSearch);

            // Mobile menu
            document.getElementById('menuToggle').addEventListener('click', showMobileMenu);
            document.getElementById('mobileMenuClose').addEventListener('click', hideMobileMenu);
            
            // Mobile navigation
            document.querySelectorAll('.mobile-menu-link[data-page]').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const page = e.currentTarget.getAttribute('data-page');
                    navigateTo(page);
                    hideMobileMenu();
                    activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "page name " + page
                }
                sendActivityData(activityData);
                });
            });
            
            // Mobile buttons
            document.getElementById('mobileProfileBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showProfileModal();
                hideMobileMenu();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "mobileProfileBtn"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('mobileWishlistBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showWishlistModal();
                hideMobileMenu();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "mobileWishlistBtn"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('mobileCartBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showCartModal();
                hideMobileMenu();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "mobileCartBtn"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('mobileContactBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showContactModal();
                hideMobileMenu();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "mobileContactBtn"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('mobileLiveChatBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showChatModal();
                hideMobileMenu();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "mobileLiveChatBtn"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('mobileSuggestionsBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showSuggestionsModal();
                hideMobileMenu();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "mobileSuggestionsBtn"
                }
                sendActivityData(activityData);
            });
            
            // Category filters
            document.querySelectorAll('.mobile-menu-link[data-category]').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const category = e.currentTarget.getAttribute('data-category');
                    navigateTo('store');
                    filterProductsByCategory(category);
                    hideMobileMenu();
                    activityData = {
                        productId: " " || "",
                        productName: " " || "",
                        activity: "clicked on category " + category
                    }
                    sendActivityData(activityData);
                });
            });
            
            // Close modals
            document.getElementById('closeProfileModal').addEventListener('click', () => hideModal('profileModal'));
            document.getElementById('closeCartModal').addEventListener('click', () => hideModal('cartModal'));
            document.getElementById('closeWishlistModal').addEventListener('click', () => hideModal('wishlistModal'));
            document.getElementById('closeContactModal').addEventListener('click', () => hideModal('contactModal'));
            document.getElementById('closeChatModal').addEventListener('click', () => hideModal('chatModal'));
            document.getElementById('closeOrderModal').addEventListener('click', () => hideModal('orderModal'));
            document.getElementById('closeSuggestionsModal').addEventListener('click', () => hideModal('suggestionsModal'));
            document.getElementById('closeAdminProductModal').addEventListener('click', () => hideModal('adminProductModal'));
            document.getElementById('closeZoomModal').addEventListener('click', () => hideModal('zoomModal'));
            document.getElementById('closeGalleryModal').addEventListener('click', () => hideModal('galleryModal'));
            
            // Modal overlays
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        hideModal(modal.id);
                    }
                });
            });
            
            // Profile tabs
            document.querySelectorAll('.profile-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const tabId = e.currentTarget.getAttribute('data-tab');
                    switchProfileTab(tabId);
                        activityData = {
                        productId: " " || "",
                        productName: " " || "",
                        activity: "profile-tab"
                    }
                    sendActivityData(activityData);
                });
            });
            
            // Login form
            document.getElementById('loginForm').addEventListener('submit', handleLogin);
            document.getElementById('loginCancelBtn').addEventListener('click', () => hideModal('profileModal'));
            
            // Register form
            document.getElementById('registerForm').addEventListener('submit', handleRegister);
            document.getElementById('registerCancelBtn').addEventListener('click', () => hideModal('profileModal'));
            
            // Logout
            document.getElementById('logoutBtn').addEventListener('click', handleLogout);
            document.getElementById('closeProfileBtn').addEventListener('click', () => hideModal('profileModal'));
            document.getElementById('editProfileBtn').addEventListener('click', showEditProfile);
            
            // Checkout
            document.getElementById('checkoutBtn').addEventListener('click', showOrderModal);
            
            // Order form
            document.getElementById('orderForm').addEventListener('submit', handleOrderSubmit);
            document.getElementById('cancelOrderBtn').addEventListener('click', () => hideModal('orderModal'));
            
            // Payment methods
            document.querySelectorAll('.payment-method').forEach(method => {
                method.addEventListener('click', () => {
                    document.querySelectorAll('.payment-method').forEach(m => m.classList.remove('active'));
                    method.classList.add('active');
                    
                    const paymentType = method.getAttribute('data-method');
                    const paymentDetails = document.getElementById('paymentDetails');
                    if (paymentType !== 'cod') {
                        paymentDetails.style.display = 'block';
                    } else {
                        paymentDetails.style.display = 'none';
                    }
                });
            });
            
            // Contact buttons
            document.getElementById('floatingChatBtn').addEventListener('click', showChatModal);
            document.getElementById('floatingContactBtn').addEventListener('click', showContactModal);
            document.getElementById('footerContactBtn').addEventListener('click', (e) => {
                e.preventDefault();
                showContactModal();
            });
            
           // Live chat
            document.getElementById('liveChatBtn').addEventListener('click', showChatModal);
            document.getElementById('sendChatBtn').addEventListener('click', sendChatMessage);

            // Chat input - Enter key to send
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendChatMessage();
                }
            });

            // Emoji button (if you added it in HTML)
            const emojiBtn = document.getElementById('emojiBtn');
            if (emojiBtn) {
                emojiBtn.addEventListener('click', () => {
                    showToast('Emoji picker coming soon!', 'info');
                });
            }

            // Attach button (if you added it in HTML)
            const attachBtn = document.getElementById('attachBtn');
            if (attachBtn) {
                attachBtn.addEventListener('click', () => {
                    showToast('File attachment coming soon!', 'info');
                });
            }
            
            // Back to top
            document.getElementById('floatingBackBtn').addEventListener('click', scrollToTop);
            
            // Store controls
            document.getElementById('sortSelect').addEventListener('change', handleSortChange);
            document.getElementById('filterSelect').addEventListener('change', handleFilterChange);
            document.getElementById('priceSelect').addEventListener('change', handleFilterChange);
            
            // View all buttons
            document.getElementById('viewTrending').addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo('store');
                filterProductsByCategory('all');
                document.getElementById('sortSelect').value = 'popular';
                handleSortChange();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "viewTrending"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('viewDiscounted').addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo('store');
                filterProductsByCategory('all');
                document.getElementById('sortSelect').value = 'discount';
                handleSortChange();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "viewDiscounted"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('viewTopRated').addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo('store');
                filterProductsByCategory('all');
                document.getElementById('sortSelect').value = 'rating';
                handleSortChange();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "view Top Rated"
                }
                sendActivityData(activityData);
            });
            
            document.getElementById('viewMostSold').addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo('store');
                filterProductsByCategory('all');
                document.getElementById('sortSelect').value = 'popular';
                handleSortChange();
                activityData = {
                    productId: " " || "",
                    productName: " " || "",
                    activity: "view Most Sold"
                }
                sendActivityData(activityData);
            });
            
            // Window events
            window.addEventListener('scroll', handleScroll);
            window.addEventListener('beforeunload', handleBeforeUnload);
            
            // Admin access
            // In setupEventListeners() function, update the admin access:
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'F') {
                    e.preventDefault();
                    
                    if (currentUser && currentUser.isAdmin) {
                        navigateTo('admin');
                    } else {
                        showToast('Admin access required. Please login as admin first.', 'error');
                        showProfileModal();
                    }
                }
            });
            
            // Admin product management
            document.getElementById('addProductBtn').addEventListener('click', showAddProductModal);
            document.getElementById('adminProductCancel').addEventListener('click', () => hideModal('adminProductModal'));
            document.getElementById('adminProductForm').addEventListener('submit', handleAdminProductSubmit);
            document.getElementById('adminProductImageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('adminSearch').addEventListener('input', handleAdminSearch);
            
            // ===== ADMIN PRODUCT MANAGEMENT =====
            function showAddProductModal() {
                document.getElementById('adminProductModalTitle').textContent = 'Add New Product';
                document.getElementById('adminProductForm').reset();
                document.getElementById('adminProductImages').innerHTML = '';
                document.getElementById('adminProductSubmit').textContent = 'Save Product';
                document.getElementById('adminProductSubmit').dataset.action = 'add';
                showModal('adminProductModal');
            }

            function handleAdminProductSubmit(e) {
                e.preventDefault();
                
                const action = e.submitter.dataset.action;
                const productId = action === 'edit' ? parseInt(e.submitter.dataset.productId) : Date.now();
                
                // Validate required fields
                const productName = document.getElementById('adminProductName').value.trim();
                const productCategory = document.getElementById('adminProductCategory').value;
                const productDescription = document.getElementById('adminProductDescription').value.trim();
                const productPrice = parseFloat(document.getElementById('adminProductPrice').value);
                const productStock = parseInt(document.getElementById('adminProductStock').value);
                
                if (!productName || !productCategory || !productDescription || isNaN(productPrice) || isNaN(productStock)) {
                    showToast('Please fill in all required fields correctly', 'error');
                    return;
                }
                
                // Get images
                const productImages = Array.from(document.querySelectorAll('#adminProductImages img')).map(img => img.src);
                if (productImages.length === 0) {
                    // Add a placeholder image if none uploaded
                    productImages.push('https://images.unsplash.com/photo-1505740420928-5e560c06d30e?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80');
                }
                
                // Get other fields
                const originalPrice = document.getElementById('adminProductOriginalPrice').value ? 
                    parseFloat(document.getElementById('adminProductOriginalPrice').value) : undefined;
                
                let productSpecs = {};
                try {
                    const specsText = document.getElementById('adminProductSpecs').value.trim();
                    productSpecs = specsText ? JSON.parse(specsText) : {};
                } catch (error) {
                    showToast('Invalid JSON in specifications. Please use valid JSON format.', 'error');
                    return;
                }
                
                const tags = document.getElementById('adminProductTags').value.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                const productData = {
                    id: productId,
                    name: productName,
                    category: productCategory,
                    description: productDescription,
                    price: productPrice,
                    originalPrice: originalPrice,
                    stock: productStock,
                    images: productImages,
                    rating: 4.0, // Default rating
                    ratingCount: 0,
                    specifications: productSpecs,
                    tags: tags,
                    weight: productSpecs.weight || 500, // Default weight or from specs
                    trending: false,
                    topRated: false,
                    mostSold: false,
                    discounted: !!originalPrice,
                    sellerId: 1,
                    createdAt: action === 'edit' ? products.find(p => p.id === productId)?.createdAt : new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    metadata: {
                        views: 0,
                        clicks: 0,
                        wishlistAdds: 0,
                        cartAdds: 0,
                        purchases: 0,
                        totalViewTime: 0
                    }
                };
                
                if (action === 'edit') {
                    const index = products.findIndex(p => p.id === productId);
                    if (index !== -1) {
                        products[index] = { ...products[index], ...productData };
                        showToast('Product updated successfully', 'success');
                    }
                } else {
                    products.push(productData);
                    // Add to interactions tracking
                    interactions.push({
                        productId: productId,
                        views: 0,
                        clicks: 0,
                        wishlistAdds: 0,
                        cartAdds: 0,
                        purchases: 0,
                        totalViewTime: 0,
                        avgViewTime: 0,
                        conversionRate: 0,
                        lastUpdated: new Date().toISOString()
                    });
                    showToast('Product added successfully', 'success');
                }
                
                saveToLocalStorage();
                hideModal('adminProductModal');
                
                // Refresh admin panel if currently viewing it
                if (currentPage === 'admin') {
                    loadAdminPanel();
                }
            }
            function toggleClearSearchButton(visible) {
                const clearBtn = document.getElementById('clearSearchBtn');
                if (clearBtn) {
                    clearBtn.style.display = visible ? 'inline-flex' : 'none';
                }
            }
            function handleAdminSearch(e) {
                const query = e.target.value.toLowerCase().trim();
                toggleClearSearchButton(query.length > 0);
                
                if (!query) {
                    // Reset to show all data
                    loadProductAnalytics();
                    loadUserAnalytics();
                    return;
                }
                
                // Search in products
                const filteredProducts = products.filter(product => 
                    product.name.toLowerCase().includes(query) ||
                    product.category.toLowerCase().includes(query) ||
                    product.description.toLowerCase().includes(query) ||
                    product.tags?.some(tag => tag.toLowerCase().includes(query))
                );
                
                // Update product analytics table with filtered products
                const tableBody = document.getElementById('productAnalyticsBody');
                tableBody.innerHTML = '';
                
                filteredProducts.forEach(product => {
                    const interaction = interactions.find(i => i.productId === product.id);
                    if (!interaction) return;
                    
                    const viewTime = formatTime(interaction.avgViewTime);
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <img src="${product.images[0]}" alt="${product.name}" style="width: 40px; height: 40px; border-radius: var(--radius-sm); object-fit: cover;">
                                <div>
                                    <div style="font-weight: 600;">${product.name}</div>
                                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${product.category}</div>
                                </div>
                            </div>
                        </td>
                        <td>${interaction.views.toLocaleString()}</td>
                        <td>${interaction.clicks.toLocaleString()}</td>
                        <td>${interaction.wishlistAdds.toLocaleString()}</td>
                        <td>${interaction.cartAdds.toLocaleString()}</td>
                        <td>${interaction.purchases.toLocaleString()}</td>
                        <td>${viewTime}</td>
                        <td>
                            <div class="admin-badge ${interaction.conversionRate > 5 ? 'badge-success' : interaction.conversionRate > 2 ? 'badge-warning' : 'badge-error'}">
                                ${interaction.conversionRate}%
                            </div>
                        </td>
                        <td>
                            <div class="admin-actions">
                                <button class="admin-action-btn" title="Edit" onclick="editProduct(${product.id})">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="admin-action-btn delete" title="Delete" onclick="deleteProduct(${product.id})">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </td>
                    `;
                    tableBody.appendChild(row);
                });
                
                // Search in users
                const filteredUsers = users.filter(user => 
                    user.name.toLowerCase().includes(query) ||
                    user.email.toLowerCase().includes(query) ||
                    user.phone?.toLowerCase().includes(query) ||
                    user.address?.toLowerCase().includes(query)
                );
                
                // Update user analytics table with filtered users
                const userTableBody = document.getElementById('userAnalyticsBody');
                userTableBody.innerHTML = '';
                
                filteredUsers.forEach(user => {
                    const userOrders = orders.filter(o => o.userId === user.id);
                    const totalSpent = userOrders.reduce((sum, order) => sum + order.total, 0);
                    const avgOrderValue = userOrders.length > 0 ? totalSpent / userOrders.length : 0;
                    const lastActivity = user.activityStats?.lastActivity ? 
                        formatTimeAgo(new Date(user.activityStats.lastActivity)) : 'Never';
                    const sessionTime = formatTime(user.activityStats?.totalTimeSpent || 0);
                    const viewedProducts = user.preferences?.viewedProducts?.length || 0;
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <div style="width: 40px; height: 40px; border-radius: 50%; background: var(--gradient-primary); display: flex; align-items: center; justify-content: center; color: var(--text-white); font-weight: 600;">
                                    ${user.name.charAt(0)}
                                </div>
                                <div>
                                    <div style="font-weight: 600;">${user.name}</div>
                                    <div style="font-size: 0.75rem; color: var(--text-secondary);">${user.email}</div>
                                </div>
                            </div>
                        </td>
                        <td>${userOrders.length}</td>
                        <td><b><strong>৳</strong></b>${totalSpent.toFixed(2)}</td>
                        <td><b><strong>৳</strong></b>${avgOrderValue.toFixed(2)}</td>
                        <td>${lastActivity}</td>
                        <td>${sessionTime}</td>
                        <td>${viewedProducts}</td>
                        <td>
                            <div class="admin-badge ${user.isAdmin ? 'badge-info' : 'badge-success'}">
                                ${user.isAdmin ? 'Admin' : 'User'}
                            </div>
                        </td>
                        <td>
                            <div class="admin-actions">
                                <button class="admin-action-btn" title="View Details" onclick="viewUserDetails(${user.id})">
                                    <i class="fas fa-eye"></i>
                                </button>
                                ${!user.isAdmin ? `
                                    <button class="admin-action-btn delete" title="Delete User" onclick="deleteUser(${user.id})">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                ` : ''}
                            </div>
                        </td>
                    `;
                    userTableBody.appendChild(row);
                });
                // Add event listener for clear button
                document.getElementById('clearSearchBtn')?.addEventListener('click', () => {
                    document.getElementById('adminSearch').value = '';
                    toggleClearSearchButton(false);
                    handleAdminSearch({ target: { value: '' } });
                });
            }

            function viewUserDetails(userId) {
                const user = users.find(u => u.id === userId);
                if (!user) return;
                
                const userOrders = orders.filter(o => o.userId === user.id);
                const userWishlist = wishlist.filter(item => item.userId === user.id);
                const userReviews = reviews.filter(r => r.userId === user.id);
                
                const modalContent = `
                    <div class="admin-form-group">
                        <h3 style="margin-bottom: 1rem;">User Details</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                            <div>
                                <strong>Name:</strong><br>${user.name}
                            </div>
                            <div>
                                <strong>Email:</strong><br>${user.email}
                            </div>
                            <div>
                                <strong>Phone:</strong><br>${user.phone || 'Not provided'}
                            </div>
                            <div>
                                <strong>Address:</strong><br>${user.address || 'Not provided'}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin-bottom: 0.5rem;">Statistics</h4>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                                <div style="padding: 0.75rem; background: var(--surface-color); border-radius: var(--radius); min-width: 120px;">
                                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">${userOrders.length}</div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Orders</div>
                                </div>
                                <div style="padding: 0.75rem; background: var(--surface-color); border-radius: var(--radius); min-width: 120px;">
                                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">${userWishlist.length}</div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Wishlist Items</div>
                                </div>
                                <div style="padding: 0.75rem; background: var(--surface-color); border-radius: var(--radius); min-width: 120px;">
                                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">${userReviews.length}</div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Reviews</div>
                                </div>
                                <div style="padding: 0.75rem; background: var(--surface-color); border-radius: var(--radius); min-width: 120px;">
                                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">${user.totalSpent ? `<b><strong>৳</strong></b>${user.totalSpent.toFixed(2)}` : '<b><strong>৳</strong></b>0'}</div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Spent</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create or update a modal for user details
                if (!document.getElementById('userDetailsModal')) {
                    const modalHTML = `
                        <div class="modal-overlay" id="userDetailsModal">
                            <div class="modal" style="max-width: 800px;">
                                <div class="modal-header">
                                    <h2 class="modal-title">User Details</h2>
                                    <button class="modal-close" onclick="hideModal('userDetailsModal')">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                                <div class="modal-body" id="userDetailsContent">
                                    ${modalContent}
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                } else {
                    document.getElementById('userDetailsContent').innerHTML = modalContent;
                }
                
                showModal('userDetailsModal');
            }

            function deleteUser(userId) {
                if (userId === currentUser?.id) {
                    showToast('You cannot delete your own account', 'error');
                    return;
                }
                
                const user = users.find(u => u.id === userId);
                if (!user) return;
                
                if (confirm(`Are you sure you want to delete user "${user.name}"? All their data will be removed.`)) {
                    // Remove user
                    users = users.filter(u => u.id !== userId);
                    
                    // Remove user's orders
                    orders = orders.filter(o => o.userId !== userId);
                    
                    // Remove user's wishlist items
                    wishlist = wishlist.filter(item => item.userId !== userId);
                    
                    // Remove user's reviews
                    reviews = reviews.filter(r => r.userId !== userId);
                    
                    // Remove user's activities
                    activities = activities.filter(a => a.userId !== userId);
                    
                    saveToLocalStorage();
                    showToast(`User "${user.name}" deleted successfully`, 'success');
                    
                    // Refresh admin panel
                    if (currentPage === 'admin') {
                        loadAdminPanel();
                    }
                }
            }
            function handleImageUpload(e) {
                const files = e.target.files;
                const imagesContainer = document.getElementById('adminProductImages');
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    
                    reader.onload = function(event) {
                        const imageElement = document.createElement('div');
                        imageElement.className = 'admin-form-image';
                        imageElement.innerHTML = `
                            <img src="${event.target.result}" alt="Uploaded Image">
                            <button type="button" class="admin-form-image-remove">
                                <i class="fas fa-times"></i>
                            </button>
                        `;
                        
                        imageElement.querySelector('.admin-form-image-remove').addEventListener('click', () => {
                            imageElement.remove();
                        });
                        
                        imagesContainer.appendChild(imageElement);
                    };
                    
                    reader.readAsDataURL(file);
                }
                
                e.target.value = '';
            }

            function editProduct(productId) {
                const product = products.find(p => p.id === productId);
                if (!product) return;
                
                document.getElementById('adminProductModalTitle').textContent = 'Edit Product';
                document.getElementById('adminProductName').value = product.name;
                document.getElementById('adminProductCategory').value = product.category;
                document.getElementById('adminProductDescription').value = product.description;
                document.getElementById('adminProductPrice').value = product.price;
                document.getElementById('adminProductOriginalPrice').value = product.originalPrice || '';
                document.getElementById('adminProductStock').value = product.stock;
                document.getElementById('adminProductTags').value = product.tags?.join(', ') || '';
                document.getElementById('adminProductSpecs').value = JSON.stringify(product.specifications || {}, null, 2);
                
                // Load images
                const imagesContainer = document.getElementById('adminProductImages');
                imagesContainer.innerHTML = '';
                product.images.forEach((img, index) => {
                    const imageElement = document.createElement('div');
                    imageElement.className = 'admin-form-image';
                    imageElement.innerHTML = `
                        <img src="${img}" alt="Product Image ${index + 1}">
                        <button type="button" class="admin-form-image-remove" data-index="${index}">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    imagesContainer.appendChild(imageElement);
                });
                
                document.getElementById('adminProductSubmit').textContent = 'Update Product';
                document.getElementById('adminProductSubmit').dataset.action = 'edit';
                document.getElementById('adminProductSubmit').dataset.productId = productId;
                
                showModal('adminProductModal');
            }

            function deleteProduct(productId) {
                const product = products.find(p => p.id === productId);
                if (!product) {
                    showToast('Product not found', 'error');
                    return;
                }
                
                if (!confirm(`Are you sure you want to delete "${product.name}"?\n\nThis will also remove it from:\n• User wishlists\n• Shopping carts\n• User reviews\n• Order history\n\nThis action cannot be undone!`)) {
                    return;
                }
                
                try {
                    // Remove product from products array
                    const productIndex = products.findIndex(p => p.id === productId);
                    if (productIndex > -1) {
                        products.splice(productIndex, 1);
                    }
                    
                    // Remove from interactions
                    interactions = interactions.filter(i => i.productId !== productId);
                    
                    // Remove from wishlists
                    wishlist = wishlist.filter(item => item.productId !== productId);
                    
                    // Remove from cart
                    cart = cart.filter(item => item.productId !== productId);
                    
                    // Remove reviews for this product
                    reviews = reviews.filter(r => r.productId !== productId);
                    
                    // Remove from orders (replace with placeholder)
                    orders.forEach(order => {
                        if (order.items) {
                            order.items = order.items.filter(item => item.productId !== productId);
                        }
                    });
                    
                    // Remove from activities
                    activities = activities.filter(a => a.productId !== productId);
                    
                    // Remove from user preferences
                    users.forEach(user => {
                        if (user.preferences?.viewedProducts) {
                            user.preferences.viewedProducts = user.preferences.viewedProducts.filter(id => id !== productId);
                        }
                        if (user.preferences?.likedProducts) {
                            user.preferences.likedProducts = user.preferences.likedProducts.filter(id => id !== productId);
                        }
                        if (user.viewingStats && user.viewingStats[productId]) {
                            delete user.viewingStats[productId];
                        }
                    });
                    
                    // Clear suggestions cache
                    window.relatedProductsCache = {};
                    window.userSuggestionsCache = {};
                    
                    saveToLocalStorage();
                    showToast(`Product "${product.name}" deleted successfully`, 'success');
                    
                    // Refresh current view
                    if (currentPage === 'admin') {
                        loadAdminPanel();
                    } else if (currentPage === 'home') {
                        loadHomePage();
                    } else if (currentPage === 'store') {
                        loadStorePage();
                    } else if (currentPage === 'product') {
                        // If viewing the deleted product, redirect to store
                        const currentProductId = document.querySelector('.product-title-large')?.dataset.productId;
                        if (currentProductId == productId) {
                            showToast('This product is no longer available', 'info');
                            navigateTo('store');
                        }
                    }
                } catch (error) {
                    console.error('Error deleting product:', error);
                    showToast('Error deleting product', 'error');
                }
            }

            // Improved editProduct function
            function editProduct(productId) {
                const product = products.find(p => p.id === productId);
                if (!product) {
                    showToast('Product not found', 'error');
                    return;
                }
                
                // Show loading state
                showToast('Loading product data...', 'info');
                
                // Populate form with product data
                document.getElementById('adminProductModalTitle').textContent = 'Edit Product';
                
                // Clear existing form
                document.getElementById('adminProductForm').reset();
                document.getElementById('adminProductImages').innerHTML = '';
                
                // Set form values
                document.getElementById('adminProductName').value = product.name;
                document.getElementById('adminProductCategory').value = product.category;
                document.getElementById('adminProductDescription').value = product.description;
                document.getElementById('adminProductPrice').value = product.price;
                document.getElementById('adminProductOriginalPrice').value = product.originalPrice || '';
                document.getElementById('adminProductStock').value = product.stock;
                document.getElementById('adminProductTags').value = product.tags?.join(', ') || '';
                
                // Format specifications for display
                const specsText = product.specifications ? 
                    JSON.stringify(product.specifications, null, 2) : '{}';
                document.getElementById('adminProductSpecs').value = specsText;
                
                // Load images
                const imagesContainer = document.getElementById('adminProductImages');
                product.images.forEach((img, index) => {
                    const imageElement = document.createElement('div');
                    imageElement.className = 'admin-form-image';
                    imageElement.innerHTML = `
                        <img src="${img}" alt="Product Image ${index + 1}" 
                            onerror="this.src='https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80'">
                        <button type="button" class="admin-form-image-remove" 
                                onclick="removeProductImage(this, ${productId}, '${img}')">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    imagesContainer.appendChild(imageElement);
                });
                
                // Add image event listeners
                document.getElementById('adminProductImageUpload').onchange = handleImageUpload;
                
                // Set submit button for edit mode
                const submitBtn = document.getElementById('adminProductSubmit');
                submitBtn.textContent = 'Update Product';
                submitBtn.dataset.action = 'edit';
                submitBtn.dataset.productId = productId;
                
                showModal('adminProductModal');
                
                // Hide loading toast
                setTimeout(() => {
                    const toast = document.querySelector('.toast.info');
                    if (toast) toast.remove();
                }, 1000);
            }

            // New function to handle image removal
            function removeProductImage(button, productId, imageUrl) {
                if (!confirm('Remove this image from the product?')) return;
                
                const product = products.find(p => p.id === productId);
                if (!product) return;
                
                // Remove image from product
                const imageIndex = product.images.indexOf(imageUrl);
                if (imageIndex > -1) {
                    product.images.splice(imageIndex, 1);
                    
                    // If no images left, add a placeholder
                    if (product.images.length === 0) {
                        product.images.push('https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80');
                    }
                    
                    saveToLocalStorage();
                    showToast('Image removed', 'success');
                    
                    // Update the UI
                    button.parentElement.remove();
                    
                    // Refresh if viewing this product
                    if (currentPage === 'product') {
                        const currentProductId = document.querySelector('.product-title-large')?.dataset.productId;
                        if (currentProductId == productId) {
                            loadProductPage(productId);
                        }
                    }
                }
            }
        }
        // ===== NAVIGATION FUNCTIONS =====
        function navigateTo(page) {
            // Stop tracking current product view time
            Object.keys(nanoTimeTracker).forEach(productId => {
                const viewTime = performance.now() - nanoTimeTracker[productId];
                trackInteraction(productId, 'viewTime', Math.round(viewTime));
                trackActivity('product_view_end', productId, Math.round(viewTime));
                delete nanoTimeTracker[productId];
            });
            
            // Hide all pages
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            
            // Show selected page
            const pageElement = document.getElementById(page + 'Page');
            if (pageElement) {
                pageElement.classList.add('active');
                currentPage = page;
                
                // Update URL
                history.pushState({ page }, '', `?page=${page}`);
                
                // Load page content
                switch(page) {
                    case 'home':
                        loadHomePage();
                        break;
                    case 'store':
                        loadStorePage();
                        break;
                    case 'admin':
                        if (!currentUser?.isAdmin) {
                            showToast('Admin access required', 'error');
                            navigateTo('home');
                            return;
                        }
                        loadAdminPanel();
                        break;
                }
                
                // Update back button
                updateBackButton();
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function loadHomePage() {
            //console.log('Loading home page...');
            
            // Make sure containers exist
            const trendingContainer = document.getElementById('trendingProducts');
            const categoriesContainer = document.getElementById('categoriesGrid');
            
            if (!trendingContainer || !categoriesContainer) {
                console.error('Required containers not found!');
                return;
            }
            
            // Load categories
            renderCategories();
            loadProductData().then(data => {
                products = data;

            // Load trending products
            const trending = products.filter(p => p.trending).slice(0, 12);
            renderProducts(trending, 'trendingProducts');
            
            // Load discounted products
            const discounted = products.filter(p => p.discounted && p.originalPrice).slice(0, 12);
            renderProducts(discounted, 'discountedProducts');
            
            // Load top rated products
            const topRated = products.filter(p => p.topRated).slice(0, 12);
            renderProducts(topRated, 'topRatedProducts');
            
            // Load most sold products
            const mostSold = products.filter(p => p.mostSold).slice(0, 12);
            renderProducts(mostSold, 'mostSoldProducts');
            });
            //console.log('Home page loaded');
        }
        function renderCategories() {
            const totalCategories = {};

            loadProductData().then(data => {
                products = data;

                products.forEach(product => {
                    if (totalCategories.hasOwnProperty(product.category)) {
                        totalCategories[product.category]++;
                    } else {
                        totalCategories[product.category] = 1;
                    }
                });

            //console.log(totalCategories);


            loadCategoryData().then(data => {
                categories = data;
                
            const container = document.getElementById('categoriesGrid');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Direct Unsplash URLs that are guaranteed to work
            const categoryImages = {};
            
            categories.forEach(category => {
                categoryImages[category.slug] = category.image;
                const categoryElement = document.createElement('div');
                categoryElement.className = 'category-card';
                categoryElement.dataset.category = category.slug;
                
                // Get the image URL for this category
                const imageUrl = categoryImages[category.slug] || categoryImages.default;
                
                // Create image element separately so we can attach events properly
                const imgElement = document.createElement('img');
                imgElement.className = 'category-image';
                imgElement.alt = category.name;
                imgElement.loading = 'lazy';
                
                // Create overlay content
                const overlayDiv = document.createElement('div');
                overlayDiv.className = 'category-overlay';
                overlayDiv.innerHTML = `
                    <h3 class="category-title">${category.name}</h3>
                    <p class="category-count">${totalCategories[category.slug]} products</p>
                `;
                
                // Append elements
                categoryElement.appendChild(imgElement);
                categoryElement.appendChild(overlayDiv);
                
                // Function to handle image loading with retry logic
                const loadImage = (url, retryCount = 0) => {
                    imgElement.src = url;
                    
                    // Add error handler
                    imgElement.onerror = function() {
                        if (retryCount === 0) {
                            // First fallback: Try a generic Unsplash search for the category
                            const fallbackUrl = `https://source.unsplash.com/featured/800x600/?${encodeURIComponent(category.slug)},${encodeURIComponent(category.name)}`;
                            loadImage(fallbackUrl, 1);
                        } else if (retryCount === 1) {
                            // Second fallback: Try a different generic image
                            const genericUrl = `https://source.unsplash.com/featured/800x600/?shopping,store,${encodeURIComponent(category.name)}`;
                            loadImage(genericUrl, 2);
                        } else {
                            // Final fallback: Use a default placeholder
                            imgElement.src = 'https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&q=80';
                            imgElement.onerror = null; // Remove error handler
                        }
                    };
                    
                    // Add load handler to remove error listener on success
                    imgElement.onload = function() {
                        imgElement.onerror = null;
                    };
                };
                
                // Start loading the image
                loadImage(imageUrl);
                
                // Add click event
                categoryElement.addEventListener('click', () => {
                    navigateTo('store');
                    filterProductsByCategory(category.slug);
                    activityData = {
                        productId: category.slug || "",
                        productName: category.slug || "",
                        activity: "clicked on category"
                    }
                    sendActivityData(activityData);
                });
                
                container.appendChild(categoryElement);
            });
            });
            });
        }

        function renderProducts(productsArray, containerId, isSeller = false) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            if (productsArray.length === 0) {
                container.innerHTML = `
                    <div class="text-center" style="grid-column: 1/-1; padding: 3rem; color: var(--text-secondary)">
                        <i class="fas fa-box-open" style="font-size: 4rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3 style="margin-bottom: 0.5rem;">No products found</h3>
                        <p>Try adjusting your search or filter criteria</p>
                    </div>
                `;
                return;
            }
            
            // Check if this is for suggestions modal
            const isSuggestionsModal = containerId === 'suggestionsProducts';
            
            productsArray.forEach(product => {
                const productElement = isSuggestionsModal ? 
                    createSuggestionProductElement(product, isSeller) : 
                    createProductElement(product, isSeller);
                container.appendChild(productElement);
            });
            
            // Re-setup intersection observer for new products
            if (!isSuggestionsModal) {
                setTimeout(() => {
                    setupIntersectionObserver();
                }, 100);
            }
        }
        function createSuggestionProductElement(product, isSeller = false) {
            const discount = product.originalPrice ? 
                Math.round(((product.originalPrice - product.price) / product.originalPrice) * 100) : 0;
            
            const isInWishlist = wishlist.some(item => item.productId === product.id);
            const cartItem = cart.find(item => item.productId === product.id);
            const isInCart = !!cartItem;
            
            // Determine badges (show only sale badge in suggestions)
            const badges = [];
            if (discount >= 20) badges.push({ type: 'sale', text: `-${discount}%` });
            
            const element = document.createElement('div');
            element.className = 'product-card';
            element.dataset.productId = product.id;
            
            element.innerHTML = `
                <div class="product-image-container">
                    <img src="${product.images[0]}" alt="${product.name}" class="product-image">
                    
                    ${badges.length > 0 ? `
                        <div class="product-badges">
                            ${badges.map(badge => `
                                <div class="product-badge badge-${badge.type}">${badge.text}</div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div class="product-actions">
                        <button class="product-action-btn ${isInWishlist ? 'active' : ''}" data-action="wishlist" title="${isInWishlist ? 'Remove from wishlist' : 'Add to wishlist'}">
                            <i class="fas fa-heart"></i>
                        </button>
                        <button class="product-action-btn" data-action="quickview" title="Quick view">
                            <i class="fas fa-eye"></i>
                        </button>
                        <button class="product-action-btn ${isInCart ? 'active' : ''}" data-action="cart" title="${isInCart ? 'In cart' : 'Add to cart'}">
                            <i class="fas fa-shopping-cart"></i>
                        </button>
                    </div>
                </div>
                <div class="product-info">
                    <h3 class="product-title">${product.name}</h3>
                    <div class="product-price">
                        <span class="current-price"><b><strong>৳</strong></b>${product.price.toFixed(2)}</span>
                        ${product.originalPrice ? `
                            <span class="original-price" style="font-size: 0.75rem;"><b><strong>৳</strong></b>${product.originalPrice.toFixed(2)}</span>
                        ` : ''}
                    </div>
                    <div class="product-rating">
                        <div class="rating-stars">
                            ${getStarsHTML(product.rating)}
                        </div>
                        <span class="rating-count">(${product.ratingCount})</span>
                    </div>
                </div>
            `;
            
            // Add event listeners
            const image = element.querySelector('.product-image');
            const wishlistBtn = element.querySelector('[data-action="wishlist"]');
            const quickviewBtn = element.querySelector('[data-action="quickview"]');
            const cartBtn = element.querySelector('[data-action="cart"]');
            
            const isMobileDevice = window.matchMedia('(max-width: 768px)').matches || window.matchMedia('(hover: none)').matches;

            const toggleCardActions = () => {
                document.querySelectorAll('.product-card.active-actions').forEach(card => {
                    if (card !== element) card.classList.remove('active-actions');
                });
                element.classList.toggle('active-actions');
            };

            image.addEventListener('click', (e) => {
                if (isMobileDevice) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleCardActions();
                    return;
                }
                viewProduct(product.id);
                activityData = {
                    productId: product.id || "",
                    productName: product.name || "",
                    activity: "image clicked from suggestions"
                }
                sendActivityData(activityData);
            });
            element.querySelector('.product-title').addEventListener('click', (e) => {
                e.stopPropagation();
                viewProduct(product.id);
                activityData = {
                    productId: product.id || "",
                    productName: product.name || "",
                    activity: "title clicked from suggestions"
                }
                sendActivityData(activityData);
            });
            
            wishlistBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleWishlist(product.id);
                updateWishlistButton(wishlistBtn, product.id);
                activityData = {
                    productId: product.id || "",
                    productName: product.name || "",
                    activity: "wishlisted from suggestions"
                }
                sendActivityData(activityData);
    });
            
            quickviewBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                viewProduct(product.id);
                activityData = {
                    productId: product.id || "",
                    productName: product.name || "",
                    activity: "product view from suggestions"
                }
                sendActivityData(activityData);
            });
            
            cartBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isInCart) {
                    showCartModal();
                } else {
                    addToCart(product.id);
                    updateCartButton(cartBtn, product.id);
                    showToast('Added to cart!', 'success');
                    activityData = {
                            productId: product.id || "",
                            productName: product.name || "",
                            activity: "added to cart from suggestions"
                        }
                        sendActivityData(activityData);
                }
            });
            
            return element;
        }
        function createProductElement(product, isSeller = false) {
            const discount = product.originalPrice ? 
                Math.round(((product.originalPrice - product.price) / product.originalPrice) * 100) : 0;
            
            const isInWishlist = wishlist.some(item => item.productId === product.id);
            const cartItem = cart.find(item => item.productId === product.id);
            const isInCart = !!cartItem;
            
            const element = document.createElement('div');
            element.className = 'product-card';
            element.dataset.productId = product.id;
            
            // Determine badges
            const badges = [];
            //if (product.trending) badges.push({ type: 'hot', text: 'Trending' });
            if (discount >= 20) badges.push({ type: 'sale', text: `` });
            if (product.stock < 10) badges.push({ type: 'warning', text: 'Low Stock' });
            if (product.stock === 0) badges.push({ type: 'error', text: 'Out of Stock' });
            
            element.innerHTML = `
                <div class="product-image-container">
                    <img src="${product.images[0]}" alt="${product.name}" class="product-image">
                    
                    <div class="product-badges">
                        ${badges.map(badge => `
                            <div class="product-badge badge-${badge.type}">${badge.text}</div>
                        `).join('')}
                    </div>
                    
                    <div class="product-actions">
                        <button class="product-action-btn ${isInWishlist ? 'active' : ''}" data-action="wishlist" title="${isInWishlist ? 'Remove from wishlist' : 'Add to wishlist'}">
                            <i class="fas fa-heart"></i>
                        </button>
                        <button class="product-action-btn" data-action="quickview" title="Quick view">
                            <i class="fas fa-eye"></i>
                        </button>
                        <button class="product-action-btn ${isInCart ? 'active' : ''}" data-action="cart" title="${isInCart ? 'In cart' : 'Add to cart'}">
                            <i class="fas fa-shopping-cart"></i>
                        </button>
                    </div>
                </div>
                <div class="product-info">
                    <span class="product-category">${product.category.toUpperCase()}</span>
                    <h3 class="product-title">${product.name}</h3>
                    <div class="product-price">
                        <span class="current-price"><b><strong>৳</strong></b>${product.price.toFixed(2)}</span>
                        ${product.originalPrice ? `
                            <span class="original-price"><b><strong>৳</strong></b>${product.originalPrice.toFixed(2)}</span>
                            <span class="discount">-${discount}%</span>
                        ` : ''}
                    </div>
                    <div class="product-rating">
                        <div class="rating-stars">
                            ${getStarsHTML(product.rating)}
                        </div>
                        <span class="rating-count">(${product.ratingCount})</span>
                    </div>
                    <div class="product-meta">
                        <div class="product-stock">
                            <span class="stock-dot ${product.stock > 10 ? '' : product.stock === 0 ? 'out' : 'low'}"></span>
                            <span>${product.stock > 10 ? 'In Stock' : product.stock === 0 ? 'Out of Stock' : 'Low Stock'}</span>
                        </div>
                        <div class="product-weight">
                            ${product.weight < 1000 ? `${product.weight}g` : `${(product.weight/1000).toFixed(1)}kg`}
                        </div>
                    </div>
                </div>
            `;
            
            // Add event listeners
            const image = element.querySelector('.product-image');
            const wishlistBtn = element.querySelector('[data-action="wishlist"]');
            const quickviewBtn = element.querySelector('[data-action="quickview"]');
            const cartBtn = element.querySelector('[data-action="cart"]');
            
            const isMobileDevice = window.matchMedia('(max-width: 768px)').matches || window.matchMedia('(hover: none)').matches;

            const toggleCardActions = () => {
                document.querySelectorAll('.product-card.active-actions').forEach(card => {
                    if (card !== element) card.classList.remove('active-actions');
                });
                element.classList.toggle('active-actions');
            };

            image.addEventListener('click', (e) => {
                if (isMobileDevice) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleCardActions();
                    return;
                }
                viewProduct(product.id);
                activityData = {
                            productId: product.id || "",
                            productName: product.name || "",
                            activity: "product view from android"
                        }
                        sendActivityData(activityData);
            });
            
            wishlistBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleWishlist(product.id);
                updateWishlistButton(wishlistBtn, product.id);
                activityData = {
                            productId: product.id || "",
                            productName: product.name || "",
                            activity: "wishlisted"
                        }
                        sendActivityData(activityData);
            });
            
            quickviewBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                viewProduct(product.id);
                activityData = {
                            productId: product.id || "",
                            productName: product.name || "",
                            activity: "product view"
                        }
                        sendActivityData(activityData);
            });
            
            cartBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isInCart) {
                    showCartModal();
                } else {
                    addToCart(product.id);
                    updateCartButton(cartBtn, product.id);
                    showToast('Added to cart!', 'success');
                    activityData = {
                            productId: product.id || "",
                            productName: product.name || "",
                            activity: "added to cart"
                        }
                        sendActivityData(activityData);
                }
            });
            
            // Mobile: tap card to reveal action buttons (do not auto-open product)
            if (isMobileDevice) {
                element.addEventListener('click', (e) => {
                    if (e.target.closest('.product-action-btn')) return;
                    if (e.target.closest('.product-title')) return;
                    e.preventDefault();
                    toggleCardActions();
                }, { passive: false });
            }

return element;
        }

        function getStarsHTML(rating) {
            let stars = '';
            const fullStars = Math.floor(rating);
            const halfStar = rating % 1 >= 0.5;
            
            for (let i = 0; i < 5; i++) {
                if (i < fullStars) {
                    stars += '<i class="fas fa-star rating-star active"></i>';
                } else if (i === fullStars && halfStar) {
                    stars += '<i class="fas fa-star-half-alt rating-star active"></i>';
                } else {
                    stars += '<i class="far fa-star rating-star"></i>';
                }
            }
            
            return stars;
        }

        function viewProduct(productId) {
            // Track click
            trackInteraction(productId, 'click');
            trackActivity('product_click', productId);
            
            // Update URL
            history.pushState({}, '', `?page=product&product=${productId}`);
            
            // Load product
            loadProductPage(productId);
        }

        function loadProductPage(productId) {
            loadProductData().then(data => {
                products = data;
            
            const product = products.find(p => p.id == productId);
            if (!product) {
                showToast('Product not found', 'error');
                navigateTo('store');
                return;
            }
            
            // Hide other pages
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            
            // Show product page
            document.getElementById('productPage').classList.add('active');
            currentPage = 'product';
            
            // Start view timer
            if (!nanoTimeTracker[productId]) {
                nanoTimeTracker[productId] = performance.now();
            }
            
            // Load product details
            renderProductDetails(product);
            });
        }

        function renderProductDetails(product) {
            loadReviewData().then(data => {
                reviews = data;
                //console.log(reviews)

            const container = document.getElementById('productDetailsContainer');
            const discount = product.originalPrice ? 
                Math.round(((product.originalPrice - product.price) / product.originalPrice) * 100) : 0;
            
            const isInWishlist = wishlist.some(item => item.productId === product.id);
            const cartItem = cart.find(item => item.productId === product.id);
            const isInCart = !!cartItem;
            
            // Get product reviews
            const productReviews = reviews.filter(r => r.productId === product.id);
            const averageRating = productReviews.length > 0 ? 
                productReviews.reduce((sum, review) => sum + review.rating, 0) / productReviews.length : 
                product.rating;
            
            // Create thumbnails HTML
            const thumbnailsHTML = product.images.map((img, index) => `
                <img src="${img}" alt="${product.name} - View ${index + 1}" 
                     class="thumbnail ${index === 0 ? 'active' : ''}"
                     data-index="${index}"
                     onerror="this.src='${product.images[0]}'">
            `).join('');
            
            // Create specifications HTML
            const specsHTML = product.specifications ? 
                Object.entries(product.specifications).map(([key, value]) => `
                    <div class="spec-item">
                        <div class="spec-key">${key}</div>
                        <div class="spec-value">${value}</div>
                    </div>
                `).join('') : '';
            
            // Create reviews HTML
            const reviewsHTML = productReviews.slice(0, 5).map(review => {
                const user = users.find(u => u.id === review.userId);
                return `
                    <div class="review-card">
                        <div class="review-header">
                            <div class="review-user">
                                <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(user?.name || 'User')}&background=random" 
                                     alt="${user?.name || 'User'}" class="review-user-img">
                                <div class="review-user-info">
                                    <h4>${user?.name || 'User'}</h4>
                                    <div class="review-date">${formatDate(review.createdAt)}</div>
                                </div>
                            </div>
                            <div class="review-rating">
                                ${getStarsHTML(review.rating)}
                                <span>${review.rating.toFixed(1)}</span>
                            </div>
                        </div>
                        <div class="review-content">
                            <h5>${review.title}</h5>
                            <p>${review.comment}</p>
                        </div>
                        ${review.images && review.images.length > 0 ? `
                            <div class="review-images">
                                ${review.images.map(img => `
                                    <img src="${img}" alt="Review image" class="review-image">
                                `).join('')}
                            </div>
                        ` : ''}
                        <div class="review-helpful">
                            <button class="btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                <i class="fas fa-thumbs-up"></i> Helpful (${review.helpful})
                            </button>
                            <button class="btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                <i class="fas fa-thumbs-down"></i> (${review.notHelpful})
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = `
                <div class="product-gallery">
                    <div class="main-image-container">
                        <img src="${product.images[0]}" alt="${product.name}" class="main-product-image" id="mainProductImage">
                        <div class="zoom-overlay">
                            <i class="fas fa-search-plus"></i>
                            <span>Click to zoom</span>
                        </div>
                    </div>
                    <div class="thumbnail-container">
                        ${thumbnailsHTML}
                    </div>
                </div>
                <div class="product-info-details">
                    <div class="product-category-detail">${product.category.toUpperCase()}</div>
                    <h1 class="product-title-large">${product.name}</h1>
                    
                    <div class="product-rating-large">
                        <div class="rating-stars">
                            ${getStarsHTML(averageRating)}
                        </div>
                        <span class="rating-count">${product.ratingCount} ratings • ${productReviews.length} reviews</span>
                        <a href="#reviews" style="color: var(--info-color); font-size: 0.9375rem;">See all reviews</a>
                    </div>
                    
                    <div class="product-price-large">
                        <span class="current-price-large"><b><strong>৳</strong></b>${product.price.toFixed(2)}</span>
                        ${product.originalPrice ? `
                            <span class="original-price-large"><b><strong>৳</strong></b>${product.originalPrice.toFixed(2)}</span>
                            <span class="discount-large">-${discount}%</span>
                        ` : ''}
                    </div>
                    
                    <div class="product-description">
                        <h3 class="description-title">Description</h3>
                        <p class="description-content">${product.description}</p>
                    </div>
                    
                    <div class="product-actions-large">
                        <button class="action-btn-large buy-now-btn" id="buyNowBtn">
                            <i class="fas fa-bolt"></i> Buy Now
                        </button>
                        <button class="action-btn-large add-cart-btn ${isInCart ? 'active' : ''}" id="addToCartBtn">
                            <i class="fas fa-shopping-cart"></i> ${isInCart ? 'View Cart' : 'Add to Cart'}
                        </button>
                        <button class="action-btn-large wishlist-btn-large ${isInWishlist ? 'active' : ''}" id="wishlistBtnLarge">
                            <i class="fas fa-heart"></i>
                        </button>
                    </div>
                    
                    ${specsHTML ? `
                    <div class="product-description">
                        <h3 class="description-title">Specifications</h3>
                        <div class="specs-grid">
                            ${specsHTML}
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="reviews-section" id="reviews">
                        <div class="reviews-header">
                            <h3 class="description-title">Customer Reviews</h3>
                            <button class="action-btn-large" id="writeReviewBtn" style="min-width: 120px;">
                                <i class="fas fa-edit"></i> Write Review
                            </button>
                        </div>
                        
                        ${productReviews.length > 0 ? `
                            <div class="reviews-list">
                                ${reviewsHTML}
                            </div>
                            ${productReviews.length > 5 ? `
                                <div class="text-center mt-4">
                                    <button class="btn-secondary" id="viewAllReviewsBtn">
                                        View All ${productReviews.length} Reviews
                                    </button>
                                </div>
                            ` : ''}
                        ` : `
                            <div class="text-center" style="padding: 3rem; color: var(--text-secondary)">
                                <i class="fas fa-comments" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                                <h4 style="margin-bottom: 0.5rem;">No reviews yet</h4>
                                <p>Be the first to review this product!</p>
                            </div>
                        `}
                    </div>
                </div>
            `;
            // After the reviews section, add related products
            const relatedProducts = getRelatedProducts(product.id);

            // Only show related products if we have them
            if (relatedProducts.length > 0) {
                // Create related products HTML
                const relatedProductsHTML = `
                    <div class="related-products-section">
                        <div class="section-header">
                            <h2 class="section-title">Related Products</h2>
                            <a href="#" class="view-all" onclick="navigateTo('store'); document.getElementById('filterSelect').value='${product.category}'; handleSortChange(); return false;">
                                View All
                                <i class="fas fa-arrow-right"></i>
                            </a>
                        </div>
                        <div class="products-grid related-products-grid">
                            ${relatedProducts.map(relatedProduct => {
                                const isInWishlist = wishlist.some(item => item.productId === relatedProduct.id);
                                const isInCart = cart.some(item => item.productId === relatedProduct.id);
                                const discount = relatedProduct.originalPrice ? 
                                    Math.round(((relatedProduct.originalPrice - relatedProduct.price) / relatedProduct.originalPrice) * 100) : 0;
                                
                                return `
                                    <div class="product-card" data-product-id="${relatedProduct.id}">
                                        <div class="product-image-container">
                                            <img src="${relatedProduct.images[0]}" alt="${relatedProduct.name}" class="product-image">
                                            
                                            <div class="product-badges">
                                                ${relatedProduct.trending ? '<div class="product-badge badge-hot">Trending</div>' : ''}
                                                ${discount >= 20 ? `<div class="product-badge badge-sale">-${discount}%</div>` : ''}
                                            </div>
                                            
                                            <div class="product-actions">
                                                <button class="product-action-btn ${isInWishlist ? 'active' : ''}" data-action="wishlist" title="${isInWishlist ? 'Remove from wishlist' : 'Add to wishlist'}">
                                                    <i class="fas fa-heart"></i>
                                                </button>
                                                <button class="product-action-btn" data-action="quickview" title="Quick view">
                                                    <i class="fas fa-eye"></i>
                                                </button>
                                                <button class="product-action-btn ${isInCart ? 'active' : ''}" data-action="cart" title="${isInCart ? 'In cart' : 'Add to cart'}">
                                                    <i class="fas fa-shopping-cart"></i>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="product-info">
                                            <span class="product-category">${relatedProduct.category.toUpperCase()}</span>
                                            <h3 class="product-title">${relatedProduct.name}</h3>
                                            <div class="product-price">
                                                <span class="current-price"><b><strong>৳</strong></b>${relatedProduct.price.toFixed(2)}</span>
                                                ${relatedProduct.originalPrice ? `
                                                    <span class="original-price"><b><strong>৳</strong></b>${relatedProduct.originalPrice.toFixed(2)}</span>
                                                ` : ''}
                                            </div>
                                            <div class="product-rating">
                                                <div class="rating-stars">
                                                    ${getStarsHTML(relatedProduct.rating)}
                                                </div>
                                                <span class="rating-count">(${relatedProduct.ratingCount})</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
                
                // Append related products to the product details container
                container.innerHTML += relatedProductsHTML;
                
                // Setup event listeners for related products
                setTimeout(() => {
                    setupRelatedProductsEvents();
                }, 100);
            }
            // Add event listeners
            setupProductPageEvents(product);
            });
        }
        function setupRelatedProductsEvents() {
            // Add click events to related products
            document.querySelectorAll('.related-products-section .product-card').forEach(card => {
                const productId = card.dataset.productId;
                
                // Product image click
                card.querySelector('.product-image').addEventListener('click', () => {
                    viewProduct(productId);
                    activityData = {
                        productId: productId || "",
                        productName: product.name || "",
                        activity: "product image clicked"
                    }
                    sendActivityData(activityData);
                });
                
                // Product title click
                card.querySelector('.product-title').addEventListener('click', (e) => {
                    e.stopPropagation();
                    viewProduct(productId);
                    activityData = {
                        productId: productId || "",
                        productName: product.name || "",
                        activity: "title clicked"
                    }
                    sendActivityData(activityData);
                });
                
                // Wishlist button
                const wishlistBtn = card.querySelector('[data-action="wishlist"]');
                wishlistBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleWishlist(productId);
                    updateWishlistButton(wishlistBtn, productId);
                    activityData = {
                            productId: productId || "",
                            productName: product.name || "",
                            activity: "wishlisted"
                        }
                        sendActivityData(activityData);
                });
                
                // Quick view button
                card.querySelector('[data-action="quickview"]').addEventListener('click', (e) => {
                    e.stopPropagation();
                    viewProduct(productId);
                    activityData = {
                            productId: productId || "",
                            productName: product.name || "",
                            activity: "product view"
                        }
                        sendActivityData(activityData);
                });
                
                // Cart button
                const cartBtn = card.querySelector('[data-action="cart"]');
                cartBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isInCart = cart.some(item => item.productId == productId);
                    if (isInCart) {
                        showCartModal();
                    } else {
                        addToCart(productId);
                        updateCartButton(cartBtn, productId);
                        showToast('Added to cart!', 'success');
                        activityData = {
                            productId: productId || "",
                            productName: product.name || "",
                            activity: "added to cart"
                        }
                        sendActivityData(activityData);
                    }
                });
            });
        }
        function setupProductPageEvents(product) {
            // Thumbnails
            document.querySelectorAll('.thumbnail').forEach(thumb => {
                thumb.addEventListener('click', () => {
                    const index = thumb.getAttribute('data-index');
                    const mainImage = document.getElementById('mainProductImage');
                    if (mainImage) {
                        mainImage.src = product.images[index];
                        
                        // Update active thumbnail
                        document.querySelectorAll('.thumbnail').forEach(t => t.classList.remove('active'));
                        thumb.classList.add('active');
                    }
                });
            });
            
            // Get main image element FIRST - THIS NEEDS TO BE DECLARED BEFORE USE
            const mainImage = document.getElementById('mainProductImage');
            
            // Add zoom functionality to main image - NOW mainImage IS DEFINED
            if (mainImage) {
                mainImage.addEventListener('click', () => {
                    showZoomModal(mainImage.src);
                    activityData = {
                        productId: product.id,
                        productName: product.name,
                        activity: "clicked on zoom overlay"
                    }
                    sendActivityData(activityData);
                });
                
                // Also add zoom to zoom overlay
                const zoomOverlay = document.querySelector('.zoom-overlay');
                if (zoomOverlay) {
                    zoomOverlay.addEventListener('click', () => {
                        showZoomModal(mainImage.src);
                    });
                }
            }
            
            // Buy now
            document.getElementById('buyNowBtn').addEventListener('click', () => {
                console.log("the order is processing.")
                addToCart(product.id);
                showOrderModal();
                activityData = {
                        productId: product.id,
                        productName: product.name,
                        activity: "clicked on buy now button"
                    }
                    sendActivityData(activityData);
            });
            
            // Add to cart
            const addToCartBtn = document.getElementById('addToCartBtn');
            addToCartBtn.addEventListener('click', () => {
                const isInCart = cart.some(item => item.productId === product.id);
                if (isInCart) {
                    showCartModal();
                } else {
                    addToCart(product.id);
                    trackInteraction(product.id, 'cartAdd');
                    addToCartBtn.innerHTML = '<i class="fas fa-shopping-cart"></i> View Cart';
                    addToCartBtn.classList.add('active');
                    showToast('Added to cart!', 'success');
                    activityData = {
                        productId: product.id,
                        productName: product.name,
                        activity: "added to cart"
                    }
                    sendActivityData(activityData);

                }
            });
            
            // Wishlist
            const wishlistBtn = document.getElementById('wishlistBtnLarge');
            wishlistBtn.addEventListener('click', () => {
                toggleWishlist(product.id);
                updateWishlistButton(wishlistBtn, product.id);
                trackInteraction(product.id, 'wishlistAdd');
            });
            
            // Write review
            document.getElementById('writeReviewBtn').addEventListener('click', () => {
                if (!currentUser) {
                    showToast('Please login to write a review', 'error');
                    showProfileModal();
                    return;
                }
                showReviewModal(product.id); // This function now exists!
            });

            // Add review helpful buttons functionality
            document.addEventListener('click', function(e) {
                if (e.target.closest('.review-helpful button')) {
                    const button = e.target.closest('.review-helpful button');
                    const reviewId = parseInt(button.closest('.review-card').dataset.reviewId);
                    const isHelpful = button.textContent.includes('Helpful');
                    
                    // Update review helpful count
                    const review = reviews.find(r => r.id === reviewId);
                    if (review) {
                        if (isHelpful) {
                            review.helpful++;
                        } else {
                            review.notHelpful++;
                        }
                        saveToLocalStorage();
                        
                        // Update button text
                        if (isHelpful) {
                            button.innerHTML = `<i class="fas fa-thumbs-up"></i> Helpful (${review.helpful})`;
                        } else {
                            button.innerHTML = `<i class="fas fa-thumbs-down"></i> (${review.notHelpful})`;
                        }
                    }
                }
            });
            
            // View all reviews button (if it exists)
            const viewAllReviewsBtn = document.getElementById('viewAllReviewsBtn');
            if (viewAllReviewsBtn) {
                viewAllReviewsBtn.addEventListener('click', () => {
                    // Show all reviews
                    showToast('Showing all reviews', 'info');
                    document.getElementById('reviews').scrollIntoView({ behavior: 'smooth' });
                });
            }
            
            // Be first review button (if it exists)
            const beFirstReviewBtn = document.getElementById('beFirstReviewBtn');
            if (beFirstReviewBtn) {
                beFirstReviewBtn.addEventListener('click', () => {
                    if (!currentUser) {
                        showToast('Please login to write a review', 'error');
                        showProfileModal();
                        return;
                    }
                    showReviewModal(product.id);
                });
            }
            
            // Login to review button (if it exists)
            const loginToReviewBtn = document.getElementById('loginToReviewBtn');
            if (loginToReviewBtn) {
                loginToReviewBtn.addEventListener('click', () => {
                    showProfileModal();
                });
            }
            
            // Related products click events (if they exist)
            document.querySelectorAll('#relatedProducts .product-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.product-action-btn')) {
                        const productId = card.dataset.productId;
                        viewProduct(productId);
                    }
                });
            });
            
            // Add event listeners for review sorting buttons (if they exist)
            const reviewsSorting = document.getElementById('reviewsSorting');
            if (reviewsSorting) {
                reviewsSorting.querySelectorAll('.sort-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const sortBy = btn.dataset.sort;
                        
                        // Update active button
                        reviewsSorting.querySelectorAll('.sort-btn').forEach(b => {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        
                        // Reload reviews with new sorting
                        loadProductPage(product.id);
                    });
                });
            }
        }

        function showZoomModal(imageUrl) {
            if (!imageUrl) return;
            
            // Create or get modal
            let zoomModal = document.getElementById('zoomModal');
            
            if (!zoomModal) {
                const modalHTML = `
                    <div class="modal-overlay" id="zoomModal">
                        <div class="modal">
                            <div class="modal-header">
                                <h2 class="modal-title">Product Image</h2>
                                <button class="modal-close" id="closeZoomModal">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div class="modal-body" style="display: flex; align-items: center; justify-content: center; min-height: 400px;">
                                <img src="" alt="Zoomed Product Image" id="zoomedImage" 
                                    style="max-width: 100%; max-height: 70vh; object-fit: contain; border-radius: var(--radius); cursor: zoom-in;">
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                // Add event listener for close button
                document.getElementById('closeZoomModal').addEventListener('click', () => {
                    hideModal('zoomModal');
                });
                
                // Add click outside to close
                document.getElementById('zoomModal').addEventListener('click', (e) => {
                    if (e.target.id === 'zoomModal') {
                        hideModal('zoomModal');
                    }
                });
                
                // Add zoom in/out functionality
                const zoomedImage = document.getElementById('zoomedImage');
                let isZoomed = false;
                let originalTransform = '';
                
                zoomedImage.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    if (!isZoomed) {
                        // Zoom in
                        zoomedImage.style.transform = 'scale(2)';
                        zoomedImage.style.cursor = 'zoom-out';
                        isZoomed = true;
                    } else {
                        // Zoom out
                        zoomedImage.style.transform = 'scale(1)';
                        zoomedImage.style.cursor = 'zoom-in';
                        isZoomed = false;
                    }
                });
                
                zoomModal = document.getElementById('zoomModal');
            }
            
            // Set image source and show modal
            const zoomedImage = document.getElementById('zoomedImage');
            zoomedImage.src = imageUrl;
            zoomedImage.style.transform = 'scale(1)';
            zoomedImage.style.cursor = 'zoom-in';
            
            showModal('zoomModal');
            // Enable pinch zoom on mobile
            setupPinchZoom();
        }

        // Make function globally accessible
        window.showZoomModal = showZoomModal;
        // Add pinch zoom for mobile devices
        function setupPinchZoom() {
            const zoomedImage = document.getElementById('zoomedImage');
            if (!zoomedImage) return;

            // Avoid attaching listeners multiple times
            if (zoomedImage.dataset.pinchZoomAttached === '1') return;
            zoomedImage.dataset.pinchZoomAttached = '1';

            let startDist = 0;
            let startScale = 1;
            let scale = 1;

            // Double-tap to toggle zoom on mobile
            let lastTap = 0;
            zoomedImage.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTap < 250) {
                    e.preventDefault();
                    scale = scale > 1 ? 1 : 2;
                    zoomedImage.style.transform = `scale(${scale})`;
                    zoomedImage.style.cursor = scale > 1 ? 'zoom-out' : 'zoom-in';
                }
                lastTap = now;
            }, { passive: false });

            zoomedImage.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    startDist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const current = zoomedImage.style.transform.match(/scale\(([^)]+)\)/);
                    startScale = current ? parseFloat(current[1]) : scale;
                }
            }, { passive: false });

            zoomedImage.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && startDist) {
                    e.preventDefault();
                    const dist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const next = Math.min(4, Math.max(1, startScale * (dist / startDist)));
                    scale = next;
                    zoomedImage.style.transform = `scale(${scale})`;
                    zoomedImage.style.cursor = scale > 1 ? 'zoom-out' : 'zoom-in';
                }
            }, { passive: false });
        }

        // Call this function after showing zoom modal
        // ===== CART MANAGEMENT =====
        function addToCart(productId, quantity = 1) {
            const existingItem = cart.find(item => item.productId === productId);
            const product = products.find(p => p.id === productId);
            
            if (!product) {
                showToast('Product not found', 'error');
                return;
            }
            
            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                cart.push({
                    id: Date.now(),
                    productId: productId,
                    quantity: quantity,
                    price: product.price,
                    addedAt: new Date().toISOString()
                });
            }
            
            updateCartCount();
            saveToLocalStorage();
            
            // Track interaction
            trackInteraction(productId, 'cartAdd');
            
            // Update suggestions
            updateSuggestionsBasedOnInteraction(productId, 'cartAdd');
        }

        function updateCartCount() {
            const count = cart.reduce((total, item) => total + item.quantity, 0);
            
            // Update all badge elements
            document.querySelectorAll('#cartBadge, #mobileCartBadge, #mobileBottomCartBadge').forEach(badge => {
                badge.textContent = count > 99 ? '99+' : count;
                badge.style.display = count > 0 ? 'flex' : 'none';
            });
        }

        function updateCartButton(button, productId) {
            const isInCart = cart.some(item => item.productId === productId);
            
            if (isInCart) {
                button.classList.add('active');
                button.title = 'In cart';
                button.innerHTML = '<i class="fas fa-shopping-cart"></i>';
            } else {
                button.classList.remove('active');
                button.title = 'Add to cart';
                button.innerHTML = '<i class="fas fa-shopping-cart"></i>';
            }
        }

        function showCartModal() {
            updateCartModal();
            showModal('cartModal');
        }

        
        // Fast tap helper for mobile (prevents 300ms delay + double-fire)
        let __lastFastTap = 0;
        function bindFastTap(el, handler) {
            if (!el) return;
            const wrapped = (e) => {
                const now = Date.now();
                if (e.type === 'click' && (now - __lastFastTap) < 350) return;
                __lastFastTap = now;
                e.preventDefault();
                handler(e);
            };
            el.addEventListener('touchend', wrapped, { passive: false });
            el.addEventListener('click', wrapped);
        }

        function updateCartModal() {
            const container = document.getElementById('cartItemsContainer');
            
            if (cart.length === 0) {
                container.innerHTML = `
                    <div class="text-center" style="padding: 3rem; color: var(--text-secondary)">
                        <i class="fas fa-shopping-cart" style="font-size: 4rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3 style="margin-bottom: 0.5rem;">Your cart is empty</h3>
                        <p style="margin-bottom: 1.5rem;">Add some products to your cart!</p>
                        <button class="action-btn-large" id="startShoppingBtn">
                            Start Shopping
                        </button>
                    </div>
                `;
                
                document.getElementById('startShoppingBtn').addEventListener('click', () => {
                    hideModal('cartModal');
                    navigateTo('home');
                });
                
                updateCartTotals(0);
                return;
            }
            
            let html = '';
            let subtotal = 0;
            
            cart.forEach(item => {
                const product = products.find(p => p.id === item.productId);
                if (!product) return;
                
                const itemTotal = product.price * item.quantity;
                subtotal += itemTotal;
                
                html += `
                    <div class="cart-item" data-cart-id="${item.id}">
                        <img src="${product.images[0]}" alt="${product.name}" class="cart-item-image">
                        <div class="cart-item-details">
                            <h4 class="cart-item-title">${product.name}</h4>
                            <div class="cart-item-price"><b><strong>৳</strong></b>${product.price.toFixed(2)}</div>
                            <div class="cart-item-actions">
                                <div class="quantity-control">
                                    <button class="quantity-btn" data-action="decrease">-</button>
                                    <span class="quantity-value">${item.quantity}</span>
                                    <button class="quantity-btn" data-action="increase">+</button>
                                </div>
                                <button class="remove-item-btn" data-action="remove">Remove</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Add event listeners to cart items
            container.querySelectorAll('.cart-item').forEach(item => {
                const cartId = parseInt(item.dataset.cartId);
                const cartItem = cart.find(item => item.id === cartId);
                if (!cartItem) return;
                
                const productId = cartItem.productId;
                
                bindFastTap(item.querySelector('[data-action="decrease"]'), () => {
                    updateCartItemQuantity(cartId, -1);
                });
                
                bindFastTap(item.querySelector('[data-action="increase"]'), () => {
                    updateCartItemQuantity(cartId, 1);
                });
                
                bindFastTap(item.querySelector('[data-action="remove"]'), () => {
                    removeFromCart(cartId);
                });
            });
            
            updateCartTotals(subtotal);
        }

        function updateCartItemQuantity(cartId, change) {
            const item = cart.find(item => item.id === cartId);
            if (!item) return;
            
            item.quantity += change;
            
            if (item.quantity <= 0) {
                cart = cart.filter(item => item.id !== cartId);
                showToast('Removed from cart', 'success');
            } else {
                showToast('Cart updated', 'success');
            }
            
            updateCartModal();
            updateCartCount();
            saveToLocalStorage();
            
            // Update cart button on product page if open
            const cartBtn = document.querySelector(`[data-product-id="${item.productId}"][data-action="cart"]`);
            if (cartBtn) {
                updateCartButton(cartBtn, item.productId);
            }
        }

        function removeFromCart(cartId) {
            const item = cart.find(item => item.id === cartId);
            if (!item) return;
            
            cart = cart.filter(item => item.id !== cartId);
            updateCartModal();
            updateCartCount();
            saveToLocalStorage();
            
            // Update cart button on product page if open
            const cartBtn = document.querySelector(`[data-product-id="${item.productId}"][data-action="cart"]`);
            if (cartBtn) {
                updateCartButton(cartBtn, item.productId);
            }
            
            showToast('Removed from cart', 'success');
        }

        function updateCartTotals(subtotal) {
            const shipping = subtotal > 100 ? 0 : 5.99;
            const tax = subtotal * 0.08;
            const total = subtotal + shipping + tax;
            
            document.getElementById('cartSubtotal').innerHTML = `<b><strong>৳</strong></b>${subtotal.toFixed(2)}`;
            document.getElementById('cartShipping').innerHTML = shipping === 0 ? 'FREE' : `<b><strong>৳</strong></b>${shipping.toFixed(2)}`;
            document.getElementById('cartTax').innerHTML = `<b><strong>৳</strong></b>${tax.toFixed(2)}`;
            document.getElementById('cartTotal').innerHTML = `<b><strong>৳</strong></b>${total.toFixed(2)}`;
            
            // Update order modal totals too
            document.getElementById('orderSubtotal').innerHTML = `<b><strong>৳</strong></b>${subtotal.toFixed(2)}`;
            document.getElementById('orderShipping').innerHTML = shipping === 0 ? 'FREE' : `<b><strong>৳</strong></b>${shipping.toFixed(2)}`;
            document.getElementById('orderTax').innerHTML = `<b><strong>৳</strong></b>${tax.toFixed(2)}`;
            document.getElementById('orderTotal').innerHTML = `<b><strong>৳</strong></b>${total.toFixed(2)}`;
        }

        // ===== WISHLIST MANAGEMENT =====
        function toggleWishlist(productId) {
            const existingIndex = wishlist.findIndex(item => item.productId === productId);
            
            if (existingIndex === -1) {
                wishlist.push({
                    id: Date.now(),
                    productId: productId,
                    addedAt: new Date().toISOString()
                });
                showToast('Added to wishlist', 'success');
            } else {
                wishlist.splice(existingIndex, 1);
                showToast('Removed from wishlist', 'success');
            }
            
            updateWishlistCount();
            saveToLocalStorage();
        }

        function updateWishlistCount() {
            const count = wishlist.length;
            
            document.querySelectorAll('#wishlistBadge, #mobileWishlistBadge, #mobileBottomWishlistBadge').forEach(badge => {
                badge.textContent = count > 99 ? '99+' : count;
                badge.style.display = count > 0 ? 'flex' : 'none';
            });
        }

        function updateWishlistButton(button, productId) {
            const isInWishlist = wishlist.some(item => item.productId === productId);
            
            if (isInWishlist) {
                button.classList.add('active');
                button.title = 'Remove from wishlist';
                button.innerHTML = '<i class="fas fa-heart"></i>';
            } else {
                button.classList.remove('active');
                button.title = 'Add to wishlist';
                button.innerHTML = '<i class="fas fa-heart"></i>';
            }
        }

        function showWishlistModal() {
            updateWishlistModal();
            showModal('wishlistModal');
        }

        function updateWishlistModal() {
            const container = document.getElementById('wishlistItemsContainer');
            
            if (wishlist.length === 0) {
                container.innerHTML = `
                    <div class="text-center" style="padding: 3rem; color: var(--text-secondary)">
                        <i class="fas fa-heart" style="font-size: 4rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <h3 style="margin-bottom: 0.5rem;">Your wishlist is empty</h3>
                        <p style="margin-bottom: 1.5rem;">Add some products to your wishlist!</p>
                        <button class="action-btn-large" id="browseWishlistBtn">
                            Browse Products
                        </button>
                    </div>
                `;
                
                document.getElementById('browseWishlistBtn').addEventListener('click', () => {
                    hideModal('wishlistModal');
                    navigateTo('home');
                });
                return;
            }
            
            let html = '';
            
            wishlist.forEach(item => {
                const product = products.find(p => p.id === item.productId);
                if (!product) return;
                
                html += `
                    <div class="cart-item" data-wishlist-id="${item.id}">
                        <img src="${product.images[0]}" alt="${product.name}" class="cart-item-image">
                        <div class="cart-item-details">
                            <h4 class="cart-item-title">${product.name}</h4>
                            <div class="cart-item-price"><b><strong>৳</strong></b>${product.price.toFixed(2)}</div>
                            <div class="cart-item-actions">
                                <button class="action-btn-large" style="padding: 0.5rem 1rem; font-size: 0.875rem;" data-action="addtocart">
                                    <i class="fas fa-cart-plus"></i> Add to Cart
                                </button>
                                <button class="remove-item-btn" data-action="remove">
                                    <i class="fas fa-trash"></i> Remove
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Add event listeners
            container.querySelectorAll('.cart-item').forEach(item => {
                const wishlistId = parseInt(item.dataset.wishlistId);
                const wishlistItem = wishlist.find(item => item.id === wishlistId);
                if (!wishlistItem) return;
                
                const productId = wishlistItem.productId;
                
                item.querySelector('[data-action="addtocart"]').addEventListener('click', () => {
                    addToCart(productId);
                    showToast('Added to cart!', 'success');
                });
                
                item.querySelector('[data-action="remove"]').addEventListener('click', () => {
                    toggleWishlist(productId);
                    updateWishlistModal();
                });
            });
        }

        // ===== USER MANAGEMENT =====
        function showProfileModal() {
            if (currentUser) {
                showProfileTab();
            } else {
                showLoginTab();
            }
            showModal('profileModal');
        }

        function switchProfileTab(tabId) {
            // Update tabs
            document.querySelectorAll('.profile-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.tab === tabId) {
                    tab.classList.add('active');
                }
            });
            
            // Update content
            document.querySelectorAll('.profile-content').forEach(content => {
                content.classList.remove('active');
                if (content.id === tabId + 'Tab') {
                    content.classList.add('active');
                }
            });
            
            // Show/hide profile tab based on login status
            const profileTab = document.querySelector('.profile-tab[data-tab="profile"]');
            if (profileTab) {
                profileTab.style.display = currentUser ? 'block' : 'none';
            }
        }

        function showLoginTab() {
            switchProfileTab('login');
            document.getElementById('profileModalTitle').textContent = 'Login';
        }

        function showRegisterTab() {
            switchProfileTab('register');
            document.getElementById('profileModalTitle').textContent = 'Register';
        }

        function showProfileTab() {
            switchProfileTab('profile');
            document.getElementById('profileModalTitle').textContent = 'Profile';
            
            // Update profile info
            document.getElementById('profileUserName').textContent = currentUser.name;
            document.getElementById('profileUserEmail').textContent = currentUser.email;
            document.getElementById('profileUserPhone').textContent = currentUser.phone || 'Not provided';
            document.getElementById('profileUserAddress').textContent = currentUser.address || 'Not provided';
            
            // Calculate stats
            const userOrders = orders.filter(order => order.userId === currentUser.id);
            const totalSpent = userOrders.reduce((sum, order) => sum + order.total, 0);
            
            document.getElementById('profileOrders').textContent = userOrders.length;
            document.getElementById('profileSpent').innerHTML = `<b><strong>৳</strong></b>${totalSpent.toFixed(2)}`;
            document.getElementById('profileWishlist').textContent = wishlist.length;
            
            // Check if user is admin and show admin button
            const user = users.find(u => u.id === currentUser.id);
            const formActions = document.querySelector('#profileTab .form-actions');
            
            if (user && user.isAdmin) {
                // Check if admin button already exists
                if (!document.getElementById('adminAccessBtn')) {
                    const adminBtn = document.createElement('button');
                    adminBtn.id = 'adminAccessBtn';
                    adminBtn.className = 'form-btn btn-primary';
                    adminBtn.innerHTML = '<i class="fas fa-cogs"></i> Admin Panel';
                    adminBtn.style.marginTop = '1rem';
                    
                    adminBtn.addEventListener('click', () => {
                        hideModal('profileModal');
                        navigateTo('admin');
                    });
                    
                    formActions.appendChild(adminBtn);
                }
            } else {
                // Remove admin button if it exists
                const adminBtn = document.getElementById('adminAccessBtn');
                if (adminBtn) {
                    adminBtn.remove();
                }
            }
        }

        function showEditProfile() {
            // Show edit form in modal
            const modalBody = document.querySelector('#profileModal .modal-body');
            
            // Clear any existing edit form
            const existingForm = document.getElementById('editProfileForm');
            if (existingForm) {
                existingForm.remove();
            }
            
            // Create edit form HTML
            const editFormHTML = `
                <div id="editProfileFormContainer">
                    <h3 class="mb-4">Edit Profile</h3>
                    <form id="editProfileForm">
                        <div class="admin-form-group">
                            <label class="admin-form-label">Full Name</label>
                            <input type="text" class="admin-form-input" id="editProfileName" value="${currentUser.name}" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Email</label>
                            <input type="email" class="admin-form-input" id="editProfileEmail" value="${currentUser.email}" required>
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Phone Number</label>
                            <input type="tel" class="admin-form-input" id="editProfilePhone" value="${currentUser.phone || ''}">
                        </div>
                        <div class="admin-form-group">
                            <label class="admin-form-label">Address</label>
                            <textarea class="admin-form-input admin-form-textarea" id="editProfileAddress">${currentUser.address || ''}</textarea>
                        </div>
                        <div class="form-actions">
                            <button type="submit" class="form-btn btn-primary">Save Changes</button>
                            <button type="button" class="form-btn btn-secondary" id="cancelEditProfile">Cancel</button>
                        </div>
                    </form>
                </div>
            `;
            
            // Replace modal body content
            modalBody.innerHTML = editFormHTML;
            
            // Add event listeners after form is added to DOM
            setTimeout(() => {
                const form = document.getElementById('editProfileForm');
                const cancelBtn = document.getElementById('cancelEditProfile');
                
                if (form) {
                    form.addEventListener('submit', function(e) {
                        e.preventDefault();
                        handleEditProfile();
                    });
                }
                
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', showProfileTab);
                }
            }, 100);
        }

        function handleEditProfile() {
            const name = document.getElementById('editProfileName').value.trim();
            const email = document.getElementById('editProfileEmail').value.trim();
            const phone = document.getElementById('editProfilePhone').value.trim();
            const address = document.getElementById('editProfileAddress').value.trim();
            
            if (!name || !email) {
                showToast('Please fill in all required fields', 'error');
                return;
            }
            
            // Email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                showToast('Please enter a valid email address', 'error');
                return;
            }
            
            // Update user in database
            const userIndex = users.findIndex(u => u.id === currentUser.id);
            if (userIndex !== -1) {
                users[userIndex].name = name;
                users[userIndex].email = email;
                users[userIndex].phone = phone;
                users[userIndex].address = address;
                users[userIndex].updatedAt = new Date().toISOString();
                
                // Update current user
                currentUser = { ...currentUser, name, email, phone, address };
                localStorage.setItem('shopure_current_user_v3', JSON.stringify(currentUser));
                
                saveToLocalStorage();
                showProfileTab();
                showToast('Profile updated successfully!', 'success');
            } else {
                showToast('User not found', 'error');
            }
        }
        function handleLogin(e) {
            e.preventDefault();
            
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value.trim();
            
            if (!email || !password) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            const user = users.find(u => u.email === email && u.password === hashPassword(password));
            
            if (user) {
                currentUser = {
                    id: user.id,
                    name: user.name,
                    email: user.email,
                    phone: user.phone,
                    address: user.address,
                    isAdmin: user.isAdmin || false
                };

                sendLoginData(currentUser);
                // Update last login
                user.lastLogin = new Date().toISOString();
                
                // Start user activity timer
                userActivityTimers[user.id] = Date.now();
                
                saveToLocalStorage();
                showProfileTab();
                showToast('Login successful!', 'success');
                trackActivity('user_login', null);
                
                // If user is admin, show welcome message
                if (user.isAdmin) {
                    setTimeout(() => {
                        showToast('Welcome Admin! Admin panel is available in your profile.', 'success');
                    }, 500);
                }
            } else {
                LoadRegistrationData().then(data => {
                    registeredData = data;

                    // 🔒 Normalize ANY type to clean string
                    const normalize = v => String(v ?? "").trim();

                    const foundUser = registeredData.find(u =>
                        normalize(u.email).toLowerCase() === normalize(email).toLowerCase() &&
                        normalize(u.password) === normalize(hashPassword(password))
                    );


                    if (foundUser) {
                        currentUser = {
                            id: foundUser.id,
                            name: foundUser.name,
                            email: foundUser.email,
                            phone: foundUser.phone,
                            address: foundUser.address,
                            isAdmin: foundUser.isAdmin || false
                        };

                        users.push(foundUser); // sync to local
                        saveToLocalStorage();

                        sendLoginData(currentUser);

                        foundUser.lastLogin = new Date().toISOString();
                        userActivityTimers[foundUser.id] = Date.now();

                        showProfileTab();
                        showToast('Login successful!', 'success');
                        trackActivity('user_login', null);

                        if (foundUser.isAdmin) {
                            setTimeout(() => {
                                showToast(
                                    'Welcome Admin! Admin panel is available in your profile.',
                                    'success'
                                );
                            }, 500);
                        }
                    } else {
                        showToast('Invalid email or password', 'error');
                    }
                });


            }
        }

        function handleRegister(e) {
            e.preventDefault();
            
            const name = document.getElementById('registerName').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value.trim();
            const confirmPassword = document.getElementById('registerConfirmPassword').value.trim();
            const phone = document.getElementById('registerPhone').value.trim();
            const address = document.getElementById('registerAddress').value.trim();
            
            // Validation
            if (!name || !email || !password || !confirmPassword) {
                showToast('Please fill in all required fields', 'error');
                return;
            }
            
            if (password !== confirmPassword) {
                showToast('Passwords do not match', 'error');
                return;
            }
            
            if (password.length < 8) {
                showToast('Password must be at least 8 characters', 'error');
                return;
            }
            
            // Check if user exists
            if (users.find(u => u.email === email)) {
                showToast('User with this email already exists', 'error');
                return;
            }
            
            // Create new user
            const newUser = {
                id: Date.now(),
                name: name,
                email: email,
                password: hashPassword(password),
                phone: phone,
                address: address,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                isAdmin: false,
                orders: [],
                lastLogin: new Date().toISOString(),
                totalSpent: 0,
                totalOrders: 0,
                preferences: {
                    categories: [],
                    priceRange: { min: 0, max: 1000 },
                    likedProducts: [],
                    viewedProducts: []
                },
                activityStats: {
                    totalSessions: 1,
                    totalTimeSpent: 0,
                    avgSessionTime: 0,
                    lastActivity: new Date().toISOString()
                }
            };
            sendRegistrationData(newUser);
            users.push(newUser);
            currentUser = {
                id: newUser.id,
                name: newUser.name,
                email: newUser.email,
                phone: newUser.phone,
                address: newUser.address,
                isAdmin: false
            };
            
            // Start user activity timer
            userActivityTimers[newUser.id] = Date.now();
            
            saveToLocalStorage();
            showProfileTab();
            showToast('Account created successfully!', 'success');
            trackActivity('user_register', null);
        }

        function sendRegistrationData(newUser) {
        const params = new URLSearchParams();

        // Flatten object safely
        Object.entries(newUser).forEach(([key, value]) => {
            if (typeof value === "object") {
            params.append(key, JSON.stringify(value));
            } else {
            params.append(key, value);
            }
        });

        fetch("https://script.google.com/macros/s/AKfycbxEpfVsEozPd4unHGHMPC9EqmZFVAOgpQuwpM2FXnnHwGWOVUfli2vZta8td-8FA0G3/exec", {
            method: "POST",
            body: params
        })
            .then(res => res.text())
            .then(txt => console.log("POST:", txt))
            .catch(err => console.error(err));
        }

        //send login data to the google sheet
        function sendLoginData(user) {

        const currentUser = {
            id: user.id,
            name: user.name,
            email: user.email,
            phone: user.phone,
            address: user.address,
            isAdmin: user.isAdmin
        };

        const data = new URLSearchParams(currentUser);

        fetch("https://script.google.com/macros/s/AKfycbw018ckKoZjgOXWC99NP1pY3hTPY1Zd_aEmk9BDkwhePxYB30bRsP-ZvkZn4iUQdWps/exec", {
            method: "POST",
            mode: "no-cors",
            body: data
        });
        }


        //send login data to the google sheet
        function sendActivityData(activityData) {
             fetch("https://api.ipify.org?format=json")
                .then(res => res.json())
                .then(ipDetails => {
                
            if (!currentUser){
                currentUser = {
                    id: ipDetails.ip,
                    name: ipDetails.city || "Guest",
                    email: ipDetails.org || "Guest",
                    phone: loc || ipDetails.ip,
                    address: region || ipDetails.ip

                };
            };
        const activityDetails = {
            userId: currentUser.id,
            userName: currentUser.name,
            userEmail: currentUser.email,
            userPhone: currentUser.phone,
            userAddress: currentUser.address,
            isAdmin: currentUser.isAdmin,
            productId: activityData.productid,
            productName: activityData.productName,
            activity: activityData.activity
        };

        const data = new URLSearchParams(activityDetails);

        fetch("https://script.google.com/macros/s/AKfycbxeSXUphhtvAg8A2uunB-Cgf7p2U1bLT0dzTtjfO094Yltwtyi35Qjhhy6k2Gh6IdFE/exec", {
            method: "POST",
            mode: "no-cors",
            body: data
        });
        })
            .catch(err => console.error(err));
        }


        function loadProductData() {
            return fetch("https://script.google.com/macros/s/AKfycbxHEm4DNrxnqzXvD2Ums6TszXMvyoQEgGMjdnIKiKEngtWH5AeFKpbLyyixjhNB2ZhBGA/exec")
                .then(res => res.json());
            }


        function LoadRegistrationData() {
        return fetch("https://script.google.com/macros/s/AKfycbxEpfVsEozPd4unHGHMPC9EqmZFVAOgpQuwpM2FXnnHwGWOVUfli2vZta8td-8FA0G3/exec")
            .then(res => res.json());
        }

        function loadReviewData() {
            return fetch("https://script.google.com/macros/s/AKfycbw-tSL2LsC_dQQWjUryWiukipqysB8blAfjRsus_-N8Cs69Cr0GTq89nWz2ANb6xFFS/exec")
                .then(res => res.json());
            }
    
        function loadSlideData() {
            return fetch("https://script.google.com/macros/s/AKfycbwRsdKHcqW0BL3FnDic6TdKnUcbTwqC9ejmzAduUyPOm2F5eVMMWBjuJGF3k9F6L_mhGA/exec")
                .then(res => res.json());
            }
        function loadCategoryData() {
            return fetch("https://script.google.com/macros/s/AKfycbyjF1kkZyj8WdGoE49iMzflIo6M0cJcFofuCUCEUfyh7GUelRokmv6l9puWKBuVkGPV8g/exec",)
                .then(res => res.json());
                
            }
        function loadConversationData() {
            return fetch("https://script.google.com/macros/s/AKfycbyfUCja-Grqxki_m17yT9Rg7sYIshT5exz5giXqvkwza9D-nRSGbvy_SzdZRyWn-xH0hQ/exec",)
                .then(res => res.json());
                
            }

        function handleLogout() {
            // Track view time before logout
            Object.keys(nanoTimeTracker).forEach(productId => {
                const viewTime = performance.now() - nanoTimeTracker[productId];
                trackInteraction(productId, 'viewTime', Math.round(viewTime));
                trackActivity('product_view_end', productId, Math.round(viewTime));
                delete nanoTimeTracker[productId];
            });
            
            // Update user activity before logout
            if (currentUser && userActivityTimers[currentUser.id]) {
                const sessionTime = Date.now() - userActivityTimers[currentUser.id];
                updateUserActivity(sessionTime);
                delete userActivityTimers[currentUser.id];
            }
            
            currentUser = null;
            localStorage.removeItem('shopure_current_user_v3');
            showLoginTab();
            showToast('Logged out successfully', 'success');
            trackActivity('user_logout', null);
        }

        // ===== ORDER MANAGEMENT =====
        function showOrderModal() {
            if (!currentUser) {
                showToast('Please login to checkout', 'error');
                showProfileModal();
                return;
            }
            
            if (cart.length === 0) {
                showToast('Your cart is empty', 'error');
                return;
            }
            
            // Pre-fill user info
            document.getElementById('orderName').value = currentUser.name || '';
            document.getElementById('orderEmail').value = currentUser.email || '';
            document.getElementById('orderPhone').value = currentUser.phone || '';
            document.getElementById('orderAddress').value = currentUser.address || '';
            
            // Set default city and postal code
            document.getElementById('orderCity').value = 'Dhaka';
            document.getElementById('orderPostalCode').value = '1200';
            
            showModal('orderModal');
        }

        function handleOrderSubmit(e) {
            e.preventDefault();
            
            // Get form data
            const orderData = {
                name: document.getElementById('orderName').value.trim(),
                phone: document.getElementById('orderPhone').value.trim(),
                email: document.getElementById('orderEmail').value.trim(),
                address: document.getElementById('orderAddress').value.trim(),
                city: document.getElementById('orderCity').value.trim(),
                postalCode: document.getElementById('orderPostalCode').value.trim(),
                // Get selected payment method
                paymentMethod: document.querySelector('.newPaymentMethod')?.value || '',

                // Get transaction ID
                transactionId: document.getElementById('transactionId')?.value.trim() || '',

                // Get payment amount
                paymentAmount: parseFloat(document.getElementById('paymentAmount')?.value) || 0,

                // Get last 3 digits
                lastThreeDigits: document.getElementById('lastThreeDigits')?.value.trim() || ''
            };
            
            // Validation
            if (!orderData.name || !orderData.phone || !orderData.email || !orderData.address || !orderData.city || !orderData.postalCode) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            // Calculate totals
            const subtotal = cart.reduce((total, item) => {
                const product = products.find(p => p.id === item.productId);
                return total + (product?.price || 0) * item.quantity;
            }, 0);
            
            const shipping = subtotal > 100 ? 0 : 5.99;
            const tax = subtotal * 0.08;
            const total = subtotal + shipping + tax;
            
            // Create order
            const order = {
                id: Date.now(),
                userId: currentUser.id,
                items: [...cart],
                total: total,
                subtotal: subtotal,
                shipping: shipping,
                tax: tax,
                status: 'pending',
                payment: {
                    method: orderData.paymentMethod,
                    transactionId: orderData.transactionId,
                    amount: orderData.paymentAmount || total,
                    digits: orderData.lastThreeDigits
                },
                shippingInfo: {
                    name: orderData.name,
                    phone: orderData.phone,
                    email: orderData.email,
                    address: orderData.address,
                    city: orderData.city,
                    postalCode: orderData.postalCode
                },
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            console.log("called.");
            sendOrderData(order);
            // Add to orders
            orders.push(order);
            
            // Update user stats
            const user = users.find(u => u.id === currentUser.id);
            if (user) {
                user.orders.push(order.id);
                user.totalSpent = (user.totalSpent || 0) + total;
                user.totalOrders = (user.totalOrders || 0) + 1;
                user.updatedAt = new Date().toISOString();
            }
            
            // Track purchases
            cart.forEach(item => {
                trackInteraction(item.productId, 'purchase');
                trackActivity('product_purchase', item.productId);
                
                // Update product stock
                const product = products.find(p => p.id === item.productId);
                if (product) {
                    product.stock = Math.max(0, product.stock - item.quantity);
                    product.updatedAt = new Date().toISOString();
                }
            });
            
            // Clear cart
            cart = [];
            updateCartCount();
            saveToLocalStorage();
            
            // Hide modals
            hideModal('orderModal');
            hideModal('cartModal');
            
            // Show success message
            showToast(`Wait for the confirmation! message #${order.id}`, 'procssing..');
            
            // Reset form
            document.getElementById('orderForm').reset();
        }


        //send order informations to google sheet
        function sendOrderData(order) {
        const sheetData = {
            userId: currentUser.id,
            userName: currentUser.name,
            userEmail: currentUser.email,
            userPhone: currentUser.phone,

            orderId: order.id,
            items: JSON.stringify(order.items),

            total: order.total,
            subtotal: order.subtotal,
            shipping: order.shipping,
            tax: order.tax,
            status: order.status,

            paymentMethod: order.payment.method,
            transactionId: order.payment.transactionId,
            amount: order.payment.amount,
            lastThreeDigits: order.payment.digits,

            shippingName: order.shippingInfo.name,
            shippingPhone: order.shippingInfo.phone,
            shippingEmail: order.shippingInfo.email,
            shippingAddress: order.shippingInfo.address,
            city: order.shippingInfo.city,
            postalCode: order.shippingInfo.postalCode,

            createdAt: order.createdAt,
            updatedAt: order.updatedAt
        };

        const formData = new URLSearchParams(sheetData);

        fetch("https://script.google.com/macros/s/AKfycbxtCUTtF2loKZvT8P2XMMh72w_kBc3IZEq9S7hyELmwq5G7UeHTYZeV0iD7q16ngb4/exec", {
            method: "POST",
            body: formData
        })
        .then(() => console.log("✅"))
        .catch(err => console.error("❌ Error:", err));
        }



        // Enhanced tracking system
        function trackInteraction(productId, type, value = 1, userId = null) {
            const effectiveUserId = userId || currentUser?.id || 'guest';
            
            // Global interaction tracking
            let interaction = interactions.find(i => i.productId == productId);
            
            if (!interaction) {
                interaction = {
                    productId: productId,
                    views: 0,
                    clicks: 0,
                    cartAdds: 0,
                    wishlistAdds: 0,
                    purchases: 0,
                    totalViewTime: 0,
                    avgViewTime: 0,
                    conversionRate: 0,
                    userStats: {},
                    lastUpdated: new Date().toISOString()
                };
                interactions.push(interaction);
            }
            
            // Update global stats
            switch(type) {
                case 'view':
                    interaction.views += value;
                    break;
                case 'click':
                    interaction.clicks += value;
                    break;
                case 'cartAdd':
                    interaction.cartAdds += value;
                    break;
                case 'wishlistAdd':
                    interaction.wishlistAdds += value;
                    break;
                case 'purchase':
                    interaction.purchases += value;
                    break;
                case 'viewTime':
                    interaction.totalViewTime += value;
                    interaction.avgViewTime = interaction.views > 0 ? 
                        Math.round(interaction.totalViewTime / interaction.views) : 0;
                    break;
            }
            
            // Update user-specific stats
            if (!interaction.userStats[effectiveUserId]) {
                interaction.userStats[effectiveUserId] = {
                    views: 0,
                    clicks: 0,
                    cartAdds: 0,
                    wishlistAdds: 0,
                    purchases: 0,
                    totalViewTime: 0
                };
            }
            
            const userStat = interaction.userStats[effectiveUserId];
            switch(type) {
                case 'view':
                    userStat.views += value;
                    break;
                case 'click':
                    userStat.clicks += value;
                    break;
                case 'cartAdd':
                    userStat.cartAdds += value;
                    break;
                case 'wishlistAdd':
                    userStat.wishlistAdds += value;
                    break;
                case 'purchase':
                    userStat.purchases += value;
                    break;
                case 'viewTime':
                    userStat.totalViewTime += value;
                    break;
            }
            
            // Calculate conversion rate
            if (interaction.clicks > 0) {
                interaction.conversionRate = ((interaction.purchases / interaction.clicks) * 100).toFixed(2);
            }
            
            interaction.lastUpdated = new Date().toISOString();
            
            // Update product metadata
            const product = products.find(p => p.id == productId);
            if (product && product.metadata) {
                switch(type) {
                    case 'view':
                        product.metadata.views += value;
                        break;
                    case 'click':
                        product.metadata.clicks += value;
                        break;
                    case 'cartAdd':
                        product.metadata.cartAdds += value;
                        break;
                    case 'wishlistAdd':
                        product.metadata.wishlistAdds += value;
                        break;
                    case 'purchase':
                        product.metadata.purchases += value;
                        break;
                    case 'viewTime':
                        product.metadata.totalViewTime += value;
                        break;
                }
            }
            
            // Track category interaction
            if (product) {
                trackCategoryInteraction(product.category, type, value, effectiveUserId);
            }
            
            // Update user preferences
            if (currentUser) {
                updateUserPreferencesInRealTime(type, productId);
            }
        }

        // New function to track category interactions
        function trackCategoryInteraction(category, type, value = 1, userId = null) {
            const effectiveUserId = userId || currentUser?.id || 'guest';
            
            // Initialize category tracking if not exists
            if (!window.categoryInteractions) {
                window.categoryInteractions = {};
            }
            
            if (!window.categoryInteractions[category]) {
                window.categoryInteractions[category] = {
                    views: 0,
                    clicks: 0,
                    cartAdds: 0,
                    purchases: 0,
                    userStats: {},
                    lastUpdated: new Date().toISOString()
                };
            }
            
            const catInteraction = window.categoryInteractions[category];
            
            // Update category stats
            switch(type) {
                case 'view':
                    catInteraction.views += value;
                    break;
                case 'click':
                    catInteraction.clicks += value;
                    break;
                case 'cartAdd':
                    catInteraction.cartAdds += value;
                    break;
                case 'purchase':
                    catInteraction.purchases += value;
                    break;
            }
            
            // Update user-specific category stats
            if (!catInteraction.userStats[effectiveUserId]) {
                catInteraction.userStats[effectiveUserId] = {
                    views: 0,
                    clicks: 0,
                    cartAdds: 0,
                    purchases: 0
                };
            }
            
            const userCatStat = catInteraction.userStats[effectiveUserId];
            switch(type) {
                case 'view':
                    userCatStat.views += value;
                    break;
                case 'click':
                    userCatStat.clicks += value;
                    break;
                case 'cartAdd':
                    userCatStat.cartAdds += value;
                    break;
                case 'purchase':
                    userCatStat.purchases += value;
                    break;
            }
            
            catInteraction.lastUpdated = new Date().toISOString();
            
            // Save to localStorage
            localStorage.setItem('shopure_category_interactions_v3', JSON.stringify(window.categoryInteractions));
        }

        function trackActivity(type, productId = null, duration = null) {
            const activity = {
                id: Date.now(),
                userId: currentUser?.id || null,
                type: type,
                productId: productId,
                timestamp: new Date().toISOString(),
                duration: duration,
                page: currentPage,
                ipAddress: '192.168.1.1', // In real app, get from server
                device: navigator.userAgent,
                screenSize: `${window.innerWidth}x${window.innerHeight}`
            };
            
            activities.push(activity);
            
            // Keep only last 1000 activities
            if (activities.length > 1000) {
                activities = activities.slice(-1000);
            }
            
            // Update user preferences based on activity
            if (currentUser && productId) {
                updateUserPreferences(type, productId);
            }
        }

        function updateUserPreferences(activityType, productId) {
            const user = users.find(u => u.id === currentUser.id);
            if (!user || !user.preferences) return;
            
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            switch(activityType) {
                case 'product_view':
                    if (!user.preferences.viewedProducts.includes(productId)) {
                        user.preferences.viewedProducts.push(productId);
                    }
                    if (!user.preferences.categories.includes(product.category)) {
                        user.preferences.categories.push(product.category);
                    }
                    break;
                case 'add_to_cart':
                case 'product_purchase':
                    user.preferences.priceRange.min = Math.min(user.preferences.priceRange.min, product.price);
                    user.preferences.priceRange.max = Math.max(user.preferences.priceRange.max, product.price);
                    break;
                case 'add_to_wishlist':
                    if (!user.preferences.likedProducts.includes(productId)) {
                        user.preferences.likedProducts.push(productId);
                    }
                    break;
            }
            
            user.updatedAt = new Date().toISOString();
        }

        // ===== PRODUCT SUGGESTIONS =====
        // ===== ENHANCED PERSONALIZED SUGGESTIONS =====
        // ===== ENHANCED PERSONALIZED SUGGESTIONS =====
        function generateSuggestions() {
            //console.log('Generating personalized suggestions...');
            
            if (!currentUser) {
                // For non-logged-in users, show trending products
                //console.log('No user logged in, showing trending products');
                return getTrendingSuggestions();
            }
            
            const user = users.find(u => u.id === currentUser.id);
            if (!user || !user.preferences) {
                //console.log('No user preferences found, showing trending');
                return getTrendingSuggestions();
            }
            
            const preferences = user.preferences;
            //console.log('User preferences:', preferences);
            
            // Get user's wishlist and cart items
            const userWishlist = wishlist.filter(item => item.userId === currentUser.id).map(item => item.productId);
            const userCart = cart.filter(item => item.userId === currentUser.id).map(item => item.productId);
            
            // Generate suggestions based on multiple factors
            const suggestions = new Map(); // Use Map to avoid duplicates
            
            // 1. STRATEGY: View History Analysis
            if (preferences.viewedProducts && preferences.viewedProducts.length > 0) {
                //console.log('Analyzing view history...');
                const viewBasedSuggestions = getViewBasedSuggestions(preferences.viewedProducts, userWishlist, userCart);
                addToSuggestionsMap(suggestions, viewBasedSuggestions, 3.0);
            }
            
            // 2. STRATEGY: Category Preferences
            if (preferences.categories && preferences.categories.length > 0) {
                //console.log('Analyzing category preferences...');
                const categoryBasedSuggestions = getCategoryBasedSuggestions(preferences.categories, userWishlist, userCart);
                addToSuggestionsMap(suggestions, categoryBasedSuggestions, 2.5);
            }
            
            // 3. STRATEGY: Price Range Preferences
            if (preferences.priceRange) {
                //console.log('Analyzing price range preferences...');
                const priceBasedSuggestions = getPriceBasedSuggestions(preferences.priceRange, userWishlist, userCart);
                addToSuggestionsMap(suggestions, priceBasedSuggestions, 2.0);
            }
            
            // 4. STRATEGY: Recently Viewed Similarity
            if (preferences.viewedProducts && preferences.viewedProducts.length > 0) {
                //console.log('Finding similar to recently viewed...');
                const recentSimilar = getRecentSimilarSuggestions(preferences.viewedProducts, userWishlist, userCart);
                addToSuggestionsMap(suggestions, recentSimilar, 3.5);
            }
            
            // 5. STRATEGY: Trending but Relevant
            //console.log('Adding trending relevant products...');
            const trendingRelevant = getTrendingRelevantSuggestions(preferences, userWishlist, userCart);
            addToSuggestionsMap(suggestions, trendingRelevant, 1.5);
            
            // 6. STRATEGY: Complementary Products
            if (preferences.viewedProducts && preferences.viewedProducts.length > 0) {
                //console.log('Finding complementary products...');
                const complementary = getComplementarySuggestions(preferences.viewedProducts, userWishlist, userCart);
                addToSuggestionsMap(suggestions, complementary, 1.0);
            }
            
            // Convert Map to array and sort by score
            let suggestionsArray = Array.from(suggestions.values())
                .sort((a, b) => b.score - a.score);
            
            //console.log('Generated suggestions count:', suggestionsArray.length);
            
            // If we don't have enough suggestions, add fallback products
            if (suggestionsArray.length < 8) {
                //console.log('Adding fallback suggestions...');
                const needed = 8 - suggestionsArray.length;
                const fallback = getFallbackSuggestions(suggestionsArray, needed, userWishlist, userCart);
                suggestionsArray = [...suggestionsArray, ...fallback];
            }
            
            // Limit to 12 products and remove scoring data
            const finalSuggestions = suggestionsArray
                .slice(0, 12)
                .map(item => item.product);
            
            //console.log('Final suggestions count:', finalSuggestions.length);
            
            // Cache suggestions for faster updates
            cacheUserSuggestions(currentUser.id, finalSuggestions);
            
            return finalSuggestions;
        }

        // ===== SUGGESTION STRATEGIES =====

        function getViewBasedSuggestions(viewedProductIds, userWishlist, userCart) {
            loadProductData().then(data => {
                products = data;
            const suggestions = new Map();
            
            // Filter out wishlist and cart items from suggestions
            const excludedIds = [...userWishlist, ...userCart];
            
            // Analyze view history to find patterns
            const viewedProducts = viewedProductIds
                .map(id => products.find(p => p.id === id))
                .filter(p => p);
            
            if (viewedProducts.length === 0) return suggestions;
            
            // Group by category to find user's category preferences
            const categoryCounts = {};
            viewedProducts.forEach(product => {
                categoryCounts[product.category] = (categoryCounts[product.category] || 0) + 1;
            });
            
            // Get most viewed categories (top 3)
            const topCategories = Object.entries(categoryCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([category]) => category);
            
            // For each top category, get trending products
            topCategories.forEach(category => {
                const categoryProducts = products.filter(p => 
                    p.category === category && 
                    !viewedProductIds.includes(p.id) &&
                    !excludedIds.includes(p.id) &&
                    (p.trending || p.rating >= 4.0)
                ).slice(0, 5);
                
                categoryProducts.forEach(product => {
                    if (!suggestions.has(product.id)) {
                        suggestions.set(product.id, {
                            product,
                            score: calculateViewBasedScore(product, viewedProducts)
                        });
                    }
                });
            });
            });
            
            return suggestions;
        }

        function calculateViewBasedScore(product, viewedProducts) {
            let score = 0;
            
            // Check category match
            const categoryMatches = viewedProducts.filter(p => p.category === product.category).length;
            if (categoryMatches > 0) {
                score += (categoryMatches / viewedProducts.length) * 40;
            }
            
            // Check price similarity
            const avgViewedPrice = viewedProducts.reduce((sum, p) => sum + p.price, 0) / viewedProducts.length;
            const priceDiff = Math.abs(product.price - avgViewedPrice);
            const priceSimilarity = 1 - Math.min(priceDiff / (avgViewedPrice || 1), 1);
            score += priceSimilarity * 30;
            
            // Check rating
            if (product.rating >= 4.0) score += 15;
            if (product.rating >= 4.5) score += 10;
            
            // Check trending status
            if (product.trending) score += 10;
            if (product.discounted) score += 5;
            
            return score;
        }

        function getCategoryBasedSuggestions(preferredCategories, userWishlist, userCart) {
            const suggestions = new Map();
            
            // Filter out wishlist and cart items
            const excludedIds = [...userWishlist, ...userCart];
            
            // Use last 3 viewed categories for better relevance
            const categoriesToUse = preferredCategories.slice(-3);
            
            categoriesToUse.forEach(category => {
                // Get products from this category that user hasn't viewed
                const categoryProducts = products.filter(p => 
                    p.category === category && 
                    !excludedIds.includes(p.id) &&
                    (p.trending || p.topRated || p.mostSold)
                ).slice(0, 8);
                
                categoryProducts.forEach(product => {
                    if (!suggestions.has(product.id)) {
                        suggestions.set(product.id, {
                            product,
                            score: calculateCategoryBasedScore(product, preferredCategories)
                        });
                    }
                });
            });
            
            return suggestions;
        }

        function calculateCategoryBasedScore(product, preferredCategories) {
            let score = 0;
            
            // Category match score
            if (preferredCategories.includes(product.category)) {
                score += 50;
                
                // Boost if it's a recently preferred category
                const recentIndex = preferredCategories.lastIndexOf(product.category);
                const recencyBoost = Math.max(0, 20 - (recentIndex * 2));
                score += recencyBoost;
            }
            
            // Quality indicators
            if (product.rating >= 4.5) score += 20;
            if (product.rating >= 4.0) score += 10;
            if (product.trending) score += 15;
            if (product.topRated) score += 10;
            if (product.mostSold) score += 5;
            
            // Stock availability bonus
            if (product.stock > 50) score += 5;
            if (product.stock > 10) score += 3;
            
            return score;
        }

        function getPriceBasedSuggestions(priceRange, userWishlist, userCart) {
            const suggestions = new Map();
            const { min, max } = priceRange;
            
            // Filter out wishlist and cart items
            const excludedIds = [...userWishlist, ...userCart];
            
            // If user has no purchase history, use broader range
            const effectiveMin = min > 0 ? Math.max(0, min * 0.5) : 0;
            const effectiveMax = max < 1000 ? Math.min(5000, max * 2) : max;
            
            // Find products in user's price comfort zone
            const priceComfortProducts = products.filter(p => 
                p.price >= effectiveMin && 
                p.price <= effectiveMax &&
                !excludedIds.includes(p.id)
            );
            
            // Sort by value (rating/price ratio) and get top 10
            const valueProducts = priceComfortProducts
                .map(product => ({
                    product,
                    valueScore: (product.rating || 3) / (product.price || 1) * 100,
                    score: calculatePriceBasedScore(product, priceRange)
                }))
                .sort((a, b) => b.valueScore - a.valueScore)
                .slice(0, 10);
            
            valueProducts.forEach(({ product, score }) => {
                if (!suggestions.has(product.id)) {
                    suggestions.set(product.id, {
                        product,
                        score: score
                    });
                }
            });
            
            return suggestions;
        }

        function calculatePriceBasedScore(product, priceRange) {
            let score = 0;
            const { min, max } = priceRange;
            
            // Price proximity score
            const priceDiff = Math.max(
                Math.abs(product.price - min),
                Math.abs(product.price - max)
            );
            const priceSimilarity = 1 - Math.min(priceDiff / (max || 1), 1);
            score += priceSimilarity * 40;
            
            // Value score (rating per dollar)
            const valueScore = (product.rating || 3) / (product.price || 1);
            score += valueScore * 30;
            
            // Popularity indicators
            if (product.trending) score += 15;
            if (product.rating >= 4.0) score += 10;
            if (product.mostSold) score += 5;
            
            return score;
        }

        function getRecentSimilarSuggestions(viewedProductIds, userWishlist, userCart) {
            const suggestions = new Map();
            
            // Filter out wishlist and cart items
            const excludedIds = [...userWishlist, ...userCart];
            
            // Get last 5 viewed products
            const recentViewed = viewedProductIds.slice(-5)
                .map(id => products.find(p => p.id === id))
                .filter(p => p);
            
            if (recentViewed.length === 0) return suggestions;
            
            // For each recently viewed product, find similar ones
            recentViewed.forEach(viewedProduct => {
                const similarProducts = getRelatedProducts(viewedProduct.id);
                
                // Filter out excluded products
                const filteredSimilar = similarProducts.filter(p => 
                    !excludedIds.includes(p.id) && 
                    !viewedProductIds.includes(p.id)
                );
                
                // Boost similarity for more recent views
                const recencyBoost = 5 - recentViewed.indexOf(viewedProduct);
                
                filteredSimilar.forEach((product, index) => {
                    if (!suggestions.has(product.id)) {
                        suggestions.set(product.id, {
                            product,
                            score: calculateSimilarityScore(product, viewedProduct, recencyBoost, index)
                        });
                    } else {
                        // Update score if this product appears from multiple sources
                        const existing = suggestions.get(product.id);
                        existing.score += calculateSimilarityScore(product, viewedProduct, recencyBoost, index) * 0.5;
                    }
                });
            });
            
            return suggestions;
        }

        function calculateSimilarityScore(product, viewedProduct, recencyBoost, position) {
            let score = 0;
            
            // Base similarity (from getRelatedProducts finalScore)
            score += (viewedProduct.rating || 3) * 10;
            
            // Recency boost
            score += recencyBoost * 5;
            
            // Position boost (higher ranked similar products get more points)
            const positionBoost = Math.max(0, 10 - position);
            score += positionBoost;
            
            // Additional similarity factors
            if (product.category === viewedProduct.category) score += 20;
            
            // Price similarity
            const priceDiff = Math.abs(product.price - viewedProduct.price);
            const priceSimilarity = 1 - Math.min(priceDiff / (viewedProduct.price || 1), 1);
            score += priceSimilarity * 15;
            
            // Rating similarity
            if (product.rating >= viewedProduct.rating) score += 10;
            
            return score;
        }

        function getTrendingRelevantSuggestions(preferences, userWishlist, userCart) {
            const suggestions = new Map();
            
            // Filter out wishlist and cart items
            const excludedIds = [...userWishlist, ...userCart];
            
            // Get trending products
            const trendingProducts = products.filter(p => p.trending && !excludedIds.includes(p.id)).slice(0, 20);
            
            // Score them based on relevance to user preferences
            trendingProducts.forEach(product => {
                const relevanceScore = calculateTrendingRelevanceScore(product, preferences);
                
                if (relevanceScore > 30) { // Only include if somewhat relevant
                    suggestions.set(product.id, {
                        product,
                        score: relevanceScore
                    });
                }
            });
            
            return suggestions;
        }

        function calculateTrendingRelevanceScore(product, preferences) {
            let score = 0;
            
            // Category relevance
            if (preferences.categories && preferences.categories.includes(product.category)) {
                score += 40;
            }
            
            // Price range relevance
            if (preferences.priceRange) {
                const { min, max } = preferences.priceRange;
                if (product.price >= min * 0.7 && product.price <= max * 1.3) {
                    score += 30;
                }
            }
            
            // Trending bonus
            if (product.trending) score += 20;
            
            // Quality bonus
            if (product.rating >= 4.5) score += 10;
            if (product.topRated) score += 5;
            
            return score;
        }

        function getComplementarySuggestions(viewedProductIds, userWishlist, userCart) {
            const suggestions = new Map();
            
            // Filter out wishlist and cart items
            const excludedIds = [...userWishlist, ...userCart];
            
            // Get last 3 viewed products
            const recentViewed = viewedProductIds.slice(-3)
                .map(id => products.find(p => p.id === id))
                .filter(p => p);
            
            recentViewed.forEach(viewedProduct => {
                // Find complementary products (different category but related)
                const complementaryCategories = getComplementaryCategories(viewedProduct.category);
                
                complementaryCategories.forEach(category => {
                    const complementaryProducts = products.filter(p => 
                        p.category === category &&
                        p.price <= viewedProduct.price * 2 && // Not too expensive
                        !viewedProductIds.includes(p.id) &&
                        !excludedIds.includes(p.id) &&
                        p.rating >= 4.0
                    ).slice(0, 3);
                    
                    complementaryProducts.forEach(product => {
                        if (!suggestions.has(product.id)) {
                            suggestions.set(product.id, {
                                product,
                                score: calculateComplementaryScore(product, viewedProduct)
                            });
                        }
                    });
                });
            });
            
            return suggestions;
        }

        function getComplementaryCategories(category) {
            const categoryMap = {
                'electronics': ['books', 'sports', 'home'],
                'fashion': ['beauty', 'home', 'sports'],
                'home': ['electronics', 'fashion', 'books'],
                'beauty': ['fashion', 'home', 'electronics'],
                'sports': ['electronics', 'fashion', 'home'],
                'books': ['electronics', 'home', 'fashion'],
                'toys': ['books', 'home', 'electronics']
            };
            
            return categoryMap[category] || ['electronics', 'fashion', 'home'];
        }

        function calculateComplementaryScore(product, viewedProduct) {
            let score = 0;
            
            // Category complementarity
            score += 30;
            
            // Price appropriateness (not more than 2x viewed product)
            if (product.price <= viewedProduct.price * 2) score += 20;
            
            // Quality assurance
            if (product.rating >= 4.0) score += 25;
            if (product.rating >= 4.5) score += 15;
            
            // Popularity
            if (product.trending) score += 10;
            
            return score;
        }

        function getTrendingSuggestions() {
            // For non-logged-in users, show a mix of trending, discounted, and top-rated
            const trending = products.filter(p => p.trending).slice(0, 6);
            const discounted = products.filter(p => p.discounted && p.originalPrice).slice(0, 4);
            const topRated = products.filter(p => p.topRated && !p.trending).slice(0, 4);
            
            // Combine and remove duplicates
            const all = [...trending, ...discounted, ...topRated];
            const unique = [];
            const seen = new Set();
            
            all.forEach(product => {
                if (!seen.has(product.id)) {
                    seen.add(product.id);
                    unique.push(product);
                }
            });
            
            return unique.slice(0, 12);
        }

        function getFallbackSuggestions(existingSuggestions, needed, userWishlist, userCart) {
            const existingIds = new Set(existingSuggestions.map(item => item.product.id));
            
            // Filter out wishlist and cart items
            const excludedIds = [...userWishlist, ...userCart, ...Array.from(existingIds)];
            
            // Get products not already in suggestions
            const availableProducts = products.filter(p => !excludedIds.includes(p.id));
            
            // Score available products for fallback selection
            const scoredProducts = availableProducts.map(product => ({
                product,
                score: calculateFallbackScore(product)
            }));
            
            // Sort by score and take needed amount
            return scoredProducts
                .sort((a, b) => b.score - a.score)
                .slice(0, needed)
                .map(item => ({
                    product: item.product,
                    score: item.score * 0.5 // Reduce score for fallback items
                }));
        }

        function calculateFallbackScore(product) {
            let score = 0;
            
            // Popularity metrics
            if (product.trending) score += 40;
            if (product.topRated) score += 30;
            if (product.mostSold) score += 25;
            
            // Quality metrics
            if (product.rating >= 4.5) score += 20;
            if (product.rating >= 4.0) score += 10;
            
            // Value metrics
            if (product.discounted) score += 15;
            
            // Availability
            if (product.stock > 50) score += 10;
            
            return score;
        }

        // ===== HELPER FUNCTIONS =====

        function addToSuggestionsMap(map, newSuggestions, weight = 1.0) {
            if (!newSuggestions || !newSuggestions.forEach) return;
            
            newSuggestions.forEach(({ product, score }) => {
                const weightedScore = score * weight;
                
                if (map.has(product.id)) {
                    // Update score if product already exists
                    const existing = map.get(product.id);
                    existing.score = Math.max(existing.score, weightedScore);
                } else {
                    // Add new suggestion
                    map.set(product.id, {
                        product,
                        score: weightedScore
                    });
                }
            });
        }

        function cacheUserSuggestions(userId, suggestions) {
            // Create or update cache
            if (!window.userSuggestionsCache) {
                window.userSuggestionsCache = {};
            }
            
            window.userSuggestionsCache[userId] = {
                suggestions: [...suggestions],
                timestamp: Date.now()
            };
        }

        function getCachedSuggestions(userId) {
            if (!window.userSuggestionsCache || !window.userSuggestionsCache[userId]) {
                return null;
            }
            
            const cache = window.userSuggestionsCache[userId];
            const cacheAge = Date.now() - cache.timestamp;
            
            // Cache valid for 5 minutes
            if (cacheAge < 5 * 60 * 1000) {
                return cache.suggestions;
            }
            
            return null;
        }

        // ===== UPDATE USER PREFERENCES FUNCTION =====
        // This function should be called whenever user interacts with products
        function updateUserPreferencesInRealTime(activityType, productId) {
            if (!currentUser) return;
            
            const user = users.find(u => u.id === currentUser.id);
            if (!user) return;
            
            // Initialize preferences if they don't exist
            if (!user.preferences) {
                user.preferences = {
                    categories: [],
                    priceRange: { min: 0, max: 1000 },
                    likedProducts: [],
                    viewedProducts: []
                };
            }
            
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            switch(activityType) {
                case 'product_view':
                    // Add to viewed products (keep only last 20)
                    if (!user.preferences.viewedProducts.includes(productId)) {
                        user.preferences.viewedProducts.push(productId);
                        if (user.preferences.viewedProducts.length > 20) {
                            user.preferences.viewedProducts = user.preferences.viewedProducts.slice(-20);
                        }
                    }
                    
                    // Update category preferences
                    if (!user.preferences.categories.includes(product.category)) {
                        user.preferences.categories.push(product.category);
                        if (user.preferences.categories.length > 10) {
                            user.preferences.categories = user.preferences.categories.slice(-10);
                        }
                    }
                    break;
                    
                case 'product_purchase':
                case 'add_to_cart':
                    // Update price range based on purchased/added items
                    const purchasedItems = orders
                        .filter(o => o.userId === user.id)
                        .flatMap(o => o.items || [])
                        .map(item => products.find(p => p.id === item.productId))
                        .filter(p => p);
                    
                    if (purchasedItems.length > 0) {
                        const prices = purchasedItems.map(p => p.price);
                        user.preferences.priceRange.min = Math.min(...prices) * 0.5;
                        user.preferences.priceRange.max = Math.max(...prices) * 2;
                    }
                    break;
            }
            
            user.updatedAt = new Date().toISOString();
            
            // Invalidate suggestions cache for this user
            if (window.userSuggestionsCache && window.userSuggestionsCache[user.id]) {
                delete window.userSuggestionsCache[user.id];
            }
            
            // Save changes
            saveToLocalStorage();
        }

        // ===== ENHANCED SUGGESTIONS MODAL =====
        function showSuggestionsModal() {
            if (!currentUser) {
                showToast('Please login to see personalized suggestions', 'error');
                showProfileModal();
                return;
            }
            
            // Check cache first
            const cached = getCachedSuggestions(currentUser.id);
            let suggestions;
            
            if (cached) {
                //console.log('Using cached suggestions');
                suggestions = cached;
            } else {
                //console.log('Generating fresh suggestions');
                suggestions = generateSuggestions();
            }
            
            if (suggestions && suggestions.length > 0) {
                renderProducts(suggestions, 'suggestionsProducts');
                showModal('suggestionsModal');
            } else {
                showToast('No suggestions available at the moment', 'info');
            }
        }

        // ===== INTEGRATE WITH EXISTING TRACKING =====
        // Update the existing trackInteraction function to call updateUserPreferencesInRealTime
        function trackInteraction(productId, type, value = 1) {
            let interaction = interactions.find(i => i.productId == productId);
            
            if (!interaction) {
                interaction = {
                    productId: productId,
                    views: 0,
                    clicks: 0,
                    cartAdds: 0,
                    wishlistAdds: 0,
                    purchases: 0,
                    totalViewTime: 0,
                    avgViewTime: 0,
                    conversionRate: 0,
                    lastUpdated: new Date().toISOString()
                };
                interactions.push(interaction);
            }
            
            switch(type) {
                case 'view':
                    interaction.views += value;
                    break;
                case 'click':
                    interaction.clicks += value;
                    break;
                case 'cartAdd':
                    interaction.cartAdds += value;
                    break;
                case 'wishlistAdd':
                    interaction.wishlistAdds += value;
                    break;
                case 'purchase':
                    interaction.purchases += value;
                    break;
                case 'viewTime':
                    interaction.totalViewTime += value;
                    interaction.avgViewTime = interaction.views > 0 ? 
                        Math.round(interaction.totalViewTime / interaction.views) : 0;
                    break;
            }
            
            // Calculate conversion rate
            if (interaction.clicks > 0) {
                interaction.conversionRate = ((interaction.purchases / interaction.clicks) * 100).toFixed(2);
            }
            
            interaction.lastUpdated = new Date().toISOString();
            
            // Also update product metadata
            const product = products.find(p => p.id == productId);
            if (product && product.metadata) {
                switch(type) {
                    case 'view':
                        product.metadata.views += value;
                        break;
                    case 'click':
                        product.metadata.clicks += value;
                        break;
                    case 'cartAdd':
                        product.metadata.cartAdds += value;
                        break;
                    case 'wishlistAdd':
                        product.metadata.wishlistAdds += value;
                        break;
                    case 'purchase':
                        product.metadata.purchases += value;
                        break;
                    case 'viewTime':
                        product.metadata.totalViewTime += value;
                        break;
                }
            }
            
            // Update user preferences in real time
            updateUserPreferencesInRealTime(type, productId);
        }

        // Real-time suggestions update function
        function updateSuggestionsBasedOnInteraction(productId, interactionType) {
            if (!currentUser) return;
            
            const user = users.find(u => u.id === currentUser.id);
            if (!user) return;
            
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            // Initialize suggestions history if not exists
            if (!user.suggestionsHistory) {
                user.suggestionsHistory = [];
            }
            
            // Record this interaction for future suggestions
            const suggestionRecord = {
                productId: productId,
                category: product.category,
                interactionType: interactionType,
                timestamp: new Date().toISOString(),
                price: product.price,
                tags: product.tags || []
            };
            
            // Keep only last 100 interactions
            user.suggestionsHistory.push(suggestionRecord);
            if (user.suggestionsHistory.length > 100) {
                user.suggestionsHistory = user.suggestionsHistory.slice(-100);
            }
            
            // Update user preferences based on this interaction
            if (!user.preferences) {
                user.preferences = {
                    categories: [],
                    priceRange: { min: 0, max: 1000 },
                    likedProducts: [],
                    viewedProducts: []
                };
            }
            
            // Update category preference
            if (!user.preferences.categories.includes(product.category)) {
                user.preferences.categories.push(product.category);
                // Keep only last 10 categories
                if (user.preferences.categories.length > 10) {
                    user.preferences.categories = user.preferences.categories.slice(-10);
                }
            }
            
            // Update price range based on interactions
            if (interactionType === 'purchase' || interactionType === 'cartAdd') {
                const interactionPrices = user.suggestionsHistory
                    .filter(r => r.interactionType === 'purchase' || r.interactionType === 'cartAdd')
                    .map(r => r.price);
                
                if (interactionPrices.length > 0) {
                    const minPrice = Math.min(...interactionPrices);
                    const maxPrice = Math.max(...interactionPrices);
                    
                    user.preferences.priceRange.min = Math.max(0, minPrice * 0.7);
                    user.preferences.priceRange.max = maxPrice * 1.3;
                }
            }
            
            // Update viewed products
            if (!user.preferences.viewedProducts.includes(productId)) {
                user.preferences.viewedProducts.push(productId);
                if (user.preferences.viewedProducts.length > 20) {
                    user.preferences.viewedProducts = user.preferences.viewedProducts.slice(-20);
                }
            }
            
            // Update liked products for wishlist
            if (interactionType === 'wishlistAdd') {
                if (!user.preferences.likedProducts.includes(productId)) {
                    user.preferences.likedProducts.push(productId);
                }
            }
            
            user.updatedAt = new Date().toISOString();
            
            // Invalidate suggestions cache
            if (window.userSuggestionsCache && window.userSuggestionsCache[currentUser.id]) {
                delete window.userSuggestionsCache[currentUser.id];
            }
            
            saveToLocalStorage();
            //console.log('Suggestions updated based on interaction:', interactionType);
        }

        // ===== ADMIN PANEL =====
        function showAdminPanel() {
            const password = prompt('Enter admin password:');
            
            if (password === ADMIN_PASSWORD) {
                // Create admin user if not exists
                if (!currentUser || !currentUser.isAdmin) {
                    const adminUser = users.find(u => u.email === 'admin@shopure.com');
                    if (adminUser) {
                        currentUser = {
                            id: adminUser.id,
                            name: adminUser.name,
                            email: adminUser.email,
                            phone: adminUser.phone,
                            address: adminUser.address,
                            isAdmin: true
                        };
                    } else {
                        showToast('Admin user not found', 'error');
                        return;
                    }
                }
                navigateTo('admin');
            } else {
                showToast('Invalid admin password', 'error');
            }
        }

        function loadAdminPanel() {
            if (!currentUser?.isAdmin) {
                showToast('Admin access required', 'error');
                navigateTo('home');
                return;
            }
            
            // Update stats
            updateAdminStats();
            
            // Load analytics tables
            loadProductAnalytics();
            loadUserAnalytics();
            loadRecentActivities();
            
            // Initialize charts
            initCharts();
        }

        function updateAdminStats() {
            document.getElementById('adminTotalUsers').textContent = users.length;
            document.getElementById('adminTotalProducts').textContent = products.length;
            document.getElementById('adminTotalOrders').textContent = orders.length;
            
            // Calculate total revenue
            const totalRevenue = orders.reduce((sum, order) => sum + (order.total || 0), 0);
            document.getElementById('adminTotalRevenue').textContent = `<b><strong>৳</strong></b>${totalRevenue.toFixed(2)}`;
            
            // Calculate average order value
            const avgOrderValue = orders.length > 0 ? totalRevenue / orders.length : 0;
            document.getElementById('adminAvgOrder').textContent = `<b><strong>৳</strong></b>${avgOrderValue.toFixed(2)}`;
            
            // Calculate conversion rate
            const totalClicks = interactions.reduce((sum, i) => sum + (i.clicks || 0), 0);
            const totalPurchases = interactions.reduce((sum, i) => sum + (i.purchases || 0), 0);
            const conversionRate = totalClicks > 0 ? (totalPurchases / totalClicks * 100) : 0;
            document.getElementById('adminConversion').textContent = `${conversionRate.toFixed(2)}%`;
            
            // Calculate user engagement
            const totalViewTime = interactions.reduce((sum, i) => sum + (i.totalViewTime || 0), 0) / 1000; // in seconds
            const avgSessionTime = activities.length > 0 ? 
                activities.reduce((sum, a) => sum + (a.duration || 0), 0) / activities.length / 1000 : 0;
            
            // Calculate real changes (based on last month)
            const oneMonthAgo = new Date();
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
            
            const recentOrders = orders.filter(o => new Date(o.createdAt) > oneMonthAgo);
            const oldOrders = orders.filter(o => new Date(o.createdAt) <= oneMonthAgo);
            
            const recentRevenue = recentOrders.reduce((sum, o) => sum + (o.total || 0), 0);
            const oldRevenue = oldOrders.reduce((sum, o) => sum + (o.total || 0), 0);
            
            const revenueChange = oldRevenue > 0 ? ((recentRevenue - oldRevenue) / oldRevenue * 100) : 100;
            const orderChange = oldOrders.length > 0 ? 
                ((recentOrders.length - oldOrders.length) / oldOrders.length * 100) : 100;
            
            // Update change indicators
            const changes = {
                users: '+12%',
                products: '+5%',
                orders: `${orderChange >= 0 ? '+' : ''}${orderChange.toFixed(1)}%`,
                revenue: `${revenueChange >= 0 ? '+' : ''}${revenueChange.toFixed(1)}%`,
                avgOrder: '+8%',
                conversion: '-2%'
            };
            
            // Update DOM with calculated values
            document.getElementById('adminUsersChange').textContent = changes.users;
            document.getElementById('adminProductsChange').textContent = changes.products;
            document.getElementById('adminOrdersChange').textContent = changes.orders;
            document.getElementById('adminRevenueChange').textContent = changes.revenue;
            document.getElementById('adminAvgOrderChange').textContent = changes.avgOrder;
            document.getElementById('adminConversionChange').textContent = changes.conversion;
            
            // Update color based on positive/negative change
            const updateChangeColor = (elementId, value) => {
                const element = document.getElementById(elementId);
                if (element) {
                    const isPositive = value.includes('+');
                    element.className = `admin-stat-change ${isPositive ? 'positive' : 'negative'}`;
                }
            };
            
            updateChangeColor('adminOrdersChange', changes.orders);
            updateChangeColor('adminRevenueChange', changes.revenue);
            updateChangeColor('adminConversionChange', changes.conversion);
        }

        function loadProductAnalytics() {
            const tableBody = document.getElementById('productAnalyticsBody');
            tableBody.innerHTML = '';
            
            interactions.forEach(interaction => {
                const product = products.find(p => p.id === interaction.productId);
                if (!product) return;
                
                const viewTime = formatTime(interaction.avgViewTime);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <img src="${product.images[0]}" alt="${product.name}" style="width: 40px; height: 40px; border-radius: var(--radius-sm); object-fit: cover;">
                            <div>
                                <div style="font-weight: 600;">${product.name}</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">${product.category}</div>
                            </div>
                        </div>
                    </td>
                    <td>${interaction.views.toLocaleString()}</td>
                    <td>${interaction.clicks.toLocaleString()}</td>
                    <td>${interaction.wishlistAdds.toLocaleString()}</td>
                    <td>${interaction.cartAdds.toLocaleString()}</td>
                    <td>${interaction.purchases.toLocaleString()}</td>
                    <td>${viewTime}</td>
                    <td>
                        <div class="admin-badge ${interaction.conversionRate > 5 ? 'badge-success' : interaction.conversionRate > 2 ? 'badge-warning' : 'badge-error'}">
                            ${interaction.conversionRate}%
                        </div>
                    </td>
                    <td>
                        <div class="admin-actions">
                            <button class="admin-action-btn" title="Edit" data-product-id="${product.id}">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="admin-action-btn delete" title="Delete" data-product-id="${product.id}">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </td>
                `;
                
                // Add event listeners to action buttons
                row.querySelector('[title="Edit"]').addEventListener('click', () => {
                    editProduct(product.id);
                });
                
                row.querySelector('[title="Delete"]').addEventListener('click', () => {
                    if (confirm(`Are you sure you want to delete "${product.name}"?`)) {
                        deleteProduct(product.id);
                    }
                });
                
                tableBody.appendChild(row);
            });
        }

        function loadUserAnalytics() {
            const tableBody = document.getElementById('userAnalyticsBody');
            tableBody.innerHTML = '';
            
            users.forEach(user => {
                const userOrders = orders.filter(o => o.userId === user.id);
                const totalSpent = userOrders.reduce((sum, order) => sum + order.total, 0);
                const avgOrderValue = userOrders.length > 0 ? totalSpent / userOrders.length : 0;
                const lastActivity = user.activityStats?.lastActivity ? 
                    formatTimeAgo(new Date(user.activityStats.lastActivity)) : 'Never';
                const sessionTime = formatTime(user.activityStats?.totalTimeSpent || 0);
                
                const viewedProducts = user.preferences?.viewedProducts?.length || 0;
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="width: 40px; height: 40px; border-radius: 50%; background: var(--gradient-primary); display: flex; align-items: center; justify-content: center; color: var(--text-white); font-weight: 600;">
                                ${user.name.charAt(0)}
                            </div>
                            <div>
                                <div style="font-weight: 600;">${user.name}</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">${user.email}</div>
                            </div>
                        </div>
                    </td>
                    <td>${userOrders.length}</td>
                    <td><b><strong>৳</strong></b>${totalSpent.toFixed(2)}</td>
                    <td><b><strong>৳</strong></b>${avgOrderValue.toFixed(2)}</td>
                    <td>${lastActivity}</td>
                    <td>${sessionTime}</td>
                    <td>${viewedProducts}</td>
                    <td>
                        <div class="admin-badge ${user.isAdmin ? 'badge-info' : 'badge-success'}">
                            ${user.isAdmin ? 'Admin' : 'User'}
                        </div>
                    </td>
                    <td>
                        <div class="admin-actions">
                            <button class="admin-action-btn" title="View Details" data-user-id="${user.id}">
                                <i class="fas fa-eye"></i>
                            </button>
                            ${!user.isAdmin ? `
                                <button class="admin-action-btn delete" title="Delete User" data-user-id="${user.id}">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                        </div>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        function loadRecentActivities() {
            const tableBody = document.getElementById('recentActivitiesBody');
            tableBody.innerHTML = '';
            
            const recentActivities = activities.slice(-20).reverse();
            
            recentActivities.forEach(activity => {
                const user = users.find(u => u.id === activity.userId);
                const product = products.find(p => p.id === activity.productId);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${user?.name || 'Guest'}</td>
                    <td>
                        <div class="admin-badge ${activity.type.includes('view') ? 'badge-info' : 
                            activity.type.includes('cart') ? 'badge-warning' : 
                            activity.type.includes('purchase') ? 'badge-success' : 'badge-info'}">
                            ${activity.type.replace('_', ' ')}
                        </div>
                    </td>
                    <td>${product?.name || '-'}</td>
                    <td>${formatTimeAgo(new Date(activity.timestamp))}</td>
                    <td>${activity.duration ? formatTime(activity.duration) : '-'}</td>
                    <td>${activity.ipAddress}</td>
                    <td>${activity.device?.substring(0, 30)}...</td>
                `;
                tableBody.appendChild(row);
            });
        }

        function initCharts() {
            renderSalesChart();
            renderCategoriesChart();
            renderActivityChart();
        }

        function renderSalesChart() {
            const salesChart = document.getElementById('salesChart');
            if (!salesChart) return;

            const days = [];
            const totals = [];
            const today = new Date();
            for (let i = 6; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(today.getDate() - i);
                const key = d.toISOString().slice(0, 10);
                const label = d.toLocaleDateString(undefined, { weekday: 'short' });
                days.push({ key, label });

                const dayTotal = orders
                    .filter(o => (o.createdAt || o.date || '').slice(0,10) === key)
                    .reduce((sum, o) => sum + (Number(o.total) || 0), 0);

                totals.push(dayTotal);
            }

            const max = Math.max(...totals, 1);
            salesChart.innerHTML = `
                <div style="display:flex; flex-direction:column; height:100%;">
                    <div style="flex:1; display:flex; align-items:flex-end; gap:6px; padding:1rem;">
                        ${totals.map(v => {
                            const h = Math.round((v / max) * 100);
                            return `<div style="flex:1; background: var(--primary-color); border-radius: 6px 6px 0 0; height:${h}%; min-height:4px;" title="<b><strong>৳</strong></b>${v.toFixed(2)}"></div>`;
                        }).join('')}
                    </div>
                    <div style="display:flex; justify-content:space-between; padding:0 1rem 0.75rem; font-size:0.75rem; color:var(--text-secondary);">
                        ${days.map(d => `<span>${d.label}</span>`).join('')}
                    </div>
                    <div style="padding: 0 1rem 1rem; font-size:0.85rem; color: var(--text-secondary); display:flex; justify-content:space-between;">
                        <span>Last 7 days revenue</span>
                        <strong style="color: var(--text-primary)"><b><strong>৳</strong></b>${totals.reduce((a,b)=>a+b,0).toFixed(2)}</strong>
                    </div>
                </div>
            `;
        }

        function renderCategoriesChart() {
            const categoriesChart = document.getElementById('categoriesChart');
            if (!categoriesChart) return;

            const counts = {};
            if (orders && orders.length > 0) {
                orders.forEach(order => {
                    (order.items || []).forEach(item => {
                        const product = products.find(p => p.id === item.productId);
                        const cat = (product?.category || 'other').toLowerCase();
                        counts[cat] = (counts[cat] || 0) + (Number(item.quantity) || 1);
                    });
                });
            } else {
                products.forEach(p => {
                    const cat = (p.category || 'other').toLowerCase();
                    counts[cat] = (counts[cat] || 0) + 1;
                });
            }

            const entries = Object.entries(counts)
                .sort((a,b)=>b[1]-a[1])
                .slice(0, 8);

            const total = entries.reduce((s, [,c]) => s + c, 0) || 1;

            categoriesChart.innerHTML = `
                <div style="display:flex; flex-direction:column; gap:0.75rem; padding:1rem;">
                    ${entries.map(([cat, c]) => {
                        const pct = Math.round((c / total) * 100);
                        return `
                            <div>
                                <div style="display:flex; justify-content:space-between; margin-bottom:0.25rem;">
                                    <span style="text-transform:capitalize">${cat}</span>
                                    <span>${c} (${pct}%)</span>
                                </div>
                                <div style="height:8px; background: var(--surface-color); border-radius:999px; overflow:hidden;">
                                    <div style="width:${pct}%; height:100%; background: var(--primary-color);"></div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function renderActivityChart() {
            const activityChart = document.getElementById('activityChart');
            if (!activityChart) return;

            const now = Date.now();
            const last24h = (activities || []).filter(a => {
                const t = new Date(a.timestamp || a.createdAt || a.date || 0).getTime();
                return t && (now - t) <= 24 * 60 * 60 * 1000;
            });

            const byType = {};
            last24h.forEach(a => {
                const t = (a.type || 'other');
                byType[t] = (byType[t] || 0) + 1;
            });

            const entries = Object.entries(byType).sort((a,b)=>b[1]-a[1]).slice(0, 8);
            const max = Math.max(...entries.map(([,c])=>c), 1);

            activityChart.innerHTML = `
                <div style="display:flex; flex-direction:column; height:100%;">
                    <div style="flex:1; display:flex; align-items:flex-end; gap:8px; padding:1rem;">
                        ${entries.map(([t, c]) => {
                            const h = Math.round((c / max) * 100);
                            return `<div style="flex:1; background: var(--info-color); border-radius: 6px 6px 0 0; height:${h}%; min-height:4px;" title="${t}: ${c}"></div>`;
                        }).join('')}
                    </div>
                    <div style="display:flex; justify-content:space-between; gap:8px; padding:0 1rem 1rem; font-size:0.7rem; color:var(--text-secondary);">
                        ${entries.map(([t]) => `<span style="flex:1; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${t.replace(/_/g,' ')}</span>`).join('')}
                    </div>
                    <div style="padding:0 1rem 1rem; font-size:0.85rem; color:var(--text-secondary); display:flex; justify-content:space-between;">
                        <span>Events (last 24h)</span>
                        <strong style="color: var(--text-primary)">${last24h.length}</strong>
                    </div>
                </div>
            `;
        }

        // ===== MODAL FUNCTIONS =====
        function showContactModal() {
            showModal('contactModal');
        }

        function showChatModal() {
            if (!currentUser) {
                showToast('Please login to start chat', 'error');
                showProfileModal();
                return;
            }
            
            showModal('chatModal');
            
            // Focus on chat input
            setTimeout(() => {
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.focus();
                }
            }, 100);
        }

        // Already defined earlier, but just in case:
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

// ===== CHAT MANAGEMENT =====
let chatMessages = JSON.parse(localStorage.getItem('shopure_chat_messages')) || [];
let chatTypingTimeout = null;

function showChatModal() {
    if (!currentUser) {
        showToast('Please login to start chat', 'error');
        showProfileModal();
        return;
    }
    
    // Load chat messages
    loadChatMessages();
    
    showModal('chatModal');
    
    // Focus on chat input
    setTimeout(() => {
        const chatInput = document.getElementById('chatInput');
        if (chatInput) {
            chatInput.focus();
        }
    }, 100);
    
    // Mark all messages as read
    markChatMessagesAsRead();
}

function loadChatMessages() {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    
    // Clear container
    chatMessagesContainer.innerHTML = '';
    
    // Add welcome message if no messages exist
    if (chatMessages.length === 0) {
        addWelcomeMessage();
        return;
    }
    
    // Group messages by date
    const groupedMessages = groupMessagesByDate(chatMessages);
    
    // Render messages
    Object.keys(groupedMessages).forEach(date => {
        // Add date separator
        if (date !== 'today') {
            const timestampElement = document.createElement('div');
            timestampElement.className = 'chat-timestamp';
            timestampElement.innerHTML = `<span>${formatChatDate(date)}</span>`;
            chatMessagesContainer.appendChild(timestampElement);
        }
        
        // Add messages for this date
        groupedMessages[date].forEach(message => {
            addMessageToChat(message, false);
        });
    });
    
    // Scroll to bottom
    scrollChatToBottom();
}

function addWelcomeMessage() {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    
    const welcomeMessage = {
        id: 'welcome',
        sender: 'bot',
        content: 'Welcome to ShoPure Live Chat! How can we help you today?',
        timestamp: new Date().toISOString(),
        status: 'read'
    };
    
    addMessageToChat(welcomeMessage, true);
}

function addMessageToChat(message, scrollToBottom = true) {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${message.sender === 'user' ? 'message-outgoing' : 'message-incoming'}`;
    messageElement.dataset.messageId = message.id;
    
    // Format time
    const time = formatChatTime(message.timestamp);
    
    messageElement.innerHTML = `
        <div class="message-content">${escapeHtml(message.content)}</div>
        <div class="message-footer">
            <div class="message-time">${message.content}</div>
            ${message.sender === 'user' ? `
                <div class="message-status ${message.status || 'sent'}">
                    ${getStatusIcon(message.status)}
                </div>
            ` : ''}
        </div>
    `;
    
    chatMessagesContainer.appendChild(messageElement);
    
    if (scrollToBottom) {
        scrollChatToBottom();
    }
}

function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const chatMessagesContainer = document.getElementById('chatMessages');
    
    if (!chatInput || !chatMessagesContainer) return;
    
    const message = chatInput.value.trim();
    //console.log(message);
    
    if (!message) {
        showToast('Please enter a message', 'error');
        return;
    }
    
    // Create user message object
    const userMessage = {
        id: Date.now(),
        sender: 'user',
        content: message,
        timestamp: new Date().toISOString(),
        status: 'sent'
    };
    
    // Add user message to chat
    addMessageToChat(userMessage);
    
    // Clear input
    chatInput.value = '';
    
    // Save to chat history
    chatMessages.push(userMessage);
    saveChatMessages();
    
    // Show typing indicator
    showTypingIndicator();
    
    // Simulate bot response after delay
    setTimeout(sendBotResponse(message), 1500);
}

function showTypingIndicator() {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    
    // Remove existing typing indicator
    const existingIndicator = document.getElementById('typingIndicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    // Create new typing indicator
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typingIndicator';
    typingIndicator.className = 'typing-indicator';
    typingIndicator.innerHTML = `
        <span class="typing-dots">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <span style="font-size: 0.875rem; color: var(--text-secondary); margin-left: 0.5rem;">
            Support is typing...
        </span>
    `;
    
    chatMessagesContainer.appendChild(typingIndicator);
    scrollChatToBottom();
}








class UltraTextMatcherTF {
  // =====================================================================
  // SECTION A — Construction & Defaults
  // =====================================================================

  constructor(targets = null, options = null) {
    this._version = "2.0.0";
    this._inited = false;

    // TFJS / Model
    this._model = null;         // USE model instance
    this._backend = null;       // backend string
    this._modelName = "universal-sentence-encoder";
    this._tfReady = false;

    // Targets storage (supports live updates)
    this._targets = [];         // normalized objects: { text, meta, id }
    this._targetText = [];      // parallel
    this._targetMeta = [];      // parallel
    this._targetIds = [];       // parallel

    // Indexes / stats
    this._bm25 = null;          // BM25 corpus stats
    this._lastBm25BuildAt = 0;

    // Caches
    this._featureCache = new Map();        // key: "T:<index>" -> features
    this._queryFeatureCache = new Map();   // key: "Q:<query>" -> features
    this._embedLRU = new Map();            // key: embeddingKey -> { vec: Float32Array, bytes, lastUsed, dim }
    this._embedLRUBytes = 0;

    // Options
    this._options = this._deepMerge(this._defaultOptions(), options || {});
    this._normalizeFactorWeights(this._options);

    // Attach targets if provided
    if (targets) this.setTargets(targets);
  }

  _defaultOptions() {
    return {
      // ------------------------------------------------------------
      // Debug controls
      // ------------------------------------------------------------
      debug: {
        enabled: false,           // master
        logTimings: true,
        logWarnings: true,
        logBatches: false,
        logCache: false,
        logTopK: false,
        logFactorBreakdown: false,
        groupCollapsed: true
      },

      // ------------------------------------------------------------
      // Runtime weight focus knobs (multipliers)
      // If you manually set factor weights, those values are used,
      // then focus multipliers further amplify them.
      // ------------------------------------------------------------
      focus: {
        favorMeaning: 1.0,
        favorNumbers: 1.0,
        favorPrefix: 1.0,
        favorEmoji: 1.0,
        favorGrammar: 1.0,
        favorMorphology: 1.0,
        favorTokens: 1.0,
        favorPunctuation: 1.0,
        favorCase: 1.0
      },

      // ------------------------------------------------------------
      // Performance controls
      // ------------------------------------------------------------
      perf: {
        topK: 5,
        maxTargetsSafety: 200000,
        semanticBatchSize: 64,
        microYield: {
          enabled: true,
          everyItems: 64,         // yield after this many candidates
          strategy: "timeout0"    // "timeout0" | "raf" | "idle"
        },
        timeBudgetMs: 0,          // 0 disables. Otherwise soft stop.
        nonSemanticFastPath: false // if true, skip some heavy string ops for very large corpora
      },

      // ------------------------------------------------------------
      // TFJS controls
      // ------------------------------------------------------------
      tfjs: {
        preferredBackends: ["webgl", "wasm", "cpu"],
        forceBackend: "",
        warmup: true,
        modelUrl: "",     // optional; usually unnecessary
        // if wasm is chosen, user must load tfjs-backend-wasm separately; we do not auto-load.
        // we simply attempt to setBackend in priority order.
      },

      // ------------------------------------------------------------
      // Cache controls
      // ------------------------------------------------------------
      cache: {
        featureCache: true,
        queryFeatureCache: true,
        embeddingCache: true,
        embeddingCacheKey: "text",   // "text" | "hash"
        embeddingCacheLimitMB: 128,
        autoClearAfterMatch: false,
        clearEmbedCacheAfterMatch: false,
        clearFeatureCacheAfterMatch: false,
        clearQueryCacheAfterMatch: false
      },

      // ------------------------------------------------------------
      // Metadata filtering/boosting (multi-purpose string search)
      // - NO recency by default
      // - Uses importance signals: priority/rank/quality/weight
      // ------------------------------------------------------------
      meta: {
        enabled: true,

        // Filter can be:
        // - null
        // - function(meta, text, index) => boolean
        // - object rules:
        //   { allowTags?, blockTags?, allowAnyTags?, blockAnyTags?, allowTypes?, blockTypes?, allowChannels?, blockChannels?,
        //     requireFields?, minPriority?, maxPriority?, minQuality?, maxQuality? }
        filter: null,

        // Boost can be:
        // - null
        // - function(meta, text, index, queryFeatures) => { addScore01?, multScore?, notes? }
        // - object rules:
        //   { tagBoost?, typeBoost?, channelBoost?, authorBoost?, importanceField?, importanceMode?, importanceScale?, clampAdd?, clampMult? }
        //
        // importanceField defaults: "priority" then "rank" then "quality" then "weight"
        // importanceMode: "linear" | "sigmoid"
        // importanceScale: how strongly importance affects addScore01
        boost: {
          importanceField: "auto",
          importanceMode: "sigmoid",
          importanceScale: 0.10,
          tagBoost: null,
          typeBoost: null,
          channelBoost: null,
          authorBoost: null,
          clampAdd: 0.25,
          clampMultMin: 0.70,
          clampMultMax: 1.35
        },

        includeMetaInDiagnostics: false
      },

      // ------------------------------------------------------------
      // Fusion: robust weighted power mean + penalties + sigmoid confidence
      // ------------------------------------------------------------
      fusion: {
        powerMeanP: 2.8,

        contradiction: {
          enabled: true,
          semanticVsNumeric: {
            enabled: true,
            semanticHigh: 0.80,
            numericLow: 0.25,
            penaltyMax: 0.35
          },
          semanticVsTokens: {
            enabled: true,
            semanticHigh: 0.82,
            tokenLow: 0.20,
            penaltyMax: 0.18
          }
        },

        confidence: {
          center: 0.62,
          steepness: 9.5,
          agreementBoost: 0.12,
          dispersionPenalty: 0.14,
          capIfSemanticLow: true
        }
      },

      // ------------------------------------------------------------
      // 16 Mandatory factor weights
      // IMPORTANT: raw exactness should NOT dominate
      // ------------------------------------------------------------
      factorWeights: {
        // 1
        numericSimilarity: 0.85,
        // 2
        alphabeticSimilarity: 0.35,
        // 3
        upperCasePatternSimilarity: 0.14,
        // 4
        lowerCasePatternSimilarity: 0.10,
        // 5
        spacesSimilarity: 0.12,
        // 6
        punctuationSimilarity: 0.18,
        // 7 (MOST IMPORTANT)
        humanMeaningSimilarity: 2.75,
        // 8
        wordsSimilarity: 1.20,
        // 9
        wordsSimilarityNoGrammar: 0.75,
        // 10
        wordsSimilarityWithGrammar: 0.50,
        // 11
        emojiSimilarity: 0.22,
        // 12
        firstSectionSimilarity: 0.45,
        // 13
        secondSectionSimilarity: 0.30,
        // 14
        followGrammarSimilarity: 0.62,
        // 15
        verbSimilarity: 0.36,
        // 16
        auxiliaryVerbSimilarity: 0.26
      },

      // ------------------------------------------------------------
      // Factor-specific configs
      // ------------------------------------------------------------
      factorConfig: {
        numeric: {
          maxNumbers: 64,
          relativeEps: 1e-6,
          closenessAlpha: 0.85
        },

        alphabetic: {
          charNGramN: 3,
          charNGramMax: 5000,
          editDistanceMaxLen: 900
        },

        casePattern: {
          bins: 24
        },

        spaces: {
          runMax: 80,
          bins: 24
        },

        punctuation: {
          trackPositions: true,
          maxPositions: 256,
          bins: 24
        },

        semantic: {
          enableFloor: true,
          cosineFloor: -0.15
        },

        words: {
          minTokenLen: 2,
          maxTokens: 256,
          maxTokenGrams: 4096,
          tokenGramN: 2,
          bm25: { k1: 1.2, b: 0.75 }
        },

        nogrammar: {
          stripSuffixes: ["ing", "ed", "es", "s"],
          minRootLen: 3
        },

        grammarWords: {
          morphologySensitivity: 0.70,
          maxEditDistanceLen: 240
        },

        emoji: {
          maxEmoji: 64,
          positionalWeight: 0.35,
          bins: 24
        },

        sections: {
          firstChars: 140,
          secondChars: 170,
          jaroPrefixScale: 0.10
        },

        grammar: {
          maxSentences: 12,
          maxClauseLen: 240,
          svoWindow: 7,
          punctuationPatternWeight: 0.35,
          posHeuristicWeight: 0.35,
          functionWordWeight: 0.30
        },

        verbs: {
          maxVerbs: 64,
          positionalWeight: 0.30,
          bins: 24
        },

        aux: {
          positionalWeight: 0.25,
          bins: 24
        }
      }
    };
  }

  // =====================================================================
  // SECTION B — Public API
  // =====================================================================

  async init() {
    if (this._inited) return;

    if (typeof tf === "undefined") {
      throw new Error("TensorFlow.js (tf) not found. Load https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest");
    }
    if (typeof use === "undefined") {
      throw new Error("Universal Sentence Encoder (use) not found. Load https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@latest");
    }

    // Ensure TFJS is ready
    await tf.ready();
    this._tfReady = true;

    // Pick backend
    const opt = this._options;
    let backend = opt.tfjs.forceBackend || "";
    if (!backend) backend = await this._pickBestBackend(opt.tfjs.preferredBackends);

    if (backend) {
      try {
        await tf.setBackend(backend);
        await tf.ready();
      } catch (e) {
        this._dWarn(opt, "Failed to set backend:", backend, e);
      }
    }

    this._backend = tf.getBackend();

    // Load USE
    const t0 = this._now();
    try {
      if (opt.tfjs.modelUrl && typeof use.load === "function") {
        // Some versions accept config; fallback to no-arg
        try {
          this._model = await use.load({ modelUrl: opt.tfjs.modelUrl });
        } catch (_e) {
          this._model = await use.load();
        }
      } else {
        this._model = await use.load();
      }
    } catch (e) {
      throw new Error("Failed to load USE model. Ensure you are ONLINE and the USE script is loaded. " + e);
    }
    const t1 = this._now();

    // Warmup (safe)
    if (opt.tfjs.warmup) {
      try {
        await this._warmupModel(opt);
      } catch (e) {
        // Non-fatal
        this._dWarn(opt, "Warmup failed (non-fatal):", e);
      }
    }

    this._inited = true;
    this._dInfo(opt, `init() done. backend=${this._backend} model=${this._modelName} ms=${(t1 - t0).toFixed(1)}`);
  }

  setTargets(list) {
    const arr = Array.isArray(list) ? list : [];
    const opt = this._options;

    if (arr.length > opt.perf.maxTargetsSafety) {
      throw new Error(`Too many targets (${arr.length}). Safety limit: ${opt.perf.maxTargetsSafety}`);
    }

    this._targets = [];
    this._targetText = [];
    this._targetMeta = [];
    this._targetIds = [];

    for (let i = 0; i < arr.length; i++) {
      const it = arr[i];
      const norm = this._normalizeTargetItem(it);
      this._targets.push(norm);
      this._targetText.push(norm.text);
      this._targetMeta.push(norm.meta);
      this._targetIds.push(norm.id);
    }

    // Rebuild BM25
    this._bm25 = this._buildBM25(this._targetText, opt.factorConfig.words);
    this._lastBm25BuildAt = Date.now();

    // Clear index-bound caches
    if (opt.cache.featureCache) this._featureCache.clear();
  }

  setOptions(partial) {
    this._options = this._deepMerge(this._options, partial || {});
    this._normalizeFactorWeights(this._options);
  }

  // Live update: add
  addTarget(item) {
    const opt = this._options;
    if (this._targets.length + 1 > opt.perf.maxTargetsSafety) return -1;

    const norm = this._normalizeTargetItem(item);
    const idx = this._targets.length;

    this._targets.push(norm);
    this._targetText.push(norm.text);
    this._targetMeta.push(norm.meta);
    this._targetIds.push(norm.id);

    // BM25 rebuild for correctness (can be optimized)
    this._bm25 = this._buildBM25(this._targetText, opt.factorConfig.words);
    this._lastBm25BuildAt = Date.now();

    return idx;
  }

  // Live update: remove by id
  removeTargetById(id) {
    if (!id) return false;
    const idx = this._targetIds.indexOf(id);
    if (idx < 0) return false;

    // Remove
    this._targets.splice(idx, 1);
    this._targetText.splice(idx, 1);
    this._targetMeta.splice(idx, 1);
    this._targetIds.splice(idx, 1);

    // Clear feature cache (indexes changed)
    if (this._options.cache.featureCache) this._featureCache.clear();

    // BM25 rebuild
    this._bm25 = this._buildBM25(this._targetText, this._options.factorConfig.words);
    this._lastBm25BuildAt = Date.now();

    return true;
  }

  // Live update: update by id
  updateTargetById(id, newItem) {
    if (!id) return false;
    const idx = this._targetIds.indexOf(id);
    if (idx < 0) return false;

    const prev = this._targets[idx];
    const norm = this._normalizeTargetItem(newItem);

    // Preserve id if not provided
    norm.id = prev.id;

    this._targets[idx] = norm;
    this._targetText[idx] = norm.text;
    this._targetMeta[idx] = norm.meta;

    // Clear feature cache entry for that index
    if (this._options.cache.featureCache) this._featureCache.delete(this._tKey(idx));

    // BM25 rebuild
    this._bm25 = this._buildBM25(this._targetText, this._options.factorConfig.words);
    this._lastBm25BuildAt = Date.now();

    return true;
  }

  clearCaches() {
    this._featureCache.clear();
    this._queryFeatureCache.clear();
    this._embedLRUClear();
  }

  disposeModel() {
    // USE model may not expose dispose reliably; drop reference
    this._model = null;
    this._inited = false;
    this.clearCaches();
  }

  // Main match
    async match(query, targetsOverride = null, optionsOverride = null) {
    const tStart = this._now();

    // 1️⃣ merge options
    let opt = this._deepMerge(this._options, optionsOverride || {});
    this._normalizeFactorWeights(opt);

    // 2️⃣ 🔒 PERF SAFETY BLOCK (MUST BE HERE)
    opt.perf = opt.perf || {};
    opt.perf.microYield = opt.perf.microYield || { enabled: false };
    opt.perf.semanticBatchSize =
        opt.perf.semanticBatchSize ??
        this._options.perf.semanticBatchSize ??
        64;
    opt.perf.maxTargetsSafety =
        opt.perf.maxTargetsSafety ??
        this._options.perf.maxTargetsSafety ??
        200000;

    // 3️⃣ এখন নিচের সব code safe

    // Apply focus multipliers (without deleting manual weights)
    opt = this._applyFocus(opt);

    // Ensure init
    if (!this._inited) await this.init();

    // Resolve target arrays
    const resolved = this._resolveTargets(targetsOverride);
    const targetText = resolved.text;
    const targetMeta = resolved.meta;
    const targetIds = resolved.ids;

    const tensorsBefore = this._safeNumTensors();
    const backend = (typeof tf !== "undefined") ? tf.getBackend() : "unknown";

    query = (query === null || query === undefined) ? "" : String(query);

    if (targetText.length === 0) {
      return this._formatEmptyResult(query, opt, tStart, 0, backend, tensorsBefore);
    }

    // Meta filter
    const candIdx = this._applyMetaFilterIndices(opt, targetText, targetMeta);
    if (candIdx.length === 0) {
      return this._formatEmptyResult(query, opt, tStart, 0, backend, tensorsBefore);
    }

    // Query features
    const qFeat = this._getQueryFeatures(query, opt);

    // BM25 stats
    const bm25 = (targetsOverride ? this._buildBM25(targetText, opt.factorConfig.words) : (this._bm25 || this._buildBM25(targetText, opt.factorConfig.words)));

    // ============================================================
    // SEMANTIC (Factor 7): embeddings + cosine in TFJS (batched)
    // ============================================================
    const tSem0 = this._now();
    const semanticScores = await this._computeSemanticScores(query, qFeat, targetText, candIdx, opt);
    const msSemantic = this._now() - tSem0;

    // ============================================================
    // Non-semantic scoring + fusion
    // ============================================================
    const tNon0 = this._now();
    const topK = Math.max(1, opt.perf.topK | 0);
    const best = [];

    const factorNames = this._factorNames();

    // Optional time budget
    const budget = opt.perf.timeBudgetMs | 0;

    // Candidate scoring loop
    for (let pos = 0; pos < candIdx.length; pos++) {
      const ti = candIdx[pos];
      const text = targetText[ti];
      const meta = targetMeta[ti] || null;
      const id = targetIds[ti] || null;

      // Target features
      const tFeat = this._getTargetFeatures(text, ti, opt, targetsOverride ? true : false);

      // 16 factor scores
      const scores = Object.create(null);
      const breakdown = Object.create(null);

      // 1 numeric
      scores.numericSimilarity = this._scoreNumeric(qFeat, tFeat, opt, breakdown);
      // 2 alphabetic
      scores.alphabeticSimilarity = this._scoreAlphabetic(qFeat, tFeat, opt, breakdown);
      // 3 uppercase
      scores.upperCasePatternSimilarity = this._scoreCasePattern(qFeat, tFeat, opt, breakdown, "upper");
      // 4 lowercase
      scores.lowerCasePatternSimilarity = this._scoreCasePattern(qFeat, tFeat, opt, breakdown, "lower");
      // 5 spaces
      scores.spacesSimilarity = this._scoreSpaces(qFeat, tFeat, opt, breakdown);
      // 6 punctuation
      scores.punctuationSimilarity = this._scorePunctuation(qFeat, tFeat, opt, breakdown);
      // 7 semantic
      scores.humanMeaningSimilarity = semanticScores[pos] || 0;
      breakdown.humanMeaningSimilarity = {
        score01: scores.humanMeaningSimilarity,
        weightUsed: opt.factorWeights.humanMeaningSimilarity,
        notes: "USE embedding cosine in TFJS mapped to [0,1]"
      };
      // 8 words (BM25 + overlaps)
      scores.wordsSimilarity = this._scoreWordsBM25(qFeat, tFeat, bm25, ti, opt, breakdown, targetText, targetsOverride);
      // 9 no-grammar
      scores.wordsSimilarityNoGrammar = this._scoreWordsNoGrammar(qFeat, tFeat, opt, breakdown);
      // 10 grammar-sensitive
      scores.wordsSimilarityWithGrammar = this._scoreWordsWithGrammar(qFeat, tFeat, opt, breakdown);
      // 11 emoji
      scores.emojiSimilarity = this._scoreEmoji(qFeat, tFeat, opt, breakdown);
      // 12 first section
      scores.firstSectionSimilarity = this._scoreSection(qFeat, tFeat, opt, breakdown, 1);
      // 13 second section
      scores.secondSectionSimilarity = this._scoreSection(qFeat, tFeat, opt, breakdown, 2);
      // 14 grammar-follow
      scores.followGrammarSimilarity = this._scoreGrammarFollow(qFeat, tFeat, opt, breakdown);
      // 15 verb
      scores.verbSimilarity = this._scoreVerbs(qFeat, tFeat, opt, breakdown);
      // 16 aux
      scores.auxiliaryVerbSimilarity = this._scoreAuxVerbs(qFeat, tFeat, opt, breakdown);

      // Meta boost (importance-based, not time-based by default)
      const metaBoost = this._applyMetaBoost(opt, meta, text, ti, qFeat);

      // Fuse
      const fused = this._fuseScores(scores, opt, factorNames);
      let score01 = fused.score01;

      // Apply meta boost after fusion
      if (metaBoost) {
        const mult = (typeof metaBoost.multScore === "number") ? metaBoost.multScore : 1;
        const add = (typeof metaBoost.addScore01 === "number") ? metaBoost.addScore01 : 0;
        score01 = this._clamp01(score01 * mult + add);
      }

      // Confidence
      const confidence01 = this._confidenceFromFactors(score01, scores, opt, factorNames);

      // Diagnostics
      const diagnostics = {
        fused,
        metaBoost: metaBoost || undefined,
        id,
        embedKey: this._eKey(text, opt),
        meta: opt.meta.includeMetaInDiagnostics ? meta : undefined
      };

      // Push into topK
      this._pushTopK(best, {
        text,
        index: ti,
        score01,
        confidence01,
        breakdown,
        diagnostics
      }, topK);

      // Micro yield
      if (opt.perf.microYield.enabled && ((pos + 1) % (opt.perf.microYield.everyItems || 64) === 0)) {
        await this._microYield(opt);
      }

      // Budget stop
      if (budget > 0 && (this._now() - tStart) > budget) break;
    }

    best.sort((a, b) => b.score01 - a.score01);

    const msNonSemantic = this._now() - tNon0;
    const msTotal = this._now() - tStart;
    const tensorsAfter = this._safeNumTensors();

    if (opt.debug.enabled && opt.debug.logTimings) {
      this._dInfo(opt, `match() targets=${candIdx.length}/${targetText.length} msTotal=${msTotal.toFixed(1)} msSem=${msSemantic.toFixed(1)} msNon=${msNonSemantic.toFixed(1)} tensors ${tensorsBefore}->${tensorsAfter}`);
    }

    if (opt.debug.enabled && opt.debug.logTopK) {
      const group = "UltraTextMatcherTF TopK";
      if (opt.debug.groupCollapsed && console.groupCollapsed) console.groupCollapsed(group);
      else if (console.group) console.group(group);
      for (let i = 0; i < best.length; i++) {
        console.log(i, best[i].score01, best[i].confidence01, best[i].text);
      }
      if (console.groupEnd) console.groupEnd();
    }

    // Auto-clear caches after match if requested
    if (opt.cache.autoClearAfterMatch) {
      if (opt.cache.clearFeatureCacheAfterMatch) this._featureCache.clear();
      if (opt.cache.clearEmbedCacheAfterMatch) this._embedLRUClear();
      if (opt.cache.clearQueryCacheAfterMatch) this._queryFeatureCache.clear();
    }

    // Final formatting
    return {
      query,
      topK,
      results: best.map((r) => ({
        text: r.text,
        index: r.index,
        score01: this._round6(r.score01),
        confidence01: this._round6(r.confidence01),
        breakdown: this._roundBreakdown(r.breakdown),
        diagnostics: r.diagnostics
      })),
      stats: {
        msTotal: this._round3(msTotal),
        msSemantic: this._round3(msSemantic),
        msNonSemantic: this._round3(msNonSemantic),
        backend,
        tensorsBefore,
        tensorsAfter,
        numTargets: candIdx.length
      }
    };
  }

  // =====================================================================
  // SECTION C — Target normalization & resolution
  // =====================================================================

  _normalizeTargetItem(item) {
    if (typeof item === "string") return { text: item, meta: null, id: null };
    if (item && typeof item === "object") {
      const text = String(item.text ?? item.value ?? "");
      const meta = item.meta ?? item.metadata ?? null;
      const id = item.id ?? item._id ?? item.key ?? null;
      return { text, meta, id };
    }
    return { text: String(item ?? ""), meta: null, id: null };
  }

  _resolveTargets(targetsOverride) {
    if (!targetsOverride) {
      return { text: this._targetText, meta: this._targetMeta, ids: this._targetIds };
    }
    const arr = Array.isArray(targetsOverride) ? targetsOverride : [];
    const text = new Array(arr.length);
    const meta = new Array(arr.length);
    const ids = new Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      const norm = this._normalizeTargetItem(arr[i]);
      text[i] = norm.text;
      meta[i] = norm.meta;
      ids[i] = norm.id;
    }
    return { text, meta, ids };
  }

  _formatEmptyResult(query, opt, tStart, numTargets, backend, tensorsBefore) {
    return {
      query,
      topK: Math.max(1, opt.perf.topK | 0),
      results: [],
      stats: {
        msTotal: this._round3(this._now() - tStart),
        msSemantic: 0,
        msNonSemantic: 0,
        backend,
        tensorsBefore,
        tensorsAfter: this._safeNumTensors(),
        numTargets
      }
    };
  }

  // =====================================================================
  // SECTION D — Metadata filter & boost (no time/recency default)
  // =====================================================================

  _applyMetaFilterIndices(opt, targetText, targetMeta) {
    if (!opt.meta.enabled || !opt.meta.filter) {
      const idx = new Array(targetText.length);
      for (let i = 0; i < targetText.length; i++) idx[i] = i;
      return idx;
    }

    const f = opt.meta.filter;
    const out = [];

    if (typeof f === "function") {
      for (let i = 0; i < targetText.length; i++) {
        try {
          if (f(targetMeta[i] || null, targetText[i], i)) out.push(i);
        } catch (e) {
          if (opt.debug.logWarnings) this._dWarn(opt, "meta.filter error:", e);
          // Fail-open
          out.push(i);
        }
      }
      return out;
    }

    // Object rules
    const rules = f || {};

    const allowTags = Array.isArray(rules.allowTags) ? new Set(rules.allowTags.map(String)) : null;
    const blockTags = Array.isArray(rules.blockTags) ? new Set(rules.blockTags.map(String)) : null;
    const allowAnyTags = Array.isArray(rules.allowAnyTags) ? new Set(rules.allowAnyTags.map(String)) : null;
    const blockAnyTags = Array.isArray(rules.blockAnyTags) ? new Set(rules.blockAnyTags.map(String)) : null;

    const allowTypes = Array.isArray(rules.allowTypes) ? new Set(rules.allowTypes.map(String)) : null;
    const blockTypes = Array.isArray(rules.blockTypes) ? new Set(rules.blockTypes.map(String)) : null;

    const allowChannels = Array.isArray(rules.allowChannels) ? new Set(rules.allowChannels.map(String)) : null;
    const blockChannels = Array.isArray(rules.blockChannels) ? new Set(rules.blockChannels.map(String)) : null;

    const requireFields = Array.isArray(rules.requireFields) ? rules.requireFields.map(String) : null;

    const minPriority = (typeof rules.minPriority === "number") ? rules.minPriority : -Infinity;
    const maxPriority = (typeof rules.maxPriority === "number") ? rules.maxPriority : Infinity;

    const minQuality = (typeof rules.minQuality === "number") ? rules.minQuality : -Infinity;
    const maxQuality = (typeof rules.maxQuality === "number") ? rules.maxQuality : Infinity;

    for (let i = 0; i < targetText.length; i++) {
      const m = targetMeta[i] || {};
      let ok = true;

      // Required fields
      if (ok && requireFields && requireFields.length) {
        for (let k = 0; k < requireFields.length; k++) {
          const fld = requireFields[k];
          if (!(fld in m)) { ok = false; break; }
        }
      }

      // Types
      const ty = String(m.type ?? m.kind ?? "");
      if (ok && allowTypes && allowTypes.size && !allowTypes.has(ty)) ok = false;
      if (ok && blockTypes && blockTypes.size && blockTypes.has(ty)) ok = false;

      // Channels
      const ch = String(m.channel ?? m.room ?? m.source ?? "");
      if (ok && allowChannels && allowChannels.size && !allowChannels.has(ch)) ok = false;
      if (ok && blockChannels && blockChannels.size && blockChannels.has(ch)) ok = false;

      // Tags
      const tags = Array.isArray(m.tags) ? m.tags.map(String) : [];
      if (ok && allowTags && allowTags.size) {
        // must contain all allowTags
        for (const t of allowTags) {
          if (!tags.includes(t)) { ok = false; break; }
        }
      }
      if (ok && blockTags && blockTags.size) {
        for (const t of blockTags) {
          if (tags.includes(t)) { ok = false; break; }
        }
      }
      if (ok && allowAnyTags && allowAnyTags.size) {
        // must contain at least one
        let any = false;
        for (const t of allowAnyTags) { if (tags.includes(t)) { any = true; break; } }
        if (!any) ok = false;
      }
      if (ok && blockAnyTags && blockAnyTags.size) {
        // if contains any => block
        let any = false;
        for (const t of blockAnyTags) { if (tags.includes(t)) { any = true; break; } }
        if (any) ok = false;
      }

      // Priority & quality
      const pr = (typeof m.priority === "number") ? m.priority : (typeof m.rank === "number" ? m.rank : (typeof m.weight === "number" ? m.weight : NaN));
      const ql = (typeof m.quality === "number") ? m.quality : (typeof m.score === "number" ? m.score : NaN);

      if (ok && Number.isFinite(pr)) {
        if (pr < minPriority || pr > maxPriority) ok = false;
      }
      if (ok && Number.isFinite(ql)) {
        if (ql < minQuality || ql > maxQuality) ok = false;
      }

      if (ok) out.push(i);
    }

    return out;
  }

  _applyMetaBoost(opt, meta, text, index, qFeat) {
    if (!opt.meta.enabled || !opt.meta.boost) return null;

    const b = opt.meta.boost;

    // function mode
    if (typeof b === "function") {
      try {
        return b(meta, text, index, qFeat) || null;
      } catch (e) {
        if (opt.debug.logWarnings) this._dWarn(opt, "meta.boost error:", e);
        return null;
      }
    }

    // object rules
    const rules = b || {};
    let add = 0;
    let mult = 1;
    const notes = [];

    const m = meta || {};

    // Importance-based boost (NO time-based by default)
    // importanceField: auto | specific
    const field = rules.importanceField || "auto";
    let imp = NaN;

    if (field === "auto") {
      if (typeof m.priority === "number") imp = m.priority;
      else if (typeof m.rank === "number") imp = m.rank;
      else if (typeof m.quality === "number") imp = m.quality;
      else if (typeof m.weight === "number") imp = m.weight;
      else if (typeof m.importance === "number") imp = m.importance;
    } else {
      if (typeof m[field] === "number") imp = m[field];
    }

    if (Number.isFinite(imp)) {
      const scale = (typeof rules.importanceScale === "number") ? rules.importanceScale : 0.10;
      const mode = rules.importanceMode || "sigmoid";
      let v = 0;
      if (mode === "linear") {
        // assume imp ~ 0..1 or 0..10; normalize robustly
        const norm = this._clamp01(imp > 1 ? (imp / 10) : imp);
        v = scale * (norm - 0.5) * 2; // -scale..+scale
      } else {
        // sigmoid centered at 0.5 (if imp 0..1) or 5 (if imp 0..10)
        const x = (imp > 1) ? (imp - 5) : ((imp - 0.5) * 10);
        const s = 1 / (1 + Math.exp(-x));
        v = scale * (s - 0.5) * 2;
      }
      add += v;
      notes.push(`importance(${field})=${imp} add=${v.toFixed(4)}`);
    }

    // tag boosts
    if (rules.tagBoost && Array.isArray(m.tags)) {
      for (let i = 0; i < m.tags.length; i++) {
        const tg = String(m.tags[i]);
        const val = rules.tagBoost[tg];
        if (typeof val === "number" && val !== 0) {
          add += val;
          notes.push(`tagBoost(${tg})=${val}`);
        }
      }
    }

    // type boosts
    const ty = String(m.type ?? m.kind ?? "");
    if (rules.typeBoost && ty) {
      const val = rules.typeBoost[ty];
      if (typeof val === "number" && val !== 0) {
        add += val;
        notes.push(`typeBoost(${ty})=${val}`);
      }
    }

    // channel boosts
    const ch = String(m.channel ?? m.room ?? m.source ?? "");
    if (rules.channelBoost && ch) {
      const val = rules.channelBoost[ch];
      if (typeof val === "number" && val !== 0) {
        add += val;
        notes.push(`channelBoost(${ch})=${val}`);
      }
    }

    // author boosts
    const au = String(m.author ?? m.user ?? m.owner ?? "");
    if (rules.authorBoost && au) {
      const val = rules.authorBoost[au];
      if (typeof val === "number" && val !== 0) {
        add += val;
        notes.push(`authorBoost(${au})=${val}`);
      }
    }

    // Optional query-tag affinity (#tag in query)
    if (qFeat && qFeat.hashTags && qFeat.hashTags.size && Array.isArray(m.tags)) {
      let hits = 0;
      for (const ht of qFeat.hashTags) {
        if (m.tags.map((x) => String(x).toLowerCase()).includes(ht)) hits++;
      }
      if (hits > 0) {
        const extra = Math.min(0.10, 0.02 * hits);
        add += extra;
        notes.push(`queryTagAffinity=${extra.toFixed(3)}`);
      }
    }

    // Clamp
    const clampAdd = (typeof rules.clampAdd === "number") ? rules.clampAdd : 0.25;
    const minM = (typeof rules.clampMultMin === "number") ? rules.clampMultMin : 0.70;
    const maxM = (typeof rules.clampMultMax === "number") ? rules.clampMultMax : 1.35;

    add = Math.max(-clampAdd, Math.min(clampAdd, add));
    mult = Math.max(minM, Math.min(maxM, mult));

    if (add === 0 && mult === 1) return null;
    return { addScore01: add, multScore: mult, notes: notes.join("; ") };
  }

  // =====================================================================
  // SECTION E — Feature extraction & caching
  // =====================================================================

  _tKey(i) { return "T:" + i; }
  _qKey(q) { return "Q:" + q; }

  _getQueryFeatures(query, opt) {
    if (opt.cache.queryFeatureCache) {
      const k = this._qKey(query);
      const hit = this._queryFeatureCache.get(k);
      if (hit) return hit;
      const feat = this._extractFeatures(query, opt, true);
      this._queryFeatureCache.set(k, feat);
      return feat;
    }
    return this._extractFeatures(query, opt, true);
  }

  _getTargetFeatures(text, index, opt, isOverrideTargets) {
    // If override targets are passed, indices don't map to global cache safely.
    if (isOverrideTargets || !opt.cache.featureCache) {
      return this._extractFeatures(text, opt, false);
    }

    const k = this._tKey(index);
    const hit = this._featureCache.get(k);
    if (hit) return hit;

    const feat = this._extractFeatures(text, opt, false);
    this._featureCache.set(k, feat);
    return feat;
  }

  _extractFeatures(text, opt, isQuery) {
    const raw = String(text ?? "");
    const len = raw.length;

    // normalized strings
    const lower = raw.toLowerCase();
    const collapsedSpaces = raw.replace(/\s+/g, " ").trim();
    const alphaOnly = lower.replace(/[^a-z]+/g, "");

    // numbers
    const nums = this._extractNumbers(raw, opt.factorConfig.numeric.maxNumbers);

    // case patterns
    const caseInfo = this._extractCasePattern(raw, opt.factorConfig.casePattern.bins);

    // spaces
    const spacesInfo = this._extractSpacesPattern(raw, opt.factorConfig.spaces);

    // punctuation
    const punctInfo = this._extractPunctuation(raw, opt.factorConfig.punctuation);

    // emoji
    const emojiInfo = this._extractEmoji(raw, opt.factorConfig.emoji);

    // tokens
    const tokens = this._tokenizeEnglish(raw, opt.factorConfig.words);
    const tokenSet = new Set(tokens);

    // token ngrams
    const tokenBigrams = this._tokenNGrams(tokens, opt.factorConfig.words.tokenGramN, opt.factorConfig.words.maxTokenGrams);
    const tokenBigramSet = new Set(tokenBigrams);

    // no-grammar tokens
    const tokensNoGrammar = tokens.map((t) => this._stripSuffixes(t, opt.factorConfig.nogrammar));
    const tokenNGSet = new Set(tokensNoGrammar);

    // verbs/aux
    const verbs = this._extractVerbs(tokens, opt.factorConfig.verbs);
    const aux = this._extractAuxVerbs(tokens, opt.factorConfig.aux);

    // sections
    const sections = this._extractSections(raw, opt.factorConfig.sections);

    // grammar heuristics
    const grammarFeat = this._extractGrammarHeuristics(raw, tokens, opt.factorConfig.grammar);

    // char ngrams (alphabetic)
    const charN = opt.factorConfig.alphabetic.charNGramN;
    const charNGrams = this._charNGrams(alphaOnly, charN, opt.factorConfig.alphabetic.charNGramMax);
    const charNGramSet = new Set(charNGrams);

    // hashtags (query only)
    let hashTags = null;
    if (isQuery) {
      hashTags = new Set();
      const m = raw.match(/#[A-Za-z0-9_]+/g);
      if (m) for (let i = 0; i < m.length; i++) hashTags.add(m[i].slice(1).toLowerCase());
    }

    return {
      raw,
      len,
      lower,
      collapsedSpaces,
      alphaOnly,
      nums,
      caseInfo,
      spacesInfo,
      punctInfo,
      emojiInfo,
      tokens,
      tokenSet,
      tokenBigrams,
      tokenBigramSet,
      tokensNoGrammar,
      tokenNGSet,
      verbs,
      aux,
      sections,
      grammarFeat,
      charNGrams,
      charNGramSet,
      hashTags
    };
  }

  // =====================================================================
  // SECTION F — Semantic computation (fixed tidy usage)
  // =====================================================================

  async _computeSemanticScores(query, qFeat, targetText, candIdx, opt) {
  opt.perf = opt.perf || {};
  opt.perf.microYield = opt.perf.microYield || { enabled: false, everyItems: 64, strategy: "timeout0" };


  // ...rest of your function
    const batchSize = Math.max(1, opt.perf.semanticBatchSize | 0);
    const scores = new Float32Array(candIdx.length);

    // Query vector (try cache)
    const qKey = this._eKey(query, opt);
    let qVec = opt.cache.embeddingCache ? this._embedLRUGet(qKey) : null;

    if (!qVec) {
      const qVecs = await this._embedTextsToVectors([query], opt);
      qVec = qVecs[0] || new Float32Array(0);
      if (opt.cache.embeddingCache && qVec.length) this._embedLRUSet(qKey, qVec, opt);
    }

    if (!qVec || qVec.length === 0) {
      // semantic scores remain 0
      return scores;
    }

    for (let bi = 0; bi < candIdx.length; bi += batchSize) {
      const end = Math.min(candIdx.length, bi + batchSize);
      const n = end - bi;

      // Prepare batch vecs via cache or embed
      const vecs = new Array(n);
      const keys = new Array(n);
      const needTexts = [];
      const needPos = [];

      for (let j = 0; j < n; j++) {
        const idx = candIdx[bi + j];
        const text = targetText[idx];
        const k = this._eKey(text, opt);
        keys[j] = k;
        let v = opt.cache.embeddingCache ? this._embedLRUGet(k) : null;
        if (!v) {
          needTexts.push(text);
          needPos.push(j);
          vecs[j] = null;
        } else {
          vecs[j] = v;
        }
      }

      if (needTexts.length) {
        const newVecs = await this._embedTextsToVectors(needTexts, opt);
        for (let k = 0; k < needPos.length; k++) {
          const j = needPos[k];
          const v = newVecs[k] || new Float32Array(0);
          vecs[j] = v;
          if (opt.cache.embeddingCache && v.length) this._embedLRUSet(keys[j], v, opt);
        }
      }

      // Cosine in TFJS (tidy is synchronous, await data outside)
      const cos = await this._cosineSimilarityTFJS(qVec, vecs);

      // Map cosine to [0,1]
      const cfg = opt.factorConfig.semantic;
      const floor = cfg.enableFloor ? cfg.cosineFloor : -1.0;

      for (let j = 0; j < n; j++) {
        const c = cos[j];
        let s01 = (c - floor) / (1 - floor);
        if (s01 < 0) s01 = 0;
        if (s01 > 1) s01 = 1;
        scores[bi + j] = s01;
      }

      if (opt.debug.enabled && opt.debug.logBatches) {
        this._dInfo(opt, `semantic batch ${bi}..${end} (n=${n})`);
      }

    const my = opt?.perf?.microYield;
    if (my?.enabled) {
    await this._microYield(opt);
    }
    }

    return scores;
  }

  async _warmupModel(opt) {
    // Warmup embedding + cosine to compile common kernels
    const dummy = ["Warmup sentence one.", "Warmup sentence two."];
    const vecs = await this._embedTextsToVectors(dummy, opt);
    const q = vecs[0] || new Float32Array(0);
    const A = [vecs[1] || new Float32Array(0)];
    if (q.length && A[0].length) {
      await this._cosineSimilarityTFJS(q, A);
    }
  }

  async _embedTextsToVectors(texts, opt) {
    // IMPORTANT: No tf.tidy around async
    if (!this._model || typeof this._model.embed !== "function") {
      return texts.map(() => new Float32Array(0));
    }

    // Embed
    const emb = await this._model.embed(texts); // Tensor2D [n,d]
    try {
      // Prefer data() then slice, to avoid huge nested arrays
      // But we need per-row vectors. We'll use array() safely for moderate batch sizes.
      const arr = await emb.array();
      const out = new Array(arr.length);
      for (let i = 0; i < arr.length; i++) {
        out[i] = Float32Array.from(arr[i]);
      }
      return out;
    } finally {
      // Always dispose tensor
      emb.dispose();
    }
  }

  async _cosineSimilarityTFJS(qVec, batchVecs) {
    const n = batchVecs.length;
    const d = qVec.length;
    if (n === 0) return new Float32Array(0);
    if (d === 0) return new Float32Array(n);

    // Create sim tensor via tidy (sync), then await data outside
    const simTensor = tf.tidy(() => {
      const q = tf.tensor2d(qVec, [1, d], "float32");           // [1,d]
      const A = tf.tensor2d(this._stackVecs(batchVecs, d), [n, d], "float32"); // [n,d]

      // norms
      const qNorm = tf.norm(q, "euclidean", 1).add(1e-12);      // [1]
      const ANorm = tf.norm(A, "euclidean", 1).add(1e-12);      // [n]

      // unit vectors
      const qUnit = q.div(qNorm.reshape([1, 1]));               // [1,d]
      const AUnit = A.div(ANorm.reshape([n, 1]));               // [n,d]

      // cosine
      const sim = AUnit.mul(qUnit).sum(1);                      // [n]

      // Return sim; tidy will dispose intermediates except returned tensor
      return sim;
    });

    try {
      const out = await simTensor.data(); // await outside tidy
      return out;
    } finally {
      simTensor.dispose();
    }
  }

  _stackVecs(vecs, d) {
    const n = vecs.length;
    const out = new Float32Array(n * d);
    for (let i = 0; i < n; i++) {
      const v = vecs[i] || new Float32Array(0);
      const off = i * d;
      const m = Math.min(d, v.length);
      for (let j = 0; j < m; j++) out[off + j] = v[j];
    }
    return out;
  }

  // =====================================================================
  // SECTION G — Embedding LRU (Float32Array)
  // =====================================================================

  _eKey(text, opt) {
    if (opt.cache.embeddingCacheKey === "hash") return "E:" + this._hash32(text);
    return "E:" + text;
  }

  _embedLRUGet(key) {
    const e = this._embedLRU.get(key);
    if (!e) return null;
    e.lastUsed = this._now();
    return e.vec;
  }

  _embedLRUSet(key, vec, opt) {
    const limitBytes = Math.max(1, (opt.cache.embeddingCacheLimitMB || 128) * 1024 * 1024);
    const bytes = vec.byteLength || (vec.length * 4);

    // Replace existing
    const ex = this._embedLRU.get(key);
    if (ex) {
      this._embedLRUBytes -= ex.bytes || 0;
      this._embedLRU.delete(key);
    }

    this._embedLRU.set(key, { vec, dim: vec.length, bytes, lastUsed: this._now() });
    this._embedLRUBytes += bytes;

    // Evict if needed
    if (this._embedLRUBytes > limitBytes) this._embedLRUEvict(limitBytes, opt);
  }

  _embedLRUEvict(limitBytes, opt) {
    const arr = Array.from(this._embedLRU.entries());
    arr.sort((a, b) => (a[1].lastUsed - b[1].lastUsed));
    for (let i = 0; i < arr.length && this._embedLRUBytes > limitBytes; i++) {
      const key = arr[i][0];
      const ent = arr[i][1];
      this._embedLRU.delete(key);
      this._embedLRUBytes -= ent.bytes || 0;
    }
    if (opt.debug.enabled && opt.debug.logCache) {
      this._dInfo(opt, `embedLRU evicted, bytes=${this._embedLRUBytes}`);
    }
  }

  _embedLRUClear() {
    this._embedLRU.clear();
    this._embedLRUBytes = 0;
  }

  // =====================================================================
  // SECTION H — Factor list
  // =====================================================================

  _factorNames() {
    return [
      "numericSimilarity",
      "alphabeticSimilarity",
      "upperCasePatternSimilarity",
      "lowerCasePatternSimilarity",
      "spacesSimilarity",
      "punctuationSimilarity",
      "humanMeaningSimilarity",
      "wordsSimilarity",
      "wordsSimilarityNoGrammar",
      "wordsSimilarityWithGrammar",
      "emojiSimilarity",
      "firstSectionSimilarity",
      "secondSectionSimilarity",
      "followGrammarSimilarity",
      "verbSimilarity",
      "auxiliaryVerbSimilarity"
    ];
  }

  // =====================================================================
  // SECTION I — Factor 1: Numeric similarity
  // =====================================================================

  _scoreNumeric(q, t, opt, breakdown) {
    const w = opt.factorWeights.numericSimilarity;

    const qn = q.nums;
    const tn = t.nums;

    if (qn.values.length === 0 && tn.values.length === 0) {
      const s = 0.5;
      breakdown.numericSimilarity = { score01: s, weightUsed: w, notes: "No numbers; neutral" };
      return s;
    }
    if (qn.values.length === 0 || tn.values.length === 0) {
      const s = 0.0;
      breakdown.numericSimilarity = { score01: s, weightUsed: w, notes: "Numbers on one side only" };
      return s;
    }

    // Set overlap on normalized number strings
    const setOverlap = this._jaccardSet(qn.normSet, tn.normSet);

    // Relative closeness: each query number best matches any target number
    let closeness = 0;
    const alpha = opt.factorConfig.numeric.closenessAlpha;
    for (let i = 0; i < qn.values.length; i++) {
      const a = qn.values[i];
      let best = 0;
      for (let j = 0; j < tn.values.length; j++) {
        const b = tn.values[j];
        const rel = this._relativeCloseness(a, b, opt.factorConfig.numeric.relativeEps);
        if (rel > best) best = rel;
      }
      closeness += best;
    }
    closeness /= Math.max(1, qn.values.length);

    // Blend
    const score = this._clamp01(0.55 * setOverlap + 0.45 * (alpha * closeness + (1 - alpha) * Math.sqrt(closeness)));

    breakdown.numericSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `numJaccard=${setOverlap.toFixed(3)} closeness=${closeness.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION J — Factor 2: Alphabetic similarity
  // =====================================================================

  _scoreAlphabetic(q, t, opt, breakdown) {
    const w = opt.factorWeights.alphabeticSimilarity;

    const qa = q.alphaOnly;
    const ta = t.alphaOnly;

    if (!qa && !ta) {
      const s = 0.5;
      breakdown.alphabeticSimilarity = { score01: s, weightUsed: w, notes: "No letters; neutral" };
      return s;
    }
    if (!qa || !ta) {
      const s = 0.0;
      breakdown.alphabeticSimilarity = { score01: s, weightUsed: w, notes: "Letters on one side only" };
      return s;
    }

    const ngramJac = this._jaccardSet(q.charNGramSet, t.charNGramSet);

    // Edit similarity with cap
    const maxLen = opt.factorConfig.alphabetic.editDistanceMaxLen;
    const levSim = (qa.length <= maxLen && ta.length <= maxLen) ? this._levenshteinSim01(qa, ta) : this._approxEditSimLong(qa, ta);

    const score = this._clamp01(0.62 * ngramJac + 0.38 * levSim);

    breakdown.alphabeticSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `charNGramJaccard=${ngramJac.toFixed(3)} editSim=${levSim.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION K — Factor 3 & 4: Case pattern similarity
  // =====================================================================

  _scoreCasePattern(q, t, opt, breakdown, mode) {
    const name = (mode === "upper") ? "upperCasePatternSimilarity" : "lowerCasePatternSimilarity";
    const w = opt.factorWeights[name];

    // Focus multiplier for case
    const caseMul = this._clampFocus(opt.focus.favorCase);

    const qc = q.caseInfo;
    const tc = t.caseInfo;

    const qRatio = (mode === "upper") ? qc.upperRatio : qc.lowerRatio;
    const tRatio = (mode === "upper") ? tc.upperRatio : tc.lowerRatio;

    const ratioSim = 1 - Math.min(1, Math.abs(qRatio - tRatio) / 0.45);
    const posSim = this._binPatternSim((mode === "upper") ? qc.upperBins : qc.lowerBins, (mode === "upper") ? tc.upperBins : tc.lowerBins);

    const score = this._clamp01((0.55 * ratioSim + 0.45 * posSim) * caseMul);

    breakdown[name] = {
      score01: score,
      weightUsed: w,
      notes: `ratioSim=${ratioSim.toFixed(3)} posSim=${posSim.toFixed(3)} caseMul=${caseMul.toFixed(2)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION L — Factor 5: Spaces similarity
  // =====================================================================

  _scoreSpaces(q, t, opt, breakdown) {
    const w = opt.factorWeights.spacesSimilarity;

    const qs = q.spacesInfo;
    const ts = t.spacesInfo;

    const maxCount = Math.max(1, Math.max(qs.spaceCount, ts.spaceCount));
    const countSim = 1 - Math.min(1, Math.abs(qs.spaceCount - ts.spaceCount) / maxCount);

    // run length similarity (set-like)
    const runSim = this._jaccardArr(qs.runs, ts.runs);

    // positions bins similarity
    const posSim = this._binPatternSim(qs.posBins, ts.posBins);

    // collapsed string similarity
    const colSim = this._levenshteinSim01(q.collapsedSpaces.toLowerCase(), t.collapsedSpaces.toLowerCase());

    const score = this._clamp01(0.30 * countSim + 0.25 * runSim + 0.20 * posSim + 0.25 * colSim);

    breakdown.spacesSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `countSim=${countSim.toFixed(3)} runSim=${runSim.toFixed(3)} posSim=${posSim.toFixed(3)} colSim=${colSim.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION M — Factor 6: Punctuation similarity
  // =====================================================================

  _scorePunctuation(q, t, opt, breakdown) {
    const w = opt.factorWeights.punctuationSimilarity;

    const qp = q.punctInfo;
    const tp = t.punctInfo;

    const setSim = this._jaccardSet(qp.set, tp.set);
    const posSim = this._binPatternSim(qp.posBins, tp.posBins);

    const densSim = 1 - Math.min(1, Math.abs(qp.density - tp.density) / 0.12);

    // Focus multiplier for punctuation
    const punctMul = this._clampFocus(opt.focus.favorPunctuation);

    const score = this._clamp01((0.48 * setSim + 0.32 * posSim + 0.20 * densSim) * punctMul);

    breakdown.punctuationSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `setSim=${setSim.toFixed(3)} posSim=${posSim.toFixed(3)} densSim=${densSim.toFixed(3)} punctMul=${punctMul.toFixed(2)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION N — Factor 8: Words similarity (Jaccard + n-grams + BM25)
  // =====================================================================

  _scoreWordsBM25(q, t, bm25, docIndex, opt, breakdown, targetText, isOverrideTargets) {
    const w = opt.factorWeights.wordsSimilarity;

    // Token overlap
    const jac = this._jaccardSet(q.tokenSet, t.tokenSet);

    // Token bigram overlap
    const gramJac = this._jaccardSet(q.tokenBigramSet, t.tokenBigramSet);

    // BM25
    const bm = this._bm25Score(q.tokens, docIndex, bm25, opt.factorConfig.words.bm25, targetText, isOverrideTargets, opt);
    const bm01 = 1 - Math.exp(-0.55 * bm);

    // Focus for tokens
    const tokMul = this._clampFocus(opt.focus.favorTokens);

    const score = this._clamp01((0.30 * jac + 0.22 * gramJac + 0.48 * bm01) * tokMul);

    breakdown.wordsSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `tokenJaccard=${jac.toFixed(3)} bigramJaccard=${gramJac.toFixed(3)} bm25=${bm.toFixed(3)} bm01=${bm01.toFixed(3)} tokMul=${tokMul.toFixed(2)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION O — Factor 9: Words similarity without grammar
  // =====================================================================

  _scoreWordsNoGrammar(q, t, opt, breakdown) {
    const w = opt.factorWeights.wordsSimilarityNoGrammar;

    const jac = this._jaccardSet(q.tokenNGSet, t.tokenNGSet);

    // normalized bigrams on stripped tokens
    const qArr = Array.from(q.tokenNGSet);
    const tArr = Array.from(t.tokenNGSet);
    const qG = new Set(this._tokenNGrams(qArr, 2, 2048));
    const tG = new Set(this._tokenNGrams(tArr, 2, 2048));
    const gramJac = this._jaccardSet(qG, tG);

    const score = this._clamp01(0.62 * jac + 0.38 * gramJac);

    breakdown.wordsSimilarityNoGrammar = {
      score01: score,
      weightUsed: w,
      notes: `jac=${jac.toFixed(3)} gramJac=${gramJac.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION P — Factor 10: Words similarity with grammar (morphology sensitivity)
  // =====================================================================

  _scoreWordsWithGrammar(q, t, opt, breakdown) {
    const w = opt.factorWeights.wordsSimilarityWithGrammar;

    const sensitivityBase = opt.factorConfig.grammarWords.morphologySensitivity;
    const sensitivity = this._clamp01(sensitivityBase * this._clampFocus(opt.focus.favorMorphology));

    // exact overlap by surface forms (lowercased)
    const qSet = new Set(q.tokens.map((x) => x.toLowerCase()));
    const tSet = new Set(t.tokens.map((x) => x.toLowerCase()));
    const exact = this._jaccardSet(qSet, tSet);

    // soft form similarity: for each query token, best edit similarity to any target token
    let soft = 0;
    const maxLen = opt.factorConfig.grammarWords.maxEditDistanceLen;
    const tLower = t.tokens.map((x) => x.toLowerCase());
    for (let i = 0; i < q.tokens.length; i++) {
      const a = q.tokens[i].toLowerCase();
      let best = 0;
      for (let j = 0; j < tLower.length; j++) {
        const b = tLower[j];
        const sim = (a.length <= maxLen && b.length <= maxLen) ? this._levenshteinSim01(a, b) : this._approxEditSimLong(a, b);
        if (sim > best) best = sim;
      }
      soft += best;
    }
    soft /= Math.max(1, q.tokens.length);

    // Morphology penalty: if stripped overlap high but exact low, penalize
    const stripped = this._jaccardSet(q.tokenNGSet, t.tokenNGSet);
    const morphDiff = Math.max(0, stripped - exact);
    const penalty = sensitivity * 0.55 * morphDiff;

    const score = this._clamp01((0.55 * exact + 0.45 * soft) - penalty);

    breakdown.wordsSimilarityWithGrammar = {
      score01: score,
      weightUsed: w,
      notes: `exact=${exact.toFixed(3)} soft=${soft.toFixed(3)} stripped=${stripped.toFixed(3)} penalty=${penalty.toFixed(3)} sens=${sensitivity.toFixed(2)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION Q — Factor 11: Emoji similarity
  // =====================================================================

  _scoreEmoji(q, t, opt, breakdown) {
    const w = opt.factorWeights.emojiSimilarity;

    const qe = q.emojiInfo;
    const te = t.emojiInfo;

    if (qe.list.length === 0 && te.list.length === 0) {
      const s = 0.5;
      breakdown.emojiSimilarity = { score01: s, weightUsed: w, notes: "No emoji; neutral" };
      return s;
    }
    if (qe.list.length === 0 || te.list.length === 0) {
      const s = 0.0;
      breakdown.emojiSimilarity = { score01: s, weightUsed: w, notes: "Emoji on one side only" };
      return s;
    }

    const setSim = this._jaccardSet(qe.set, te.set);
    const posSim = this._binPatternSim(qe.posBins, te.posBins);
    const score = this._clamp01(0.70 * setSim + opt.factorConfig.emoji.positionalWeight * posSim);

    breakdown.emojiSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `setSim=${setSim.toFixed(3)} posSim=${posSim.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION R — Factor 12 & 13: Section similarity
  // =====================================================================

  _scoreSection(q, t, opt, breakdown, which) {
    const name = (which === 1) ? "firstSectionSimilarity" : "secondSectionSimilarity";
    const w = opt.factorWeights[name];

    const qs = (which === 1) ? q.sections.first : q.sections.second;
    const ts = (which === 1) ? t.sections.first : t.sections.second;

    const jw = this._jaroWinklerSim01(qs, ts, opt.factorConfig.sections.jaroPrefixScale);
    const lev = this._levenshteinSim01(qs.toLowerCase(), ts.toLowerCase());

    // token overlap within section
    const qTok = this._tokenizeEnglish(qs, opt.factorConfig.words);
    const tTok = this._tokenizeEnglish(ts, opt.factorConfig.words);
    const jac = this._jaccardSet(new Set(qTok), new Set(tTok));

    // prefix focus is applied by weight multiplier earlier; still keep robust blend
    const score = this._clamp01(0.46 * jw + 0.30 * lev + 0.24 * jac);

    breakdown[name] = {
      score01: score,
      weightUsed: w,
      notes: `jw=${jw.toFixed(3)} lev=${lev.toFixed(3)} jac=${jac.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION S — Factor 14: Follow grammar similarity
  // =====================================================================

  _scoreGrammarFollow(q, t, opt, breakdown) {
    const w = opt.factorWeights.followGrammarSimilarity;

    const qg = q.grammarFeat;
    const tg = t.grammarFeat;

    const cfg = opt.factorConfig.grammar;

    const punctPatSim = this._jaccardSet(qg.punctPatternSet, tg.punctPatternSet);
    const sentLenSim = this._histSim(qg.sentenceLenHist, tg.sentenceLenHist);
    const funcSim = this._jaccardSet(qg.functionWordSet, tg.functionWordSet);
    const svoSim = this._jaccardSet(qg.svoTriplesSet, tg.svoTriplesSet);
    const clauseSim = this._jaccardSet(qg.clauseMarkersSet, tg.clauseMarkersSet);

    const inner =
      cfg.punctuationPatternWeight * punctPatSim +
      cfg.posHeuristicWeight * (0.55 * svoSim + 0.45 * sentLenSim) +
      cfg.functionWordWeight * (0.60 * funcSim + 0.40 * clauseSim);

    const denom = (cfg.punctuationPatternWeight + cfg.posHeuristicWeight + cfg.functionWordWeight) || 1;
    let score = inner / denom;

    // Grammar focus multiplier
    score = this._clamp01(score * this._clampFocus(opt.focus.favorGrammar));

    breakdown.followGrammarSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `punctPat=${punctPatSim.toFixed(3)} sentLen=${sentLenSim.toFixed(3)} func=${funcSim.toFixed(3)} svo=${svoSim.toFixed(3)} clause=${clauseSim.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION T — Factor 15: Verb similarity
  // =====================================================================

  _scoreVerbs(q, t, opt, breakdown) {
    const w = opt.factorWeights.verbSimilarity;

    const qv = q.verbs;
    const tv = t.verbs;

    if (qv.set.size === 0 && tv.set.size === 0) {
      const s = 0.5;
      breakdown.verbSimilarity = { score01: s, weightUsed: w, notes: "No verbs detected; neutral" };
      return s;
    }
    if (qv.set.size === 0 || tv.set.size === 0) {
      const s = 0.0;
      breakdown.verbSimilarity = { score01: s, weightUsed: w, notes: "Verbs on one side only" };
      return s;
    }

    const setSim = this._jaccardSet(qv.set, tv.set);
    const posSim = this._binPatternSim(qv.posBins, tv.posBins);

    const score = this._clamp01(0.70 * setSim + opt.factorConfig.verbs.positionalWeight * posSim);

    breakdown.verbSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `setSim=${setSim.toFixed(3)} posSim=${posSim.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION U — Factor 16: Auxiliary verb similarity
  // =====================================================================

  _scoreAuxVerbs(q, t, opt, breakdown) {
    const w = opt.factorWeights.auxiliaryVerbSimilarity;

    const qa = q.aux;
    const ta = t.aux;

    if (qa.set.size === 0 && ta.set.size === 0) {
      const s = 0.5;
      breakdown.auxiliaryVerbSimilarity = { score01: s, weightUsed: w, notes: "No aux verbs; neutral" };
      return s;
    }
    if (qa.set.size === 0 || ta.set.size === 0) {
      const s = 0.0;
      breakdown.auxiliaryVerbSimilarity = { score01: s, weightUsed: w, notes: "Aux verbs on one side only" };
      return s;
    }

    const setSim = this._jaccardSet(qa.set, ta.set);
    const posSim = this._binPatternSim(qa.posBins, ta.posBins);

    const score = this._clamp01(0.75 * setSim + opt.factorConfig.aux.positionalWeight * posSim);

    breakdown.auxiliaryVerbSimilarity = {
      score01: score,
      weightUsed: w,
      notes: `setSim=${setSim.toFixed(3)} posSim=${posSim.toFixed(3)}`
    };
    return score;
  }

  // =====================================================================
  // SECTION V — Fusion (weighted power mean + contradiction penalties)
  // =====================================================================

  _fuseScores(scores, opt, factorNames) {
    const p = opt.fusion.powerMeanP;

    let wSum = 0;
    let acc = 0;

    for (let i = 0; i < factorNames.length; i++) {
      const n = factorNames[i];
      const w = opt.factorWeights[n] || 0;
      const s = this._clamp01(scores[n] ?? 0);
      if (w <= 0) continue;
      wSum += w;
      acc += w * Math.pow(s, p);
    }

    let pm = (wSum > 0) ? Math.pow(acc / wSum, 1 / p) : 0;

    // Contradiction penalties
    let penalty = 0;
    const c = opt.fusion.contradiction;
    if (c && c.enabled) {
      const sem = this._clamp01(scores.humanMeaningSimilarity ?? 0);
      const num = this._clamp01(scores.numericSimilarity ?? 0);
      const tok = this._clamp01(scores.wordsSimilarity ?? 0);

      if (c.semanticVsNumeric && c.semanticVsNumeric.enabled) {
        const sw = opt.factorWeights.numericSimilarity || 0;
        if (sem >= c.semanticVsNumeric.semanticHigh && num <= c.semanticVsNumeric.numericLow && sw > 0) {
          const weightShare = sw / (wSum || 1);
          const severity = (sem - c.semanticVsNumeric.semanticHigh) / Math.max(1e-6, (1 - c.semanticVsNumeric.semanticHigh));
          penalty += c.semanticVsNumeric.penaltyMax * weightShare * this._clamp01(0.55 + 0.45 * severity);
        }
      }

      if (c.semanticVsTokens && c.semanticVsTokens.enabled) {
        const gw = opt.factorWeights.followGrammarSimilarity || 0;
        if (sem >= c.semanticVsTokens.semanticHigh && tok <= c.semanticVsTokens.tokenLow && gw > 0) {
          const weightShare = gw / (wSum || 1);
          const severity = (sem - c.semanticVsTokens.semanticHigh) / Math.max(1e-6, (1 - c.semanticVsTokens.semanticHigh));
          penalty += c.semanticVsTokens.penaltyMax * weightShare * this._clamp01(0.50 + 0.50 * severity);
        }
      }
    }

    pm = this._clamp01(pm - penalty);
    return { score01: pm, penalty };
  }

  // =====================================================================
  // SECTION W — Confidence (sigmoid + agreement shaping)
  // =====================================================================

  _confidenceFromFactors(score01, scores, opt, factorNames) {
    const c = opt.fusion.confidence;

    // Base sigmoid on final score
    const x = (score01 - c.center) * c.steepness;
    const base = 1 / (1 + Math.exp(-x));

    // Weighted mean & weighted std for dispersion
    let wSum = 0;
    let mean = 0;

    for (let i = 0; i < factorNames.length; i++) {
      const n = factorNames[i];
      const w = opt.factorWeights[n] || 0;
      if (w <= 0) continue;
      wSum += w;
      mean += w * (scores[n] ?? 0);
    }
    mean = (wSum > 0) ? mean / wSum : 0;

    let varw = 0;
    for (let i = 0; i < factorNames.length; i++) {
      const n = factorNames[i];
      const w = opt.factorWeights[n] || 0;
      if (w <= 0) continue;
      const d = (scores[n] ?? 0) - mean;
      varw += w * d * d;
    }
    const std = (wSum > 0) ? Math.sqrt(varw / wSum) : 0;

    const agreement = this._clamp01(1 - (std / 0.32));
    let conf = this._clamp01(base + c.agreementBoost * (agreement - 0.5) - c.dispersionPenalty * std);

    // Cap confidence if semantic very low but score moderate (optional)
    if (c.capIfSemanticLow) {
      const sem = this._clamp01(scores.humanMeaningSimilarity ?? 0);
      if (sem < 0.20 && score01 > 0.55) conf *= 0.85;
      if (sem < 0.10 && score01 > 0.45) conf *= 0.75;
    }

    return this._clamp01(conf);
  }

  // =====================================================================
  // SECTION X — BM25 corpus stats + scoring
  // =====================================================================

  _buildBM25(texts, wordsCfg) {
    const docCount = texts.length;
    const df = new Map();
    const dl = new Array(docCount);
    let avgdl = 0;

    for (let i = 0; i < docCount; i++) {
      const toks = this._tokenizeEnglish(texts[i], wordsCfg);
      dl[i] = toks.length;
      avgdl += dl[i];

      const seen = new Set();
      for (let j = 0; j < toks.length; j++) {
        const tok = toks[j];
        if (seen.has(tok)) continue;
        seen.add(tok);
        df.set(tok, (df.get(tok) || 0) + 1);
      }
    }

    avgdl = (docCount > 0) ? (avgdl / docCount) : 0;

    const idf = new Map();
    for (const [tok, dfi] of df.entries()) {
      const v = Math.log(1 + (docCount - dfi + 0.5) / (dfi + 0.5));
      idf.set(tok, v);
    }

    return { docCount, df, idf, dl, avgdl, wordsCfg };
  }

  _bm25Score(queryTokens, docIndex, bm25, params, targetText, isOverrideTargets, opt) {
    if (!bm25 || !bm25.docCount) return 0;

    const dl = bm25.dl[docIndex] || 0;
    const avgdl = bm25.avgdl || 1;
    const k1 = params.k1;
    const b = params.b;

    // Build doc tf
    let docTokens = null;

    // If not override targets and feature cache enabled, try cache
    if (!isOverrideTargets && opt.cache.featureCache) {
      const feat = this._featureCache.get(this._tKey(docIndex));
      if (feat && feat.tokens) docTokens = feat.tokens;
    }

    if (!docTokens) {
      const txt = targetText ? (targetText[docIndex] || "") : (this._targetText[docIndex] || "");
      docTokens = this._tokenizeEnglish(txt, bm25.wordsCfg || opt.factorConfig.words);
    }

    const tfm = new Map();
    for (let i = 0; i < docTokens.length; i++) tfm.set(docTokens[i], (tfm.get(docTokens[i]) || 0) + 1);

    // Query tf
    const qtf = new Map();
    for (let i = 0; i < queryTokens.length; i++) qtf.set(queryTokens[i], (qtf.get(queryTokens[i]) || 0) + 1);

    let score = 0;
    for (const [tok, qf] of qtf.entries()) {
      const idf = bm25.idf.get(tok) || 0;
      const f = tfm.get(tok) || 0;
      if (f <= 0) continue;

      const denom = f + k1 * (1 - b + b * (dl / avgdl));
      const term = idf * (f * (k1 + 1)) / (denom || 1);
      const qBoost = 1 + 0.10 * Math.min(3, qf - 1);
      score += term * qBoost;
    }

    return score;
  }

  // =====================================================================
  // SECTION Y — Tokenization, morphology, verbs, aux
  // =====================================================================

  _tokenizeEnglish(text, cfg) {
    const minLen = cfg.minTokenLen || 2;
    const maxTokens = cfg.maxTokens || 256;

    const raw = String(text ?? "").toLowerCase();
    const parts = raw.split(/[^a-z0-9']+/g);

    const tokens = [];
    for (let i = 0; i < parts.length; i++) {
      let t = parts[i];
      if (!t) continue;
      t = t.replace(/^'+|'+$/g, "");
      if (t.length < minLen) continue;
      tokens.push(t);
      if (tokens.length >= maxTokens) break;
    }

    return tokens;
  }

  _stripSuffixes(token, cfg) {
    token = token || "";
    const minRootLen = cfg.minRootLen || 3;

    if (token.length <= minRootLen) return token;

    // tries -> try
    if (token.endsWith("ies") && token.length > minRootLen + 2) return token.slice(0, -3) + "y";

    // running -> run (double consonant)
    if (token.endsWith("ing") && token.length > minRootLen + 2) {
      let root = token.slice(0, -3);
      if (root.length >= 2 && root[root.length - 1] === root[root.length - 2]) root = root.slice(0, -1);
      if (root.length >= minRootLen) return root;
    }

    // studied -> study
    if (token.endsWith("ied") && token.length > minRootLen + 2) return token.slice(0, -3) + "y";

    // walked -> walk
    if (token.endsWith("ed") && token.length > minRootLen + 1) {
      let root = token.slice(0, -2);
      if (root.endsWith("i") && root.length > minRootLen) root = root.slice(0, -1) + "y";
      if (root.length >= minRootLen) return root;
    }

    // boxes -> box
    if (token.endsWith("es") && token.length > minRootLen + 1) {
      const root = token.slice(0, -2);
      if (root.length >= minRootLen) return root;
    }

    // cats -> cat
    if (token.endsWith("s") && token.length > minRootLen) {
      const root = token.slice(0, -1);
      if (root.length >= minRootLen) return root;
    }

    // fallback list
    const suff = cfg.stripSuffixes || [];
    for (let i = 0; i < suff.length; i++) {
      const s = suff[i];
      if (token.endsWith(s) && token.length > minRootLen + s.length) {
        const root = token.slice(0, -s.length);
        if (root.length >= minRootLen) return root;
      }
    }

    return token;
  }

  _extractVerbs(tokens, cfg) {
    const common = this._commonVerbSet();
    const bins = cfg.bins || 24;

    const set = new Set();
    const posBins = new Uint8Array(bins);

    const max = cfg.maxVerbs || 64;
    const L = tokens.length || 0;

    let count = 0;
    for (let i = 0; i < L && count < max; i++) {
      const tok = tokens[i];
      if (this._isVerbLike(tok, common) && !this._isAuxVerb(tok)) {
        set.add(tok);
        const bi = Math.min(bins - 1, Math.floor((i / Math.max(1, L)) * bins));
        posBins[bi] = 1;
        count++;
      }
    }

    return { set, posBins: Array.from(posBins) };
  }

  _extractAuxVerbs(tokens, cfg) {
    const bins = cfg.bins || 24;

    const set = new Set();
    const posBins = new Uint8Array(bins);
    const L = tokens.length || 0;

    for (let i = 0; i < L; i++) {
      const tok = tokens[i];
      if (this._isAuxVerb(tok)) {
        set.add(tok);
        const bi = Math.min(bins - 1, Math.floor((i / Math.max(1, L)) * bins));
        posBins[bi] = 1;
      }
    }

    return { set, posBins: Array.from(posBins) };
  }

  _isAuxVerb(tok) {
    return (
      tok === "am" || tok === "is" || tok === "are" || tok === "was" || tok === "were" ||
      tok === "be" || tok === "been" || tok === "being" ||
      tok === "do" || tok === "does" || tok === "did" ||
      tok === "have" || tok === "has" || tok === "had" ||
      tok === "will" || tok === "would" || tok === "shall" || tok === "should" ||
      tok === "can" || tok === "could" || tok === "may" || tok === "might" || tok === "must"
    );
  }

  _commonVerbSet() {
    return new Set([
      "be","am","is","are","was","were","been","being",
      "do","does","did","doing",
      "have","has","had","having",
      "go","goes","went","gone","going",
      "get","gets","got","getting",
      "make","makes","made","making",
      "say","says","said","saying",
      "see","sees","saw","seen","seeing",
      "know","knows","knew","known","knowing",
      "think","thinks","thought","thinking",
      "take","takes","took","taken","taking",
      "come","comes","came","coming",
      "want","wants","wanted","wanting",
      "use","uses","used","using",
      "find","finds","found","finding",
      "give","gives","gave","given","giving",
      "tell","tells","told","telling",
      "work","works","worked","working",
      "call","calls","called","calling",
      "try","tries","tried","trying",
      "ask","asks","asked","asking",
      "need","needs","needed","needing",
      "feel","feels","felt","feeling",
      "become","becomes","became","becoming",
      "leave","leaves","left","leaving",
      "put","puts","putting",
      "submit","submits","submitted","submitting",
      "deliver","delivers","delivered","delivering",
      "send","sends","sent","sending",
      "receive","receives","received","receiving",
      "pay","pays","paid","paying"
    ]);
  }

  _isVerbLike(tok, common) {
    if (!tok) return false;
    if (common.has(tok)) return true;
    if (tok.endsWith("ed") && tok.length > 3) return true;
    if (tok.endsWith("ing") && tok.length > 4) return true;
    // cautious -s
    if (tok.endsWith("s") && tok.length > 3 && /[aeiou]/.test(tok)) return true;
    return false;
  }

  // =====================================================================
  // SECTION Z — Grammar heuristics extraction
  // =====================================================================

  _extractGrammarHeuristics(raw, tokens, cfg) {
    raw = raw || "";
    tokens = tokens || [];

    // Sentence split on punctuation boundaries
    const sentences = raw.split(/(?<=[.!?])\s+/g).slice(0, cfg.maxSentences || 12);

    // Sentence length histogram
    const sentenceLenHist = new Array(8).fill(0);
    for (let i = 0; i < sentences.length; i++) {
      const toks = this._tokenizeEnglish(sentences[i], this._options.factorConfig.words);
      const wc = toks.length;
      const bi = Math.min(7, Math.floor(wc / 6));
      sentenceLenHist[bi] += 1;
    }

    // Punctuation pattern set
    const punctPatternSet = new Set();
    const pseq = raw.match(/[.,;:!?]{1,3}/g) || [];
    for (let i = 0; i < pseq.length; i++) punctPatternSet.add(pseq[i]);

    // Function words
    const funcWords = this._functionWordSet();
    const functionWordSet = new Set();
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (funcWords.has(t)) functionWordSet.add(t);
    }

    // Clause markers set
    const clauseMarkersSet = new Set();
    const markerTokens = ["and","but","or","so","because","although","though","while","if","when","then","however","therefore","moreover","since","unless","whereas","that","which","who","whom"];
    const markerSet = new Set(markerTokens);
    for (let i = 0; i < tokens.length; i++) if (markerSet.has(tokens[i])) clauseMarkersSet.add(tokens[i]);
    if (raw.includes(",")) clauseMarkersSet.add(",");

    // SVO heuristic triples
    const svoTriplesSet = this._extractSVOTriples(tokens, cfg.svoWindow || 7);

    return {
      sentenceLenHist,
      punctPatternSet,
      functionWordSet,
      clauseMarkersSet,
      svoTriplesSet
    };
  }

  _functionWordSet() {
    return new Set([
      "a","an","the","this","that","these","those",
      "in","on","at","to","from","of","for","with","without","into","onto","over","under","above","below","between","among","through","during","before","after","about","around","near","by",
      "and","but","or","nor","so","yet",
      "if","then","else","when","while","because","since","although","though","unless","until","whereas",
      "i","you","he","she","it","we","they","me","him","her","us","them","my","your","his","her","our","their","mine","yours","hers","ours","theirs",
      "what","which","who","whom","whose","where","why","how",
      "not","no","yes","very","just","only","also","even","still","already",
      "be","am","is","are","was","were","been","being",
      "do","does","did","doing",
      "have","has","had","having",
      "will","would","shall","should","can","could","may","might","must"
    ]);
  }

  _extractSVOTriples(tokens, window) {
    const pron = new Set(["i","you","he","she","it","we","they","this","that","these","those","someone","something","anyone","anything"]);
    const commonVerbs = this._commonVerbSet();

    const triples = new Set();
    const maxTriples = 24;

    for (let i = 0, count = 0; i < tokens.length && count < maxTriples; i++) {
      const v = tokens[i];
      if (!this._isVerbLike(v, commonVerbs)) continue;

      // subject before
      const s0 = Math.max(0, i - window);
      let subj = "";
      for (let j = i - 1; j >= s0; j--) {
        const t = tokens[j];
        if (pron.has(t) || this._isNounLike(t)) { subj = this._coarseWordClass(t, pron); break; }
      }

      // object after
      const o1 = Math.min(tokens.length, i + 1 + window);
      let obj = "";
      for (let j = i + 1; j < o1; j++) {
        const t = tokens[j];
        if (this._isNounLike(t)) { obj = this._coarseWordClass(t, pron); break; }
      }

      const verbClass = this._coarseVerbClass(v);

      if (subj || obj) {
        triples.add(`${subj || "X"}:${verbClass}:${obj || "Y"}`);
        count++;
      }
    }

    return triples;
  }

  _isNounLike(tok) {
    if (!tok) return false;
    if (tok.length <= 2) return false;
    if (/^\d+$/.test(tok)) return false;

    const fw = this._functionWordSet();
    if (fw.has(tok)) return false;

    if (/(tion|ment|ness|ship|ism|ist|ity|ance|ence|hood|age|ery|ary|ory|ure)$/.test(tok)) return true;
    if (/^[a-z][a-z0-9']+$/.test(tok) && tok.length >= 4) return true;
    return false;
  }

  _coarseWordClass(tok, pronSet) {
    if (pronSet.has(tok)) return "PRON";
    if (/^\d+$/.test(tok)) return "NUM";
    if (this._isNounLike(tok)) return "NOUN";
    return "X";
  }

  _coarseVerbClass(tok) {
    if (!tok) return "V";
    if (tok.endsWith("ing")) return "V_ING";
    if (tok.endsWith("ed")) return "V_ED";
    if (tok === "is" || tok === "are" || tok === "was" || tok === "were" || tok === "be" || tok === "been" || tok === "being") return "AUX_BE";
    if (tok === "do" || tok === "does" || tok === "did") return "AUX_DO";
    if (tok === "have" || tok === "has" || tok === "had") return "AUX_HAVE";
    if (tok === "will" || tok === "would" || tok === "shall" || tok === "should" || tok === "can" || tok === "could" || tok === "may" || tok === "might" || tok === "must") return "MODAL";
    return "V";
  }

  // =====================================================================
  // SECTION AA — Numbers, case, spaces, punctuation, emoji, sections
  // =====================================================================

  _extractNumbers(text, maxN) {
    const re = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
    const values = [];
    const norm = [];
    let m;
    while ((m = re.exec(text)) !== null) {
      const s = m[0];
      const v = Number(s);
      if (!Number.isFinite(v)) continue;
      values.push(v);
      norm.push(this._normalizeNumberString(s));
      if (values.length >= maxN) break;
    }
    return { values, norm, normSet: new Set(norm) };
  }

  _normalizeNumberString(s) {
    s = String(s).trim();
    if (s[0] === "+") s = s.slice(1);
    s = s.replace(/E/g, "e");
    if (s.includes(".")) {
      s = s.replace(/0+$/, "");
      s = s.replace(/\.$/, "");
    }
    return s;
  }

  _relativeCloseness(a, b, eps) {
    const denom = Math.max(eps, Math.max(Math.abs(a), Math.abs(b)));
    const rel = Math.abs(a - b) / denom;
    return 1 / (1 + rel);
  }

  _extractCasePattern(raw, bins) {
    const L = raw.length || 0;
    let upper = 0, lower = 0;
    const upperBins = new Uint8Array(bins);
    const lowerBins = new Uint8Array(bins);

    for (let i = 0; i < L; i++) {
      const c = raw.charCodeAt(i);
      if (c >= 65 && c <= 90) {
        upper++;
        const bi = Math.min(bins - 1, Math.floor((i / Math.max(1, L)) * bins));
        upperBins[bi] = 1;
      } else if (c >= 97 && c <= 122) {
        lower++;
        const bi = Math.min(bins - 1, Math.floor((i / Math.max(1, L)) * bins));
        lowerBins[bi] = 1;
      }
    }

    return {
      upper,
      lower,
      upperRatio: (L > 0) ? upper / L : 0,
      lowerRatio: (L > 0) ? lower / L : 0,
      upperBins: Array.from(upperBins),
      lowerBins: Array.from(lowerBins)
    };
  }

  _extractSpacesPattern(raw, cfg) {
    const runMax = cfg.runMax || 80;
    const bins = cfg.bins || 24;

    const L = raw.length || 0;
    let spaceCount = 0;
    const runs = [];
    let cur = 0;
    const posBins = new Uint8Array(bins);

    for (let i = 0; i < L; i++) {
      const ch = raw[i];
      const isSpace = (ch === " " || ch === "\t" || ch === "\n" || ch === "\r" || ch === "\f" || ch === "\v");
      if (isSpace) {
        spaceCount++;
        cur++;
        const bi = Math.min(bins - 1, Math.floor((i / Math.max(1, L)) * bins));
        posBins[bi] = 1;
      } else {
        if (cur > 0) {
          runs.push(Math.min(runMax, cur));
          cur = 0;
        }
      }
    }
    if (cur > 0) runs.push(Math.min(runMax, cur));

    return { spaceCount, runs: runs.slice(0, 80), posBins: Array.from(posBins) };
  }

  _extractPunctuation(raw, cfg) {
    const bins = cfg.bins || 24;

    const punctChars = raw.match(/[.,;:!?'"(){}\[\]\-_/\\@#$%^&*+=<>`~|]/g) || [];
    const set = new Set(punctChars);
    const L = raw.length || 0;
    const density = (L > 0) ? punctChars.length / L : 0;

    const posBins = new Uint8Array(bins);
    if (cfg.trackPositions) {
      const maxPositions = cfg.maxPositions || 256;
      for (let i = 0, c = 0; i < L && c < maxPositions; i++) {
        const ch = raw[i];
        if (/[.,;:!?'"(){}\[\]\-_/\\@#$%^&*+=<>`~|]/.test(ch)) {
          const bi = Math.min(bins - 1, Math.floor((i / Math.max(1, L)) * bins));
          posBins[bi] = 1;
          c++;
        }
      }
    }

    return { list: punctChars, set, density, posBins: Array.from(posBins) };
  }

  _extractEmoji(raw, cfg) {
    const maxEmoji = cfg.maxEmoji || 64;
    const bins = cfg.bins || 24;

    let list = [];
    try {
      const re = /\p{Extended_Pictographic}/gu;
      const m = raw.match(re);
      if (m) list = m.slice(0, maxEmoji);
    } catch (_e) {
      const re2 = /[\u{1F300}-\u{1FAFF}\u{2600}-\u{26FF}]/gu;
      const m2 = raw.match(re2);
      if (m2) list = m2.slice(0, maxEmoji);
    }

    const set = new Set(list);

    const posBins = new Uint8Array(bins);
    const L = raw.length || 0;

    if (L > 0 && list.length > 0) {
      // best-effort scan
      let count = 0;
      for (let i = 0; i < raw.length && count < maxEmoji; i++) {
        const ch = raw[i];
        if (set.has(ch)) {
          const bi = Math.min(bins - 1, Math.floor((i / L) * bins));
          posBins[bi] = 1;
          count++;
        }
      }
    }

    return { list, set, posBins: Array.from(posBins) };
  }

  _extractSections(raw, cfg) {
    const s = raw || "";
    const first = s.slice(0, cfg.firstChars || 140);

    const L = s.length || 0;
    const start = Math.floor(L / 3);
    const second = s.slice(start, Math.min(L, start + (cfg.secondChars || 170)));

    return { first, second };
  }

  // =====================================================================
  // SECTION AB — Char & token n-grams
  // =====================================================================

  _charNGrams(str, n, maxCount) {
    const out = [];
    if (!str) return out;
    const L = str.length;
    if (L < n) return out;
    const cap = Math.min(maxCount || 1e9, L - n + 1);
    for (let i = 0; i < cap; i++) out.push(str.slice(i, i + n));
    return out;
  }

  _tokenNGrams(tokens, n, maxCount) {
    const out = [];
    if (!tokens || tokens.length < n) return out;
    const cap = Math.min(maxCount || 1e9, tokens.length - n + 1);
    for (let i = 0; i < cap; i++) out.push(tokens.slice(i, i + n).join(" "));
    return out;
  }

  // =====================================================================
  // SECTION AC — Similarities: Jaccard, bin pattern, hist, edit, Jaro-Winkler
  // =====================================================================

  _jaccardSet(a, b) {
    if (!a || !b) return 0;
    const as = a.size || 0;
    const bs = b.size || 0;
    if (as === 0 && bs === 0) return 1;
    if (as === 0 || bs === 0) return 0;

    let inter = 0;
    if (as < bs) {
      for (const x of a) if (b.has(x)) inter++;
    } else {
      for (const x of b) if (a.has(x)) inter++;
    }
    const uni = as + bs - inter;
    return uni > 0 ? inter / uni : 0;
  }

  _jaccardArr(a, b) {
    return this._jaccardSet(new Set(a || []), new Set(b || []));
  }

  _binPatternSim(a, b) {
    if (!a || !b) return 0;
    const n = Math.max(a.length, b.length);
    if (n === 0) return 1;

    let dot = 0, na = 0, nb = 0;
    for (let i = 0; i < n; i++) {
      const x = a[i] || 0;
      const y = b[i] || 0;
      dot += x * y;
      na += x * x;
      nb += y * y;
    }
    if (na === 0 && nb === 0) return 1;
    if (na === 0 || nb === 0) return 0;
    return this._clamp01(dot / (Math.sqrt(na) * Math.sqrt(nb)));
  }

  _histSim(a, b) {
    a = a || [];
    b = b || [];
    const n = Math.max(a.length, b.length);
    let sum = 0, diff = 0;
    for (let i = 0; i < n; i++) {
      const x = a[i] || 0;
      const y = b[i] || 0;
      sum += x + y;
      diff += Math.abs(x - y);
    }
    if (sum === 0) return 1;
    return this._clamp01(1 - diff / sum);
  }

  _levenshteinDistance(a, b) {
    a = a || ""; b = b || "";
    const n = a.length, m = b.length;
    if (n === 0) return m;
    if (m === 0) return n;

    // Ensure m <= n for less memory
    if (m > n) return this._levenshteinDistance(b, a);

    const prev = new Uint32Array(m + 1);
    const curr = new Uint32Array(m + 1);
    for (let j = 0; j <= m; j++) prev[j] = j;

    for (let i = 1; i <= n; i++) {
      curr[0] = i;
      const ca = a.charCodeAt(i - 1);
      for (let j = 1; j <= m; j++) {
        const cb = b.charCodeAt(j - 1);
        const cost = (ca === cb) ? 0 : 1;
        const del = prev[j] + 1;
        const ins = curr[j - 1] + 1;
        const sub = prev[j - 1] + cost;
        let v = del < ins ? del : ins;
        if (sub < v) v = sub;
        curr[j] = v;
      }
      for (let j = 0; j <= m; j++) prev[j] = curr[j];
    }
    return prev[m];
  }

  _levenshteinSim01(a, b) {
    const d = this._levenshteinDistance(a, b);
    const m = Math.max(1, a.length, b.length);
    return 1 - Math.min(1, d / m);
  }

  _commonPrefixLen(a, b, cap) {
    const n = Math.min(cap, a.length, b.length);
    let i = 0;
    for (; i < n; i++) if (a.charCodeAt(i) !== b.charCodeAt(i)) break;
    return i;
  }

  _commonSuffixLen(a, b, cap) {
    const n = Math.min(cap, a.length, b.length);
    let i = 0;
    for (; i < n; i++) {
      if (a.charCodeAt(a.length - 1 - i) !== b.charCodeAt(b.length - 1 - i)) break;
    }
    return i;
  }

  _approxEditSimLong(a, b) {
    const al = a.length, bl = b.length;
    if (al === 0 && bl === 0) return 1;
    if (al === 0 || bl === 0) return 0;

    const pre = this._commonPrefixLen(a, b, 64) / Math.min(64, Math.min(al, bl));
    const suf = this._commonSuffixLen(a, b, 64) / Math.min(64, Math.min(al, bl));
    const lenSim = 1 - Math.min(1, Math.abs(al - bl) / Math.max(al, bl));

    const sa = a.slice(0, 128) + a.slice(Math.max(0, al - 128));
    const sb = b.slice(0, 128) + b.slice(Math.max(0, bl - 128));
    const A = new Set(this._charNGrams(sa, 3, 1200));
    const B = new Set(this._charNGrams(sb, 3, 1200));
    const jac = this._jaccardSet(A, B);

    return this._clamp01(0.33 * pre + 0.27 * suf + 0.18 * lenSim + 0.22 * jac);
  }

  _jaroSim01(s1, s2) {
    const len1 = s1.length, len2 = s2.length;
    if (len1 === 0 && len2 === 0) return 1;
    if (len1 === 0 || len2 === 0) return 0;

    const matchDist = Math.floor(Math.max(len1, len2) / 2) - 1;
    const s1Matches = new Array(len1).fill(false);
    const s2Matches = new Array(len2).fill(false);

    let matches = 0;
    for (let i = 0; i < len1; i++) {
      const start = Math.max(0, i - matchDist);
      const end = Math.min(i + matchDist + 1, len2);
      for (let j = start; j < end; j++) {
        if (s2Matches[j]) continue;
        if (s1.charCodeAt(i) !== s2.charCodeAt(j)) continue;
        s1Matches[i] = true;
        s2Matches[j] = true;
        matches++;
        break;
      }
    }
    if (matches === 0) return 0;

    let k = 0;
    let trans = 0;
    for (let i = 0; i < len1; i++) {
      if (!s1Matches[i]) continue;
      while (!s2Matches[k]) k++;
      if (s1.charCodeAt(i) !== s2.charCodeAt(k)) trans++;
      k++;
    }
    trans /= 2;

    return (matches / len1 + matches / len2 + (matches - trans) / matches) / 3;
  }

  _jaroWinklerSim01(s1, s2, prefixScale) {
    const j = this._jaroSim01(s1, s2);
    const l = Math.min(4, this._commonPrefixLen(s1, s2, 4));
    const p = (typeof prefixScale === "number") ? prefixScale : 0.1;
    return this._clamp01(j + l * p * (1 - j));
  }

  // =====================================================================
  // SECTION AD — Focus application (amplifies manual weights)
  // =====================================================================

  _applyFocus(opt) {
    // Make a shallow clone to avoid mutating shared options object in caller
    const o = this._deepMerge(opt, {});
    const fw = o.factorWeights;

    const meaning = this._clampFocus(o.focus.favorMeaning);
    const numbers = this._clampFocus(o.focus.favorNumbers);
    const prefix = this._clampFocus(o.focus.favorPrefix);
    const emoji = this._clampFocus(o.focus.favorEmoji);
    const grammar = this._clampFocus(o.focus.favorGrammar);

    // Apply multipliers
    fw.humanMeaningSimilarity *= meaning;
    fw.numericSimilarity *= numbers;
    fw.firstSectionSimilarity *= prefix;
    fw.emojiSimilarity *= emoji;
    fw.followGrammarSimilarity *= grammar;

    // Keep exactness from dominating semantic by default (soft cap)
    // If user *really* wants exactness, they can still force high values, but cap prevents accidental dominance.
    const sem = fw.humanMeaningSimilarity || 1;
    const cap = 3.8 * sem;
    fw.alphabeticSimilarity = Math.min(fw.alphabeticSimilarity, cap * 0.55);
    fw.spacesSimilarity = Math.min(fw.spacesSimilarity, cap * 0.25);
    fw.punctuationSimilarity = Math.min(fw.punctuationSimilarity, cap * 0.35);

    // Re-normalize any invalids
    this._normalizeFactorWeights(o);
    return o;
  }

  _normalizeFactorWeights(opt) {
    const fw = opt.factorWeights;
    const names = this._factorNames();
    for (let i = 0; i < names.length; i++) {
      const k = names[i];
      let v = fw[k];
      if (typeof v !== "number" || !Number.isFinite(v) || v < 0) v = 0;
      fw[k] = v;
    }
  }

  _clampFocus(x) {
    if (typeof x !== "number" || !Number.isFinite(x)) return 1;
    return Math.max(0.15, Math.min(6.0, x));
  }

  // =====================================================================
  // SECTION AE — Utilities: time, rounding, deep merge, micro yield, debug
  // =====================================================================

  _now() {
    return (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
  }

  _clamp01(x) {
    if (x <= 0) return 0;
    if (x >= 1) return 1;
    return x;
  }

  _round3(x) { return Math.round(x * 1000) / 1000; }
  _round6(x) { return Math.round(x * 1000000) / 1000000; }

  _roundBreakdown(bd) {
    const out = Object.create(null);
    for (const k in bd) {
      const v = bd[k];
      if (!v || typeof v !== "object") continue;
      out[k] = {
        score01: this._round6(v.score01 ?? 0),
        weightUsed: this._round6(v.weightUsed ?? 0),
        notes: v.notes ?? ""
      };
    }
    return out;
  }

  _deepMerge(a, b) {
    if (b === null || b === undefined) return a;
    if (typeof b !== "object") return b;
    if (a === null || a === undefined) return b;
    if (typeof a !== "object") return a;

    const out = Array.isArray(a) ? a.slice() : { ...a };

    for (const k of Object.keys(b)) {
      const bv = b[k];

      // ✅ KEY FIX: do not overwrite defaults with undefined
      if (bv === undefined) continue;

      const av = out[k];
      if (
        bv && typeof bv === "object" && !Array.isArray(bv) &&
        av && typeof av === "object" && !Array.isArray(av)
      ) {
        out[k] = this._deepMerge(av, bv);
      } else {
        out[k] = bv;
      }
    }
    return out;
  }

  _safeNumTensors() {
    try {
      return (typeof tf !== "undefined" && tf.memory) ? (tf.memory().numTensors || 0) : -1;
    } catch (_e) {
      return -1;
    }
  }

  _dInfo(opt, ...args) {
    if (opt.debug && opt.debug.enabled) console.log("[UltraTextMatcherTF]", ...args);
  }

  _dWarn(opt, ...args) {
    if ((opt.debug && opt.debug.enabled) || (opt.debug && opt.debug.logWarnings)) console.warn("[UltraTextMatcherTF]", ...args);
  }

  async _pickBestBackend(preferred) {
    const prefs = Array.isArray(preferred) ? preferred : ["webgl", "cpu"];
    for (let i = 0; i < prefs.length; i++) {
      const b = prefs[i];
      try {
        await tf.setBackend(b);
        await tf.ready();
        return b;
      } catch (_e) {}
    }
    return tf.getBackend();
  }

  async _microYield(opt) {
    const s = opt.perf.microYield || {};
    if (!s.enabled) return;

    if (s.strategy === "idle" && typeof requestIdleCallback !== "undefined") {
      await new Promise((resolve) => requestIdleCallback(() => resolve(), { timeout: 16 }));
      return;
    }
    if (s.strategy === "raf" && typeof requestAnimationFrame !== "undefined") {
      await new Promise((resolve) => requestAnimationFrame(() => resolve()));
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
  }

  _pushTopK(arr, item, k) {
    if (arr.length < k) { arr.push(item); return; }
    let minI = 0;
    for (let i = 1; i < arr.length; i++) if (arr[i].score01 < arr[minI].score01) minI = i;
    if (item.score01 > arr[minI].score01) arr[minI] = item;
  }

  _hash32(s) {
    s = String(s);
    let h = 0x811c9dc5;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = (h + (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24)) >>> 0;
    }
    return h.toString(16);
  }

  // =====================================================================
  // SECTION AF — Minimal HTML usage snippet (at bottom)
  // =====================================================================
}


/* ============================================================
   Product + Conversation Search (Wrappers on UltraTextMatcherTF)
   - Assumes UltraTextMatcherTF class is already loaded (your big class)
   - Goal:
     1) Product match from sheet2 (prodData) with FIELD priorities
     2) Then message match from sheet1 (convData) with full debug output
   - Robust: missing fields ok, no crash
   - Fast: one matcher instance per dataset; heavy caches reused
   ============================================================ */

/* ---------------------------
   Small helpers (safe)
--------------------------- */
function safeStr(x) {
  if (x === null || x === undefined) return "";
  if (typeof x === "string") return x;
  if (typeof x === "number" || typeof x === "boolean") return String(x);
  try { return JSON.stringify(x); } catch { return String(x); }
}

function joinClean(arr, sep = " | ") {
  return arr.map(safeStr).map(s => s.trim()).filter(Boolean).join(sep);
}

function pick(obj, path, fallback = undefined) {
  try {
    const parts = path.split(".");
    let cur = obj;
    for (const p of parts) {
      if (!cur || typeof cur !== "object") return fallback;
      cur = cur[p];
    }
    return cur === undefined ? fallback : cur;
  } catch {
    return fallback;
  }
}

function flattenObject(obj, maxPairs = 40) {
  // "Brand: Apple; Model: iPhone 14 Pro Max; Storage: 256GB"
  if (!obj || typeof obj !== "object") return "";
  const out = [];
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length && out.length < maxPairs; i++) {
    const k = keys[i];
    const v = obj[k];
    if (v === null || v === undefined) continue;
    if (typeof v === "object") continue; // keep it shallow; avoid huge nested
    out.push(`${k}: ${safeStr(v)}`);
  }
  return out.join("; ");
}

function defaultFieldWeights() {
  return {
    name: 1.00,
    brand: 0.55,
    model: 0.60,
    tags: 0.45,
    category: 0.35,
    description: 0.30,
    specifications: 0.25,
    seller: 0.15
  };
}

function clamp01(x) {
  if (x <= 0) return 0;
  if (x >= 1) return 1;
  return x;
}

/* ============================================================
   1) ProductFieldMatcher
   - Builds ONE target list = many "field targets"
   - Each target corresponds to one product field string.
   - Runs UltraTextMatcherTF once, then aggregates results per product.
   ============================================================ */
class ProductFieldMatcher {
  constructor(products = [], options = {}) {
    this._products = Array.isArray(products) ? products : [];
    this._opt = this._deepMerge(this._defaultOptions(), options || {});
    this._matcher = null;

    // Built targets
    this._fieldTargets = [];     // [{id,text,meta}]
    this._productIndexById = new Map(); // productId -> index

    this._buildTargets();
    this._buildMatcher();
  }

  _defaultOptions() {
    return {
      // Default field weights (you can override per-call too)
      fieldWeights: defaultFieldWeights(),

      // Performance
      perf: {
        // topK for FIELD matches (not final products)
        // If you have many products, use 60-200 based on size
        topKFields: 120,
        semanticBatchSize: 64,
        maxTargetsSafety: 250000
      },

      // Product normalization controls
      extract: {
        // which fields to include
        include: ["name", "brand", "model", "tags", "category", "description", "specifications", "seller"],
        // if a text is too long, slice it (avoid huge embeds)
        maxFieldChars: {
          name: 140,
          brand: 60,
          model: 80,
          tags: 180,
          category: 80,
          description: 420,
          specifications: 520,
          seller: 80
        }
      },

      // Underlying UltraTextMatcherTF options
      matcherOptions: {
        debug: {
          enabled: false,
          logTimings: true,
          logWarnings: true,
          logBatches: false,
          logCache: false,
          logTopK: false,
          logFactorBreakdown: false,
          groupCollapsed: true
        },
        perf: {
          topK: 5, // overridden per-call
          semanticBatchSize: 64,
          microYield: { enabled: true, everyItems: 96, strategy: "timeout0" },
          timeBudgetMs: 0,
          nonSemanticFastPath: false,
          maxTargetsSafety: 250000
        },
        cache: {
          featureCache: true,
          queryFeatureCache: true,
          embeddingCache: true,
          embeddingCacheKey: "hash",
          embeddingCacheLimitMB: 192,
          autoClearAfterMatch: false
        },
        meta: {
          enabled: true,
          filter: null,
          boost: {
            importanceField: "auto",
            importanceMode: "sigmoid",
            importanceScale: 0.0,   // keep 0 by default for products (we use fieldWeight)
            clampAdd: 0.15,
            clampMultMin: 0.85,
            clampMultMax: 1.15
          },
          includeMetaInDiagnostics: false
        },
        focus: {
          favorMeaning: 1.25,
          favorNumbers: 1.25,
          favorPrefix: 1.15,
          favorEmoji: 1.0,
          favorGrammar: 1.1,
          favorMorphology: 1.05,
          favorTokens: 1.2,
          favorPunctuation: 1.0,
          favorCase: 1.0
        }
      }
    };
  }

  _deepMerge(a, b) {
    if (b === null || b === undefined) return a;
    if (typeof b !== "object") return b;
    if (a === null || a === undefined) return b;
    if (typeof a !== "object") return a;

    const out = Array.isArray(a) ? a.slice() : { ...a };
    for (const k of Object.keys(b)) {
      const bv = b[k];
      const av = out[k];
      if (bv && typeof bv === "object" && !Array.isArray(bv) && av && typeof av === "object" && !Array.isArray(av)) {
        out[k] = this._deepMerge(av, bv);
      } else {
        out[k] = bv;
      }
    }
    return out;
  }

  _sliceField(text, fieldKey) {
    const m = this._opt.extract.maxFieldChars || {};
    const cap = (typeof m[fieldKey] === "number") ? m[fieldKey] : 500;
    const s = safeStr(text).trim();
    if (!s) return "";
    return (s.length > cap) ? (s.slice(0, cap) + "…") : s;
  }

  _extractBrand(prod) {
    // brand might be prod.brand or prod.specifications.Brand
    const b1 = pick(prod, "brand", "");
    if (b1) return b1;
    const b2 = pick(prod, "specifications.Brand", "");
    if (b2) return b2;
    const b3 = pick(prod, "specifications.brand", "");
    if (b3) return b3;
    return "";
  }

  _extractModel(prod) {
    const m1 = pick(prod, "model", "");
    if (m1) return m1;
    const m2 = pick(prod, "specifications.Model", "");
    if (m2) return m2;
    const m3 = pick(prod, "specifications.model", "");
    if (m3) return m3;
    return "";
  }

  _extractSeller(prod) {
    return pick(prod, "seller", pick(prod, "sellerId", ""));
  }

  _buildTargets() {
    this._fieldTargets = [];
    this._productIndexById.clear();

    const include = new Set(this._opt.extract.include || []);
    const fw = this._opt.fieldWeights || defaultFieldWeights();

    for (let i = 0; i < this._products.length; i++) {
      const p = this._products[i] || {};
      const pid = (p.id !== undefined && p.id !== null) ? String(p.id) : String(i);
      this._productIndexById.set(pid, i);

      const name = include.has("name") ? this._sliceField(p.name, "name") : "";
      const category = include.has("category") ? this._sliceField(p.category, "category") : "";
      const description = include.has("description") ? this._sliceField(p.description, "description") : "";
      const tags = include.has("tags") ? this._sliceField(Array.isArray(p.tags) ? p.tags.join(" ") : "", "tags") : "";
      const brand = include.has("brand") ? this._sliceField(this._extractBrand(p), "brand") : "";
      const model = include.has("model") ? this._sliceField(this._extractModel(p), "model") : "";
      const specs = include.has("specifications") ? this._sliceField(flattenObject(p.specifications), "specifications") : "";
      const seller = include.has("seller") ? this._sliceField(this._extractSeller(p), "seller") : "";

      // Create one target per field so we can attribute score to field
      const fields = [
        ["name", name],
        ["brand", brand],
        ["model", model],
        ["tags", tags],
        ["category", category],
        ["description", description],
        ["specifications", specs],
        ["seller", seller]
      ];

      for (const [fieldKey, fieldText] of fields) {
        const text = safeStr(fieldText).trim();
        if (!text) continue;

        const weight = (typeof fw[fieldKey] === "number") ? fw[fieldKey] : 0.2;

        // id must be unique; tie back to product+field
        const fid = `${pid}::${fieldKey}`;

        this._fieldTargets.push({
          id: fid,
          text,
          meta: {
            kind: "product_field",
            productId: pid,
            productIndex: i,
            field: fieldKey,
            fieldWeight: weight
          }
        });
      }
    }
  }

  _buildMatcher() {
    // One UltraTextMatcherTF instance for all product-field targets
    this._matcher = new UltraTextMatcherTF(this._fieldTargets, {
      ...this._opt.matcherOptions,
      perf: {
        ...(this._opt.matcherOptions?.perf || {}),
        semanticBatchSize: this._opt.perf.semanticBatchSize
      }
    });
  }

  async init() {
    if (!this._matcher) this._buildMatcher();
    await this._matcher.init();
  }

  setProducts(products) {
    this._products = Array.isArray(products) ? products : [];
    this._buildTargets();
    if (this._matcher) {
      // reuse same model instance, just update targets
      this._matcher.setTargets(this._fieldTargets);
    } else {
      this._buildMatcher();
    }
  }

  /**
   * Match products by query, with field priorities.
   * @param {string} query
   * @param {object} opts
   *  - topKProducts: final products count
   *  - topKFields: how many field-hits to retrieve from matcher (bigger => better recall)
   *  - fieldWeights: override weights {name,brand,tags,...}
   *  - focus: UltraTextMatcherTF focus overrides
   *  - factorWeights: UltraTextMatcherTF factorWeights overrides
   *  - debug: UltraTextMatcherTF debug overrides
   *  - keywordBoost: { words: ["iphone","pro"], addPerHit: 0.02, maxAdd: 0.08 } (optional)
   */
  async matchProducts(query, opts = {}) {
    await this.init();

    const topKProducts = Math.max(1, (opts.topKProducts ?? 5) | 0);
    const topKFields = Math.max(5, (opts.topKFields ?? this._opt.perf.topKFields) | 0);

    const perCallFieldWeights = { ...(this._opt.fieldWeights || {}), ...(opts.fieldWeights || {}) };

    // Optional small keyword boost (prioritize messages/products containing key words)
    const keywordBoost = opts.keywordBoost || null;
    const boostWords = keywordBoost?.words?.map(w => String(w).toLowerCase()).filter(Boolean) || [];
    const addPerHit = (typeof keywordBoost?.addPerHit === "number") ? keywordBoost.addPerHit : 0.02;
    const maxAdd = (typeof keywordBoost?.maxAdd === "number") ? keywordBoost.maxAdd : 0.08;

    // Run field-level match
    const raw = await this._matcher.match(query, null, {
      perf: { topK: topKFields },
      focus: { ...(opts.focus || {}) },
      factorWeights: { ...(opts.factorWeights || {}) },
      debug: (opts.debug ? { ...(opts.debug || {}) } : undefined),

      // Meta boost: apply fieldWeight + optional keywordBoost (small)
      meta: {
        enabled: true,
        boost: (meta, text) => {
          const field = String(meta?.field || "");
          const fw = (typeof perCallFieldWeights[field] === "number") ? perCallFieldWeights[field] : (typeof meta?.fieldWeight === "number" ? meta.fieldWeight : 0.2);

          // multiplier from field weight (keep gentle)
          // fw ~ 0.15..1.0 => mult ~ 0.90..1.18
          const mult = 0.90 + 0.28 * clamp01(fw);

          let add = 0;
          if (boostWords.length) {
            const t = String(text || "").toLowerCase();
            let hits = 0;
            for (const w of boostWords) if (t.includes(w)) hits++;
            if (hits > 0) add = Math.min(maxAdd, hits * addPerHit);
          }
          return { multScore: mult, addScore01: add, notes: `field=${field} fw=${fw} mult=${mult.toFixed(3)} kwAdd=${add.toFixed(3)}` };
        }
      }
    });

    // Aggregate field-hits into product-level results
    const byProd = new Map();

    const fieldHits = raw.results || [];
    for (const hit of fieldHits) {
      const meta = hit?.diagnostics?.metaBoost ? undefined : undefined; // keep raw payload small
      const d = hit?.diagnostics || {};
      const m = d?.meta || undefined;

      // We didn’t include meta in diagnostics; so parse from id "pid::field"
      const id = String(d.id || hit.index || "");
      let pid = "";
      let field = "";
      const parts = id.split("::");
      if (parts.length >= 2) { pid = parts[0]; field = parts[1]; }

      // fallback: parse from embedKey if needed
      if (!pid) pid = parts[0] || "";

      const pIndex = this._productIndexById.has(pid) ? this._productIndexById.get(pid) : null;
      if (pIndex === null || pIndex === undefined) continue;

      const fw = (typeof perCallFieldWeights[field] === "number") ? perCallFieldWeights[field] : 0.2;

      // Weighted score (but keep bounded)
      // Use the already meta-boosted hit.score01 as base, then apply a mild extra by fw
      const weighted = clamp01(hit.score01 * (0.92 + 0.20 * clamp01(fw)));

      const cur = byProd.get(pid) || {
        productId: pid,
        productIndex: pIndex,
        bestScore01: 0,
        bestConfidence01: 0,
        bestField: "",
        bestFieldText: "",
        fieldEvidence: [] // top field hits
      };

      // store evidence (limited)
      cur.fieldEvidence.push({
        field,
        score01: hit.score01,
        weightedScore01: weighted,
        confidence01: hit.confidence01,
        textMatched: hit.text
      });

      // choose best
      if (weighted > cur.bestScore01) {
        cur.bestScore01 = weighted;
        cur.bestConfidence01 = hit.confidence01;
        cur.bestField = field;
        cur.bestFieldText = hit.text;
      }

      byProd.set(pid, cur);
    }

    // Final product ranking
    const ranked = Array.from(byProd.values())
      .map(r => {
        // sort evidence high to low
        r.fieldEvidence.sort((a, b) => b.weightedScore01 - a.weightedScore01);
        r.fieldEvidence = r.fieldEvidence.slice(0, 6);

        // Confidence shaping: combine best field confidence + evidence strength
        const second = r.fieldEvidence[1]?.weightedScore01 ?? 0;
        const gap = clamp01((r.bestScore01 - second) / 0.25);
        const conf = clamp01((r.bestConfidence01 * 0.80) + (0.20 * gap));

        return {
          ...r,
          confidence01: conf
        };
      })
      .sort((a, b) => b.bestScore01 - a.bestScore01)
      .slice(0, topKProducts);

    // Attach full product objects
    const results = ranked.map(r => ({
      product: this._products[r.productIndex],
      productId: r.productId,
      productIndex: r.productIndex,
      score01: Number(r.bestScore01.toFixed(6)),
      confidence01: Number(r.confidence01.toFixed(6)),
      bestField: r.bestField,
      fieldEvidence: r.fieldEvidence
    }));

    return {
      query: safeStr(query),
      topKProducts,
      topKFields,
      results,
      debug: {
        fieldMatchRaw: raw // includes factors breakdown etc from UltraTextMatcherTF
      }
    };
  }
}

/* ============================================================
   2) ConversationMatcher (sheet1)
   - Matches user_message and returns support_message + meta
   ============================================================ */
class ConversationMatcher {
  constructor(convRows = [], options = {}) {
    this._rows = Array.isArray(convRows) ? convRows : [];
    this._opt = this._deepMerge(this._defaultOptions(), options || {});
    this._matcher = new UltraTextMatcherTF(this._makeTargets(), this._opt.matcherOptions);
  }

  _defaultOptions() {
    return {
      matcherOptions: {
        debug: {
          enabled: false,
          logTimings: true,
          logWarnings: true,
          logBatches: false,
          logCache: false,
          logTopK: false,
          logFactorBreakdown: false,
          groupCollapsed: true
        },
        perf: {
          topK: 5,
          semanticBatchSize: 64,
          microYield: { enabled: true, everyItems: 96, strategy: "timeout0" },
          timeBudgetMs: 0,
          nonSemanticFastPath: false,
          maxTargetsSafety: 200000
        },
        cache: {
          featureCache: true,
          queryFeatureCache: true,
          embeddingCache: true,
          embeddingCacheKey: "hash",
          embeddingCacheLimitMB: 192,
          autoClearAfterMatch: false
        },
        meta: {
          enabled: true,
          filter: null,
          boost: {
            importanceField: "auto",
            importanceMode: "sigmoid",
            importanceScale: 0.08,
            clampAdd: 0.20,
            clampMultMin: 0.80,
            clampMultMax: 1.25
          },
          includeMetaInDiagnostics: false
        },
        focus: {
          favorMeaning: 1.35,
          favorNumbers: 1.25,
          favorTokens: 1.25,
          favorGrammar: 1.1,
          favorPrefix: 1.1
        }
      }
    };
  }

  _deepMerge(a, b) {
    if (b === null || b === undefined) return a;
    if (typeof b !== "object") return b;
    if (a === null || a === undefined) return b;
    if (typeof a !== "object") return a;

    const out = Array.isArray(a) ? a.slice() : { ...a };
    for (const k of Object.keys(b)) {
      const bv = b[k];
      const av = out[k];
      if (bv && typeof bv === "object" && !Array.isArray(bv) && av && typeof av === "object" && !Array.isArray(av)) {
        out[k] = this._deepMerge(av, bv);
      } else {
        out[k] = bv;
      }
    }
    return out;
  }

  _makeTargets() {
    const t = [];
    for (let i = 0; i < this._rows.length; i++) {
      const r = this._rows[i] || {};
      const id = (r.id !== undefined && r.id !== null) ? String(r.id) : String(i);
      const text = safeStr(r.user_message || r.userMessage || "");
      const meta = r.meta || r.metadata || { type: "chat" };
      t.push({ id, text, meta });
    }
    return t;
  }

  async init() {
    await this._matcher.init();
  }

  setRows(convRows) {
    this._rows = Array.isArray(convRows) ? convRows : [];
    this._matcher.setTargets(this._makeTargets());
  }

  async matchUserMessage(query, opts = {}) {
    await this.init();

    const topK = Math.max(1, (opts.topK ?? 5) | 0);

    const out = await this._matcher.match(query, null, {
      perf: { topK },
      focus: { ...(opts.focus || {}) },
      factorWeights: { ...(opts.factorWeights || {}) },
      debug: (opts.debug ? { ...(opts.debug || {}) } : undefined),
      meta: opts.metaOverride ? opts.metaOverride : undefined
    });

    // Attach support_message + row info
    const results = (out.results || []).map(r => {
      const row = this._rows[r.index] || null;
      return {
        ...r,
        rowId: row?.id ?? r.diagnostics?.id ?? null,
        user_message: row?.user_message ?? row?.userMessage ?? null,
        support_message: row?.support_message ?? row?.supportMessage ?? null,
        rowMeta: row?.meta ?? row?.metadata ?? null
      };
    });

    return { ...out, results };
  }
}

/* ============================================================
   3) Pipeline: Product first, then Message
   - Finds best product, then matches conversation with same user input
   - Also returns both debug outputs
   ============================================================ */
class ProductThenMessageSearch {
  constructor(prodData, convData, options = {}) {
    this.productMatcher = new ProductFieldMatcher(prodData, options.product || {});
    this.convMatcher = new ConversationMatcher(convData, options.conversation || {});
  }

  async init() {
    await this.productMatcher.init();
    await this.convMatcher.init();
  }

  /**
   * @param {string} userInput
   * @param {object} opts
   *  - product: options for matchProducts(...)
   *  - conversation: options for matchUserMessage(...)
   *  - conversationQueryStrategy: "raw" | "appendProductName"
   */
  async run(userInput, opts = {}) {
    await this.init();

    const productOut = await this.productMatcher.matchProducts(userInput, opts.product || {});
    const bestProduct = productOut.results?.[0]?.product || null;

    const strategy = opts.conversationQueryStrategy || "raw";
    let convQuery = userInput;

    if (strategy === "appendProductName" && bestProduct?.name) {
      convQuery = `${userInput} | ${bestProduct.name}`;
    }

    const messageOut = await this.convMatcher.matchUserMessage(convQuery, opts.conversation || {});

    return {
      userInput,
      bestProduct,
      productOut,
      messageOut
    };
  }
}

/* ============================================================
   USAGE (with your fetchJsonRobust + sheets)
   ============================================================ */
async function fetchJsonRobust(url) {
  try {
    const res = await fetch(url, { method: "GET", mode: "cors" });
    const text = await res.text();
    try {
      return JSON.parse(text);
    } catch (e) {
      const cleaned = text.replace(/^[^{[]*/, '').replace(/[^}\]]*$/, '');
      try { return JSON.parse(cleaned); } catch (e2) { console.error("Failed to parse JSON:", url); return []; }
    }
  } catch (error) {
    console.error("Fetch failed:", url, error);
    return [];
  }
}
// 1) Load sheets, 2) build matchers once, 3) run searches many times
async function buildSearchSystem() {
  const [convData, prodData] = await Promise.all([
    fetchJsonRobust("https://script.google.com/macros/s/AKfycbxJec3yxCqQa9QjEapTDl2wlF-ETSumFWwRe5CoAWmn2DcSWOXbba0Auex32_DgCW4liQ/exec"),
    fetchJsonRobust("https://script.google.com/macros/s/AKfycbxHEm4DNrxnqzXvD2Ums6TszXMvyoQEgGMjdnIKiKEngtWH5AeFKpbLyyixjhNB2ZhBGA/exec")
  ]);

  // Create system
  const system = new ProductThenMessageSearch(prodData, convData, {
    product: {
      fieldWeights: { name: 2.0, brand: 0.55, model: 0.90, tags: 0.45, specifications: 0.25, description: 0.30 },
      perf: { topKFields: 140 },
      matcherOptions: {
        debug: { enabled: true, logTimings: true, logTopK: false },
        focus: { favorMeaning: 1.35, favorNumbers: 1.45, favorTokens: 1.25 }
      }
    },
    conversation: {
      matcherOptions: {
        debug: { enabled: true, logTimings: true, logTopK: true }
      }
    }
  });

  await system.init();
  console.log("✅ Search system ready");
  return system;
}

const dhakaRawList = [
  "dhaka", "daka", "dhakaa", "dakaa", "gazipur", "gajipur", "gazipurr", "narayanganj", "narayangonj", "narayongonj", "naryanganj", "narsingdi", "narsingdy", "norsingdi", "narsindi", "munshiganj", "munshigonj", "munsiganj", "munsigonj", "manikganj", "manikgonj", "tangail", "tangal", "tangailly", "kishoreganj", "kishoregonj", "kishorganj", "kisorupganj", "faridpur", "foridpur", "pharidpur", "madaripur", "madaripurr", "rajbari", "razbari", "shariatpur", "shariatpurr", "sariatpur", "gopalganj", "gopalgonj", "gupalganj",
  "dhamrai", "damrai", "dohar", "duhar", "keraniganj", "keranigonj", "keraniganj", "nawabganj", "nawabgonj", "nababganj", "savar", "sabor", "shavar", "ashulia", "asulia", "ashulya", "kaliakair", "kaliakor", "kaliganj", "kaligonj", "kapasia", "kapasya", "sreepur", "sripur", "shreepur", "tongi", "tungi", "konabari", "kunabari", "araihazar", "araihazat", "bandar", "bondar", "rupganj", "rupgonj", "sonargaon", "sonarga", "sonargaonr", "fatullah", "fatulla", "siddhirganj", "siddhirgonj", "shiddirganj", "belabo", "monohardi", "manohardi", "palash", "palas", "raipura", "raypura", "shibpur", "sibpur", "madhabdi", "madobdi", "ghorashal", "ghorashol", "lohajang", "lohojang", "sirajdikhan", "sirajdikhanr", "sreenagar", "srinagar", "shreenagar", "tongibari", "tungibari", "mirkadim", "mirkadimr", "singair", "singayer", "shivalaya", "shibaloy", "saturia", "shaturia", "harirampur", "horirampur", "ghior", "gheor", "daulatpur", "dowlatpur",
  "adabor", "adaborr", "badda", "badda", "vadda", "banani", "bonani", "bangshal", "bongshal", "bangshalr", "cantonment", "cantonmentr", "chawkbazar", "chokbazar", "chowkbazar", "demra", "demara", "dhanmondi", "dhanmondy", "danmondi", "gulshan", "gulshan1", "gulshan2", "gulshon", "hazaribagh", "hazaribag", "jatrabari", "jatrabari", "jatrabary", "kadamtali", "kodomtoli", "kafrul", "koprul", "kalabagan", "kolabagan", "kamrangirchar", "kamrangirchor", "khilgaon", "khilgon", "khilkhet", "khilkhet", "kotwali", "kotoyali", "lalbagh", "lalbag", "mirpur", "mirpur1", "mirpur10", "mirpur2", "mirpur12", "mirpur11", "mirpur14", "mohammadpur", "mohammadpurr", "mohamadpur", "motijheel", "matijheel", "motijhil", "newmarket", "neumarket", "pallabi", "pallabi", "paltan", "poltan", "ramna", "romna", "rampura", "rompura", "sabujbagh", "sobujbag", "shahbagh", "shahbag", "shabagh", "shyampur", "shampur", "sutrapur", "shutrapur", "tejgaon", "tejgaonr", "tejgon", "turag", "turag", "uttara", "utara", "uttara10", "uttarkhan", "uttorkhan", "dakshinkhan", "dokshinkhan", "vatara", "batara", "wari", "owari", "uoyari", "segunbagicha", "segunbagicha", "farmgate", "farmgate", "farmget", "mohakhali", "mohakhali", "mohakhali", "eskaton", "iskaton", "malibagh", "malibag", "basabo", "bashabo", "banasree", "bonosree", "aftabnagar", "aftabnagar", "niketan", "niketon", "nikunja", "nikunja"
];

// ✅ Drop-in replacement (keeps the same class name) — backward compatible
// - Accepts 3rd arg as either userInputVar (string) OR options object
// - Stores last 2 user inputs + last 2 final texts
// - Extracts payment/contact/transaction info from last 4 texts (2 inputs + 2 outputs)
// - Delivery charge placeholder logic based on delivery words + Dhaka-area location detection
// - Lots of console logging, but otherwise “hidden work” (no UI changes)

class ResponseFilter {
  static STORAGE_KEY = "ResponseFilter::state_v2";

  constructor(products, responses, userInputVarOrOptions = {}) {
    if (!products || !responses) {
      throw new Error("There was a problem with products or responses!");
    }

    // Backward compatible handling:
    // Your current call is: new ResponseFilter(products, responses, userInputVar)
    // Here we support both:
    //   - (products, responses, "user input string")
    //   - (products, responses, { userInputVar: "...", minProductConfidence: ... })
    const isStringArg = typeof userInputVarOrOptions === "string";
    const options = isStringArg ? {} : (userInputVarOrOptions ?? {});
    this.userInputVar = isStringArg ? userInputVarOrOptions : (options.userInputVar ?? "");

    // If the page was refreshed (reload), reset the saved state
    if (ResponseFilter.#isReloadSafe()) {
      console.log("[ResponseFilter] Reload detected → clearing storage");
      ResponseFilter.clearStorage();
    }

    this.products = products;
    this.responses = responses;

    this.minProductConfidence = options.minProductConfidence ?? 0.60;
    this.minMessageConfidence = options.minMessageConfidence ?? 0.70;
    this.currency = options.currency ?? "৳";

    this.productList = [];

    // Load old state (history + extracted info)
    this.state = ResponseFilter.loadFromStorage() ?? ResponseFilter.#defaultState();
    console.log("[ResponseFilter] Loaded state:", this.state);

    // Store product info
    this.storeProduct();

    // Save current state (will also update after replacePlaceholders)
    this.saveToStorage();
  }

  // ------------------------------
  // Product storing
  // ------------------------------
  storeProduct() {
    const product = this.products?.[0];
    if (!product) {
      console.log("[ResponseFilter] No product found to store");
      return;
    }

    if (product.confidence01 > this.minProductConfidence) {
      this.productList.push(product.product);
      console.log("[ResponseFilter] Stored product:", product.product);
    } else if (product.confidence01 > 0.5) {
      console.log(
        "[ResponseFilter] Product confidence < 0.60 but > 0.50:",
        product.confidence01
      );
    } else {
      console.log("[ResponseFilter] Product confidence very low:", product.confidence01);
    }
  }

  // ------------------------------
  // Placeholder replacing + intelligence layer
  // ------------------------------
  replacePlaceholders() {
    let text = this.responses?.[0]?.support_message;

    if (!text) {
      console.log("[ResponseFilter] No support_message found");
      return text ?? "";
    }

    // 1) Standard product placeholder logic (existing behavior)
    text = this.#replaceProductPlaceholders(text);

    // 2) Delivery charge placeholder logic (new)
    // Decide delivery charge BEFORE storing current output, using:
    // last (up to) 2 inputs + current input + last (up to) 2 outputs  => up to 5,
    // but we only need “last 4 texts” idea; we’ll use:
    // prev 1 input + current input + prev 2 outputs (max 4) as pre-context.
    text = this.#replaceDeliveryChargePlaceholder(text);

    // 3) Now we have a “final text” for this call.
    // Store history (last 2 user inputs + last 2 final texts)
    this.#storeConversationTurn(this.userInputVar, text);

    // 4) Extract payment/contact/transaction info from last 4 texts (2 inputs + 2 outputs)
    this.#extractAndSaveSignalsFromLastFourTexts();

    // 5) Save updated state
    this.saveToStorage();

    console.log("[ResponseFilter] Final output text:", text);
    return text;
  }

  #replaceProductPlaceholders(text) {
    if (this.productList.length === 0) return text;

    const placeholders = [...text.matchAll(/\[([^\]]+)\]/g)].map((m) => m[1]);
    const firstProduct = this.productList[0];
    const lastProduct = this.productList[this.productList.length - 1];

    if (placeholders.includes("last_product")) {
      text = text.replaceAll("[last_product]", lastProduct?.name ?? "");
      if (placeholders.includes("price")) {
        text = text.replaceAll(
          "[price]",
          `${lastProduct?.price ?? ""}${this.currency}`
        );
      }
    }

    if (placeholders.includes("first_product")) {
      text = text.replaceAll("[first_product]", firstProduct?.name ?? "");
      if (placeholders.includes("price")) {
        text = text.replaceAll(
          "[price]",
          `${firstProduct?.price ?? ""}${this.currency}`
        );
      }
    }

    return text;
  }

  #replaceDeliveryChargePlaceholder(text) {
    const hasDeliveryChargePlaceholder = /\[delivery_charge\]/i.test(text);
    if (!hasDeliveryChargePlaceholder) return text;

    const lastInputs = this.state.history.userInputs.slice(-1); // prev 1
    const lastOutputs = this.state.history.finalTexts.slice(-2); // prev 2
    const preContext = [...lastInputs, this.userInputVar, ...lastOutputs]
      .filter(Boolean)
      .slice(-4);

    const joined = preContext.join(" \n ");
    const deliveryMentioned = ResponseFilter.#containsDeliveryTopic(joined);
    const hasDhakaLocation = ResponseFilter.#containsDhakaLocation(joined);

    console.log("[ResponseFilter] Delivery pre-context (last up to 4 texts):", preContext);
    console.log("[ResponseFilter] deliveryMentioned:", deliveryMentioned);
    console.log("[ResponseFilter] hasDhakaLocation:", hasDhakaLocation);

    const charge = deliveryMentioned && hasDhakaLocation ? 60 : 120;
    const replaceValue = `${charge}${this.currency}`;

    console.log(
      `[ResponseFilter] Replacing [delivery_charge] with: ${replaceValue} (DhakaMatch=${hasDhakaLocation})`
    );

    return text.replaceAll("[delivery_charge]", replaceValue);
  }

  // ------------------------------
  // History storage (last 2 + last 2)
  // ------------------------------
  #storeConversationTurn(userInput, finalText) {
    const inputStr = String(userInput ?? "").trim();
    const outputStr = String(finalText ?? "").trim();

    if (inputStr) {
      this.state.history.userInputs.push(inputStr);
      this.state.history.userInputs = this.state.history.userInputs.slice(-2);
      console.log("[ResponseFilter] Saved user input history:", this.state.history.userInputs);
    }

    if (outputStr) {
      this.state.history.finalTexts.push(outputStr);
      this.state.history.finalTexts = this.state.history.finalTexts.slice(-2);
      console.log("[ResponseFilter] Saved final text history:", this.state.history.finalTexts);
    }
  }

  // ------------------------------
  // Extraction logic (payment/contact/transaction)
  // ------------------------------
  #extractAndSaveSignalsFromLastFourTexts() {
    const inputs = this.state.history.userInputs.slice(-2);
    const outputs = this.state.history.finalTexts.slice(-2);
    const lastFour = [...inputs, ...outputs].filter(Boolean).slice(-4);

    const joined = lastFour.join("\n");
    console.log("[ResponseFilter] Analyzing last 4 texts:", lastFour);

    const paymentTopic = ResponseFilter.#containsPaymentTopic(joined);
    const deliveryTopic = ResponseFilter.#containsDeliveryTopic(joined);
    const methodsFound = ResponseFilter.#extractBangladeshPaymentMethods(joined);

    // 11-digit BD numbers starting with 01
    const numbers01 = ResponseFilter.#extractPhoneNumbers01(joined);

    // Contact number logic:
    // if phone/mobile/contact keywords exist AND number exists => store as contactNumber
    const contactTopic = ResponseFilter.#containsContactTopic(joined);
    const contactNumber = contactTopic && numbers01.length ? numbers01[0] : null;

    // Payment number logic:
    // if payment topic AND number exists => store as paymentNumber
    const paymentNumber = paymentTopic && numbers01.length ? numbers01[0] : null;

    // Transaction ID logic:
    const transactionId = ResponseFilter.#extractTransactionId(joined);

    console.log("[ResponseFilter] paymentTopic:", paymentTopic);
    console.log("[ResponseFilter] deliveryTopic:", deliveryTopic);
    console.log("[ResponseFilter] contactTopic:", contactTopic);
    console.log("[ResponseFilter] numbers01 found:", numbers01);
    console.log("[ResponseFilter] payment methods found:", methodsFound);
    console.log("[ResponseFilter] transactionId found:", transactionId);

    // Update state dictionary
    const prev = this.state.signals.paymentInfo ?? {};
    const now = Date.now();

    // Only set fields when detected (don’t overwrite with null)
    const nextPaymentInfo = {
      ...prev,
      paymentNumber: paymentNumber ?? prev.paymentNumber ?? null,
      contactNumber: contactNumber ?? prev.contactNumber ?? null,
      methods: Array.from(new Set([...(prev.methods ?? []), ...methodsFound])),
      transactionId: transactionId ?? prev.transactionId ?? null,
      lastFourTexts: lastFour,
      updatedAt: now,
    };

    // Extra: if payment topic AND any method found but no number, still store methods.
    // Extra: if payment topic AND number found but no method, store number anyway.

    // If payment-related mention exists and we found a number and/or methods or trxid, save.
    const shouldSave =
      paymentTopic ||
      methodsFound.length > 0 ||
      transactionId ||
      (contactTopic && contactNumber);

    if (shouldSave) {
      this.state.signals.paymentInfo = nextPaymentInfo;
      console.log("[ResponseFilter] Updated paymentInfo:", this.state.signals.paymentInfo);
    } else {
      console.log("[ResponseFilter] No strong payment/contact/trx signal → not updating paymentInfo");
    }

    // Save delivery signal snapshot too (optional but useful)
    const hasDhakaLocation = ResponseFilter.#containsDhakaLocation(joined);
    this.state.signals.deliveryInfo = {
      deliveryTopic,
      hasDhakaLocation,
      lastFourTexts: lastFour,
      updatedAt: now,
    };
    console.log("[ResponseFilter] Updated deliveryInfo:", this.state.signals.deliveryInfo);
  }

  // ------------------------------
  // localStorage helpers
  // ------------------------------
  saveToStorage() {
    try {
      const stateToSave = {
        ...this.state,
        config: {
          minProductConfidence: this.minProductConfidence,
          minMessageConfidence: this.minMessageConfidence,
          currency: this.currency,
        },
        products: this.products,
        responses: this.responses,
        productList: this.productList,
        savedAt: Date.now(),
      };

      if (ResponseFilter.#hasLocalStorage()) {
        localStorage.setItem(ResponseFilter.STORAGE_KEY, JSON.stringify(stateToSave));
        console.log("[ResponseFilter] Saved state to localStorage");
      } else {
        console.log("[ResponseFilter] localStorage not available → skipping save");
      }
    } catch (e) {
      console.log("[ResponseFilter] saveToStorage error:", e);
    }
  }

  static loadFromStorage() {
    try {
      if (!ResponseFilter.#hasLocalStorage()) return null;

      const raw = localStorage.getItem(ResponseFilter.STORAGE_KEY);
      if (!raw) return null;

      const parsed = JSON.parse(raw);
      // Ensure structure safety
      const safe = {
        ...ResponseFilter.#defaultState(),
        ...parsed,
        history: {
          ...ResponseFilter.#defaultState().history,
          ...(parsed.history ?? {}),
        },
        signals: {
          ...ResponseFilter.#defaultState().signals,
          ...(parsed.signals ?? {}),
        },
      };

      return safe;
    } catch (e) {
      console.log("[ResponseFilter] loadFromStorage error:", e);
      return null;
    }
  }

  static clearStorage() {
    try {
      if (!ResponseFilter.#hasLocalStorage()) return;
      localStorage.removeItem(ResponseFilter.STORAGE_KEY);
    } catch (e) {
      console.log("[ResponseFilter] clearStorage error:", e);
    }
  }

  // ------------------------------
  // Safety + defaults
  // ------------------------------
  static #defaultState() {
    return {
      history: {
        userInputs: [],
        finalTexts: [],
      },
      signals: {
        paymentInfo: {
          paymentNumber: null,
          contactNumber: null,
          methods: [],
          transactionId: null,
          lastFourTexts: [],
          updatedAt: null,
        },
        deliveryInfo: {
          deliveryTopic: false,
          hasDhakaLocation: false,
          lastFourTexts: [],
          updatedAt: null,
        },
      },
      config: {},
      savedAt: null,
    };
  }

  static #hasLocalStorage() {
    try {
      return typeof localStorage !== "undefined";
    } catch {
      return false;
    }
  }

  static #isReloadSafe() {
    try {
      const perf = typeof performance !== "undefined" ? performance : null;
      const nav = perf?.getEntriesByType?.("navigation")?.[0];
      return nav?.type === "reload";
    } catch {
      return false;
    }
  }

  // ------------------------------
  // Text detection helpers
  // ------------------------------
  static #norm(s) {
    return String(s ?? "")
      .toLowerCase()
      .replace(/[\u09E6-\u09EF]/g, (d) => "০১২৩৪৫৬৭৮৯".indexOf(d)) // basic bn-digit mapping (best-effort)
      .replace(/[^a-z0-9\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  static #containsAny(normText, patterns) {
    return patterns.some((p) => {
      if (p instanceof RegExp) return p.test(normText);
      return normText.includes(String(p));
    });
  }

  static #extractPhoneNumbers01(text) {
    // Accept both raw and normalized scanning (raw keeps digits intact)
    const raw = String(text ?? "");
    const matches = raw.match(/\b01\d{9}\b/g) ?? [];
    return Array.from(new Set(matches));
  }

  static #containsPaymentTopic(text) {
    const t = ResponseFilter.#norm(text);

    // payment related + common typos
    const patterns = [
      "payment",
      "paymnt",
      "paymant",
      "paymet",
      "pament",
      "pymnt",
      "paid",
      "pay",
      "bkash",
      "b kash",
      "nagad",
      "nogod",
      "rocket",
      "roket",
      "upay",
      "upai",
      "bank",
      "card",
      "visa",
      "master",
      "debit",
      "credit",
      "cod",
      "cash on delivery",
      "cash",
      "advance",
      "due",
      "baki",
      "bakii",
      "baki",
      "bk",
      "nagad",
      "trx",
      "trnx",
      "txid",
      "transaction",
      "transection",
      "transfer",
      "send money",
      "sendmoney",
    ];

    return ResponseFilter.#containsAny(t, patterns);
  }

  static #containsContactTopic(text) {
    const t = ResponseFilter.#norm(text);
    const patterns = [
      "phone",
      "fone",
      "mobile",
      "mbl",
      "mob",
      "number",
      "nmbr",
      "num",
      "contact",
      "cntct",
      "call",
      "phn",
      "cell",
      "whatsapp",
      "imo",
    ];
    return ResponseFilter.#containsAny(t, patterns);
  }

  static #containsDeliveryTopic(text) {
    const t = ResponseFilter.#norm(text);
    const patterns = [
      "delivery",
      "delivary",
      "delivary",
      "delvery",
      "deliveri",
      "deliver",
      "shipping",
      "shiping",
      "ship",
      "courier",
      "curier",
      "pathao",
      "steadfast",
      "sundarban",
      "charge",
      "delivery charge",
      "home delivery",
      "address",
      "addres",
      "location",
      "locaton",
      "loc",
      "area",
      "thana",
      "post office",
      "postcode",
    ];
    return ResponseFilter.#containsAny(t, patterns);
  }

  static #extractBangladeshPaymentMethods(text) {
    const t = ResponseFilter.#norm(text);

    // Keep it conservative: only Bangladesh-common methods
    const methodMatchers = [
      { name: "bKash", re: /\b(bkash|b kash|bkaash|bksh|bikash)\b/ },
      { name: "Nagad", re: /\b(nagad|nogod|nagod|nagad)\b/ },
      { name: "Rocket", re: /\b(rocket|roket|dbbl rocket|dbbl)\b/ },
      { name: "Upay", re: /\b(upay|upai|upoye)\b/ },
      { name: "Bank Transfer", re: /\b(bank|transfer|rtgs|beftn)\b/ },
      { name: "Card", re: /\b(card|visa|master|amex|debit|credit)\b/ },
      { name: "COD", re: /\b(cod|cash on delivery)\b/ },
      { name: "Cash", re: /\b(cash)\b/ },
    ];

    const found = [];
    for (const m of methodMatchers) {
      if (m.re.test(t)) found.push(m.name);
    }
    return found;
  }

  static #extractTransactionId(text) {
    const raw = String(text ?? "");
    const norm = ResponseFilter.#norm(raw);

    // Keywords (typo tolerant)
    const hasTrxKeyword = /\b(trx|trxn|trnx|txn|txid|transaction|transection)\b/.test(norm);
    if (!hasTrxKeyword) return null;

    // Try to capture an ID near keywords in raw text (keep alphanumeric)
    // Example: "TrxID: 8A7B12CD", "transaction id 1234567890", etc.
    const candidates = [];

    // Pattern 1: keyword then separator then id
    const re1 =
      /(trx(?:id)?|trxn|trnx|txn(?:id)?|txid|transaction(?:\s*id)?|transection(?:\s*id)?)\s*[:\-#]?\s*([a-zA-Z0-9]{6,30})/gi;
    let m;
    while ((m = re1.exec(raw)) !== null) {
      candidates.push(m[2]);
    }

    // Pattern 2: "id" explicitly
    const re2 = /\b(id)\s*[:\-#]?\s*([a-zA-Z0-9]{6,30})\b/gi;
    while ((m = re2.exec(raw)) !== null) {
      candidates.push(m[2]);
    }

    const uniq = Array.from(new Set(candidates)).filter(Boolean);
    return uniq[0] ?? null;
  }

  static #containsDhakaLocation(text) {
    // Uses your global dhakaRawList
    const list = Array.isArray(globalThis.dhakaRawList)
      ? globalThis.dhakaRawList
      : (typeof dhakaRawList !== "undefined" ? dhakaRawList : []);

    if (!list.length) {
      console.log("[ResponseFilter] dhakaRawList not found / empty");
      return false;
    }

    const t = ResponseFilter.#norm(text);

    // Build a quick lookup once (cached on the class)
    if (!ResponseFilter._dhakaLookup) {
      ResponseFilter._dhakaLookup = new Set(list.map((x) => ResponseFilter.#norm(x)));
      console.log("[ResponseFilter] Built Dhaka lookup set:", ResponseFilter._dhakaLookup.size);
    }

    // Fast contains check:
    // - For single tokens: includes check
    // - For multi-word: also includes check (because norm keeps spaces)
    for (const loc of ResponseFilter._dhakaLookup) {
      if (!loc) continue;
      if (t.includes(loc)) return true;
    }
    return false;
  }
}
//[login_image] [registration_image] [cart_image] [checkout_image]

//[payment_method_image] [payment_details_image] [place_order_image]

//[wishlist_image] [reviews_image] [write_review_image]

// Cache the built system so you don’t rebuild it every call
let _systemPromise = null;
async function getSearchSystem() {
  if (!_systemPromise) _systemPromise = buildSearchSystem();
  return _systemPromise;
}

// General function: takes ANY variable, parses it into a clean user query string
function parseUserInput(inputVar) {
  return String(inputVar ?? "").trim();
}

// Main function: returns ONLY the final text
async function runSearchAndReturnFinalText(userInputVar) {
  const userQuery = parseUserInput(userInputVar);
  if (!userQuery) return "";

  const system = await getSearchSystem();

  const out = await system.run(userQuery, {
    product: {
      topKProducts: 2,
      topKFields: 180,
      focus: { favorNumbers: 2.0, favorMeaning: 1.25, favorTokens: 1.4 },
      // keywordBoost: { words: ["iphone", "pro", "max"], addPerHit: 0.02, maxAdd: 0.08 }
    },
    conversation: {
      topK: 3,
      focus: { favorMeaning: 1.4, favorTokens: 1.2 },
    },
    conversationQueryStrategy: "raw", // or "appendProductName"
  });

  // Return ONLY the final text (no debug)
  return new ResponseFilter(out.productOut.results, out.messageOut.results, userInputVar)
    .replacePlaceholders();
}



function sendBotResponse(user_input) {
  runSearchAndReturnFinalText(user_input)
    .then((response) => {
      console.log(response);

      const typingIndicator = document.getElementById('typingIndicator');
      if (typingIndicator) typingIndicator.remove();

      const botMessage = {
        id: Date.now(),
        sender: 'bot',
        content: response,
        timestamp: new Date().toISOString(),
        status: 'read'
      };

      addMessageToChat(botMessage);
      chatMessages.push(botMessage);
      saveChatMessages();
      updateLastUserMessageStatus('delivered');
    })
    .catch((err) => {
      console.error("Search failed:", err);
    });
}

function updateLastUserMessageStatus(status) {
    // Find the last user message
    const userMessages = chatMessages.filter(msg => msg.sender === 'user');
    if (userMessages.length === 0) return;
    
    const lastUserMessage = userMessages[userMessages.length - 1];
    lastUserMessage.status = status;
    
    // Update in DOM
    const messageElement = document.querySelector(`[data-message-id="${lastUserMessage.id}"]`);
    if (messageElement) {
        const statusElement = messageElement.querySelector('.message-status');
        if (statusElement) {
            statusElement.className = `message-status ${status}`;
            statusElement.innerHTML = getStatusIcon(status);
        }
    }
    
    saveChatMessages();
}

function markChatMessagesAsRead() {
    chatMessages.forEach(message => {
        if (message.sender === 'user') {
            message.status = 'read';
        }
    });
    
    // Update in DOM
    document.querySelectorAll('.chat-message.message-outgoing .message-status').forEach(el => {
        el.className = 'message-status read';
        el.innerHTML = getStatusIcon('read');
    });
    
    saveChatMessages();
}

function scrollChatToBottom() {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (chatMessagesContainer) {
        chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
    }
}

function saveChatMessages() {
    try {
        // Keep only last 100 messages to prevent storage overflow
        if (chatMessages.length > 100) {
            chatMessages = chatMessages.slice(-100);
        }
        localStorage.setItem('shopure_chat_messages', JSON.stringify(chatMessages));
    } catch (error) {
        console.error('Error saving chat messages:', error);
    }
}

// ===== CHAT UTILITY FUNCTIONS =====
function groupMessagesByDate(messages) {
    const grouped = {};
    const today = new Date().toDateString();
    
    messages.forEach(message => {
        const messageDate = new Date(message.timestamp).toDateString();
        const dateKey = messageDate === today ? 'today' : messageDate;
        
        if (!grouped[dateKey]) {
            grouped[dateKey] = [];
        }
        grouped[dateKey].push(message);
    });
    
    return grouped;
}

function formatChatDate(dateString) {
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    if (date.toDateString() === today.toDateString()) {
        return 'Today';
    } else if (date.toDateString() === yesterday.toDateString()) {
        return 'Yesterday';
    } else {
        return date.toLocaleDateString('en-US', { 
            weekday: 'short', 
            month: 'short', 
            day: 'numeric' 
        });
    }
}

function formatChatTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffHours = (now - date) / (1000 * 60 * 60);
    
    if (diffHours < 1) {
        const diffMinutes = Math.floor(diffHours * 60);
        if (diffMinutes < 1) return 'Just now';
        if (diffMinutes < 2) return '1 minute ago';
        return `${diffMinutes} minutes ago`;
    } else if (diffHours < 24) {
        const hours = Math.floor(diffHours);
        if (hours < 2) return '1 hour ago';
        return `${hours} hours ago`;
    } else {
        return date.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true
        });
    }
}

function getStatusIcon(status) {
    switch(status) {
        case 'sent':
            return '<i class="fas fa-check"></i>';
        case 'delivered':
            return '<i class="fas fa-check-double"></i>';
        case 'read':
            return '<i class="fas fa-check-double" style="color: var(--primary-color)"></i>';
        default:
            return '<i class="fas fa-check"></i>';
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML.replace(/\n/g, '<br>');
}

// ===== CHAT CLEANUP FUNCTION =====
function clearChatHistory() {
    if (confirm('Are you sure you want to clear all chat history?')) {
        chatMessages = [];
        localStorage.removeItem('shopure_chat_messages');
        showToast('Chat history cleared', 'success');
        
        // Reload chat if modal is open
        if (document.getElementById('chatModal').classList.contains('active')) {
            loadChatMessages();
        }
    }
}
        // ===== ORDER FUNCTIONS =====
        function showOrderModal() {
            if (!currentUser) {
                showToast('Please login to checkout', 'error');
                showProfileModal();
                return;
            }
            
            if (cart.length === 0) {
                showToast('Your cart is empty', 'error');
                return;
            }
            
            // Pre-fill user info
            document.getElementById('orderName').value = currentUser.name || '';
            document.getElementById('orderEmail').value = currentUser.email || '';
            document.getElementById('orderPhone').value = currentUser.phone || '';
            document.getElementById('orderAddress').value = currentUser.address || '';
            
            // Set default city and postal code
            document.getElementById('orderCity').value = 'Dhaka';
            document.getElementById('orderPostalCode').value = '1200';
            
            showModal('orderModal');
        }

        function handleOrderSubmit(e) {
            e.preventDefault();
            
            // Get form data
            const orderData = {
                name: document.getElementById('orderName').value.trim(),
                phone: document.getElementById('orderPhone').value.trim(),
                email: document.getElementById('orderEmail').value.trim(),
                address: document.getElementById('orderAddress').value.trim(),
                city: document.getElementById('orderCity').value.trim(),
                postalCode: document.getElementById('orderPostalCode').value.trim(),
                                // Get selected payment method
                paymentMethod: document.querySelector('.newPaymentMethod')?.value || '',

                // Get transaction ID
                transactionId: document.getElementById('transactionId')?.value.trim() || '',

                // Get payment amount
                paymentAmount: parseFloat(document.getElementById('paymentAmount')?.value) || 0,

                // Get last 3 digits
                lastThreeDigits: document.getElementById('lastThreeDigits')?.value.trim() || ''
            };
            
            // Validation
            if (!orderData.name || !orderData.phone || !orderData.email || !orderData.address || !orderData.city || !orderData.postalCode) {
                showToast('Please fill in all fields', 'error');
                return;
            }
            
            // For non-COD payments, require transaction ID and amount
            if (orderData.paymentMethod !== 'cod') {
                if (!orderData.transactionId) {
                    showToast('Please enter transaction ID', 'error');
                    return;
                }
                if (!orderData.paymentAmount || orderData.paymentAmount <= 0) {
                    showToast('Please enter payment amount', 'error');
                    return;
                }
            }
            
            // Calculate totals
            const subtotal = cart.reduce((total, item) => {
                const product = products.find(p => p.id === item.productId);
                return total + (product?.price || 0) * item.quantity;
            }, 0);
            
            const shipping = subtotal > 100 ? 0 : 5.99;
            const tax = subtotal * 0.08;
            const total = subtotal + shipping + tax;
            
            // Validate payment amount if provided
            // Validate payment amount - minimum 60 only
            if (orderData.paymentMethod !== 'cod' && orderData.paymentAmount < 60) {
                showToast(`Payment amount must be at least <b><strong>৳</strong></b>60. You entered <b><strong>৳</strong></b>${orderData.paymentAmount.toFixed(2)}`, 'error');
                return;
            }
            
            // Create order
            const order = {
                id: Date.now(),
                userId: currentUser.id,
                items: [...cart],
                total: total,
                subtotal: subtotal,
                shipping: shipping,
                tax: tax,
                status: 'pending',
                payment: {
                    method: orderData.paymentMethod,
                    transactionId: orderData.transactionId || null,
                    amount: orderData.paymentAmount || total,
                    digits: orderData.lastThreeDigits
                },
                shippingInfo: {
                    name: orderData.name,
                    phone: orderData.phone,
                    email: orderData.email,
                    address: orderData.address,
                    city: orderData.city,
                    postalCode: orderData.postalCode
                },
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            sendOrderData(order);
            // Add to orders
            orders.push(order);
            
            // Update user stats
            const user = users.find(u => u.id === currentUser.id);
            if (user) {
                user.orders.push(order.id);
                user.totalSpent = (user.totalSpent || 0) + total;
                user.totalOrders = (user.totalOrders || 0) + 1;
                user.updatedAt = new Date().toISOString();
            }
            
            // Track purchases
            cart.forEach(item => {
                trackInteraction(item.productId, 'purchase');
                trackActivity('product_purchase', item.productId);
                
                // Update product stock
                const product = products.find(p => p.id === item.productId);
                if (product) {
                    product.stock = Math.max(0, product.stock - item.quantity);
                    product.updatedAt = new Date().toISOString();
                }
            });
            
            // Clear cart
            cart = [];
            updateCartCount();
            saveToLocalStorage();
            
            // Hide modals
            hideModal('orderModal');
            hideModal('cartModal');
            
            // Show success message
            showToast(`Wait for the confirmation! message #${order.id}`, 'procssing..');
            
            // Reset form
            document.getElementById('orderForm').reset();
        }

        // ===== GALLERY MODAL =====
        function showGalleryModal(images, startIndex = 0) {
            const galleryThumbnails = document.getElementById('galleryThumbnails');
            const galleryMainImage = document.getElementById('galleryMainImage');
            
            if (!galleryThumbnails || !galleryMainImage) return;
            
            // Clear existing thumbnails
            galleryThumbnails.innerHTML = '';
            
            // Add thumbnails
            images.forEach((img, index) => {
                const thumbnail = document.createElement('img');
                thumbnail.src = img;
                thumbnail.alt = `Product image ${index + 1}`;
                thumbnail.className = `thumbnail ${index === startIndex ? 'active' : ''}`;
                thumbnail.onclick = () => {
                    // Update main image
                    galleryMainImage.src = img;
                    
                    // Update active thumbnail
                    document.querySelectorAll('#galleryThumbnails .thumbnail').forEach(t => {
                        t.classList.remove('active');
                    });
                    thumbnail.classList.add('active');
                };
                
                galleryThumbnails.appendChild(thumbnail);
            });
            
            // Set initial main image
            galleryMainImage.src = images[startIndex];
            
            showModal('galleryModal');
        }

        // ===== ZOOM MODAL =====
        function showZoomModal(imageUrl) {
            const zoomedImage = document.getElementById('zoomedImage');
            if (zoomedImage) {
                zoomedImage.src = imageUrl;
                // Reset zoom state
                zoomedImage.style.transform = 'scale(1)';
                zoomedImage.classList.remove('zoomed');
                showModal('zoomModal');
            }
        }

        // ===== MOBILE NAVIGATION HANDLERS =====
        function handleMobileProfile() {
            hideMobileMenu();
            showProfileModal();
        }

        function handleMobileWishlist() {
            hideMobileMenu();
            showWishlistModal();
        }

        function handleMobileCart() {
            hideMobileMenu();
            showCartModal();
        }

        function handleMobileContact() {
            hideMobileMenu();
            showContactModal();
        }

        function handleMobileSuggestions() {
            hideMobileMenu();
            showSuggestionsModal();
        }

        function handleMobileOrders() {
            hideMobileMenu();
            showToast('Orders page coming soon!', 'info');
        }

        function handleMobileReturns() {
            hideMobileMenu();
            showToast('Returns page coming soon!', 'info');
        }

        function handleMobileLiveChat() {
            hideMobileMenu();
            showChatModal();
        }
                function formatTimeAgo(date) {
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);
                    
                    if (diffMins < 1) return 'Just now';
                    if (diffMins < 60) return `${diffMins}m ago`;
                    if (diffHours < 24) return `${diffHours}h ago`;
                    if (diffDays < 7) return `${diffDays}d ago`;
                    return formatDate(date);
                }

                function formatTime(ms) {
                    if (ms < 1000) return `${ms}ms`;
                    if (ms < 60000) return `${(ms/1000).toFixed(1)}s`;
                    if (ms < 3600000) return `${Math.floor(ms/60000)}m ${Math.floor((ms%60000)/1000)}s`;
                    return `${Math.floor(ms/3600000)}h ${Math.floor((ms%3600000)/60000)}m`;
                }

                function handleBeforeUnload() {
                    // Track view time before leaving
                    Object.keys(nanoTimeTracker).forEach(productId => {
                        const viewTime = performance.now() - nanoTimeTracker[productId];
                        trackInteraction(productId, 'viewTime', Math.round(viewTime));
                        trackActivity('product_view_end', productId, Math.round(viewTime));
                        delete nanoTimeTracker[productId];
                    });
                    
                    // Update user activity before leaving
                    if (currentUser && userActivityTimers[currentUser.id]) {
                        const sessionTime = Date.now() - userActivityTimers[currentUser.id];
                        updateUserActivity(sessionTime);
                        delete userActivityTimers[currentUser.id];
                    }
                    
                    // Clear intervals
                    clearInterval(placeholderInterval);
                    clearInterval(slideInterval);
                    clearInterval(screenTimeInterval);
                    
                    saveToLocalStorage();
                }

                // ===== FIX REVIEW MODAL FUNCTIONALITY =====
        // This will fix all review modal issues

        function initializeReviewModal() {
            //console.log('Initializing review modal...');
            
            // 1. Fix close/cancel buttons
            const closeReviewModal = document.getElementById('closeReviewModal');
            const cancelReviewBtn = document.getElementById('cancelReviewBtn');
            
            if (closeReviewModal) {
                closeReviewModal.onclick = function(e) {
                    e.preventDefault();
                    hideModal('reviewModal');
                };
            }
            
            if (cancelReviewBtn) {
                cancelReviewBtn.onclick = function(e) {
                    e.preventDefault();
                    hideModal('reviewModal');
                };
            }
            
            // 2. Fix star rating
            const ratingStars = document.querySelectorAll('.rating-star-input');
            const ratingValue = document.getElementById('ratingValue');
            
            ratingStars.forEach(star => {
                // Remove existing listeners
                star.replaceWith(star.cloneNode(true));
            });
            
            // Get fresh references
            const freshStars = document.querySelectorAll('.rating-star-input');
            
            freshStars.forEach(star => {
                star.onmouseenter = function() {
                    const value = parseInt(this.dataset.value);
                    freshStars.forEach((s, index) => {
                        if (index < value) {
                            s.classList.add('hover');
                        } else {
                            s.classList.remove('hover');
                        }
                    });
                };
                
                star.onmouseleave = function() {
                    freshStars.forEach(s => s.classList.remove('hover'));
                };
                
                star.onclick = function() {
                    const value = parseInt(this.dataset.value);
                    
                    // Update stars
                    freshStars.forEach((s, index) => {
                        if (index < value) {
                            s.classList.add('active');
                        } else {
                            s.classList.remove('active');
                        }
                    });
                    
                    // Update value display
                    if (ratingValue) ratingValue.textContent = value.toFixed(1);
                };
            });
            
            // 3. Fix image upload
            const uploadArea = document.getElementById('uploadArea');
            const reviewImagesInput = document.getElementById('reviewImages');
            
            if (uploadArea && reviewImagesInput) {
                uploadArea.onclick = function() {
                    reviewImagesInput.click();
                };
                
                reviewImagesInput.onchange = function(e) {
                    handleReviewImageUpload(e);
                };
            }
            
            // 4. Fix form submission
            const reviewForm = document.getElementById('reviewForm');
            if (reviewForm) {
                reviewForm.onsubmit = function(e) {
                    e.preventDefault();
                    handleReviewSubmit(e);
                };
            }
            
            //console.log('Review modal initialized');
        }

        // Fix the showReviewModal function
        function fixShowReviewModal(productId) {
            if (!currentUser) {
                showToast('Please login to write a review', 'error');
                showProfileModal();
                return;
            }
            
            // Reset form
            document.getElementById('reviewProductId').value = productId;
            document.getElementById('reviewTitle').value = '';
            document.getElementById('reviewText').value = '';
            document.getElementById('uploadedImagesPreview').innerHTML = '';
            
            // Reset stars
            const ratingStars = document.querySelectorAll('.rating-star-input');
            const ratingValue = document.getElementById('ratingValue');
            ratingStars.forEach(star => star.classList.remove('active'));
            if (ratingValue) ratingValue.textContent = '0.0';
            
            showModal('reviewModal');
            
            // Initialize modal functionality
            setTimeout(initializeReviewModal, 50);
        }

        // Override the existing showReviewModal function
        window.showReviewModal = fixShowReviewModal;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Call after a short delay to ensure DOM is ready
            setTimeout(initializeReviewModal, 1000);
        });

        // Also initialize when any modal opens (in case review modal was added dynamically)
        document.addEventListener('click', function(e) {
            if (e.target && e.target.classList && e.target.classList.contains('modal-overlay')) {
                if (e.target.id === 'reviewModal') {
                    setTimeout(initializeReviewModal, 50);
                }
            }
        });

        // Make sure Write Review button works
        document.addEventListener('click', function(e) {
            if (e.target && (e.target.id === 'writeReviewBtn' || e.target.closest('#writeReviewBtn'))) {
                e.preventDefault();
                const productId = e.target.dataset.productId || 
                                e.target.closest('#writeReviewBtn')?.dataset.productId ||
                                document.querySelector('.product-title-large')?.dataset.productId;
                if (productId) {
                    fixShowReviewModal(productId);
                }
            }
        });


        function showEnglish() {
            document.querySelector('.bangla-message').classList.remove('active');
            document.querySelector('.english-message').classList.add('active');
        }

        function showBangla() {
            document.querySelector('.english-message').classList.remove('active');
            document.querySelector('.bangla-message').classList.add('active');
        }
// ===== VALIDATE PAYMENT FIELDS ONLY =====
function validatePaymentFields() {
    //console.log('Checking payment fields...');
    
    // Get the 3 payment fields
    const transactionId = document.getElementById('transactionId')?.value.trim() || '';
    const paymentAmount = document.getElementById('paymentAmount')?.value.trim() || '';
    const lastThreeDigits = document.getElementById('lastThreeDigits')?.value.trim() || '';
    
    //console.log('Transaction ID:', transactionId, 'Length:', transactionId.length);
    //console.log('Payment Amount:', paymentAmount, 'Length:', paymentAmount.length);
    //console.log('Last 3 Digits:', lastThreeDigits, 'Length:', lastThreeDigits.length);
    
    // Check if all 3 fields have values (non-empty)
    const allFilled = transactionId.length > 0 && paymentAmount.length > 0 && lastThreeDigits.length > 0;
    
    //console.log('All fields filled?', allFilled);
    
    // Get the Place Order button - use the correct selector
    const placeOrderBtn = document.querySelector('#orderForm button[type="submit"]');
    if (placeOrderBtn) {
        //console.log('Button found, setting disabled to:', !allFilled);
        placeOrderBtn.disabled = !allFilled;
        placeOrderBtn.style.opacity = allFilled ? '1' : '0.6';
        placeOrderBtn.style.cursor = allFilled ? 'pointer' : 'not-allowed';
    } else {
        //console.log('Button NOT found! Check your HTML structure.');
    }
}

// Set up validation when order modal opens
document.addEventListener('DOMContentLoaded', function() {
    //console.log('DOM loaded, setting up payment validation...');
    
    // Try multiple ways to trigger validation setup
    const checkoutBtn = document.getElementById('checkoutBtn');
    if (checkoutBtn) {
        //console.log('Checkout button found');
        checkoutBtn.addEventListener('click', function() {
            //console.log('Checkout clicked, setting up payment field listeners...');
            
            // Wait for modal to appear
            setTimeout(function() {
                // Add input listeners to the 3 payment fields
                const paymentFields = ['transactionId', 'paymentAmount', 'lastThreeDigits'];
                
                paymentFields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        //console.log('Adding listener to:', fieldId);
                        // Remove any existing listeners first
                        field.removeEventListener('input', validatePaymentFields);
                        // Add new listener
                        field.addEventListener('input', validatePaymentFields);
                        // Also add change listener for select/dropdown
                        field.addEventListener('change', validatePaymentFields);
                    } else {
                        //console.log('Field not found:', fieldId);
                    }
                });
                
                // Initial check
                validatePaymentFields();
            }, 500); // Increased delay to ensure modal is fully loaded
        });
    } else {
        //console.log('Checkout button NOT found!');
    }
    
    // Also set up validation when order modal itself opens (backup)
    document.addEventListener('click', function(e) {
        if (e.target && (e.target.id === 'checkoutBtn' || e.target.closest('#checkoutBtn'))) {
            setTimeout(validatePaymentFields, 600);
        }
    });
});       


        //console.log('Review modal fix loaded');




        // Make sure the function is available globally
        window.generateSuggestions = generateSuggestions;
        window.showSuggestionsModal = showSuggestionsModal;
        // Make functions available globally for inline event handlers
        // Make functions available globally
        window.showContactModal = showContactModal;
        window.showChatModal = showChatModal;
        window.showModal = showModal;
        window.hideModal = hideModal;
        window.sendChatMessage = sendChatMessage;
        window.showOrderModal = showOrderModal;
        window.showGalleryModal = showGalleryModal;
        window.showZoomModal = showZoomModal;
        window.showMobileMenu = showMobileMenu;
        window.hideMobileMenu = hideMobileMenu;
        window.scrollToTop = scrollToTop;

        // Navigation functions
        window.navigateTo = navigateTo;
        window.viewProduct = viewProduct;
        window.loadHomePage = loadHomePage;

        // Cart and Wishlist functions
        window.addToCart = addToCart;
        window.toggleWishlist = toggleWishlist;
        window.showCartModal = showCartModal;
        window.showWishlistModal = showWishlistModal;

        // User functions
        window.showProfileModal = showProfileModal;

        // Search and Filter functions
        window.handleSearch = handleSearch;
        window.filterProductsByCategory = filterProductsByCategory;
        window.loadStorePage = loadStorePage;

        // Review functions
        window.showReviewModal = showReviewModal;

        // Utility functions
        window.showToast = showToast;
        window.formatDate = formatDate;
        window.formatTimeAgo = formatTimeAgo;
    </script>
</body>
</html>
